// RUN: %target-sil-opt -enable-sil-verify-all %s -predictable-deadalloc-elim | %FileCheck %s

sil_stage canonical

import Swift
import Builtin

// CHECK-LABEL: sil @simple_trivial_stack : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'simple_trivial_stack'
sil @simple_trivial_stack : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_stack $Builtin.Int32
  store %0 to %1 : $*Builtin.Int32
  dealloc_stack %1 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @simple_trivial_init_box : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_box
// CHECK: } // end sil function 'simple_trivial_init_box'
sil @simple_trivial_init_box : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_box ${ var Builtin.Int32 }
  %2 = project_box %1 : ${ var Builtin.Int32 }, 0
  store %0 to %2 : $*Builtin.Int32
  strong_release %1 : ${ var Builtin.Int32 }
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @simple_trivial_uninit_box : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_box
// CHECK: } // end sil function 'simple_trivial_uninit_box'
sil @simple_trivial_uninit_box : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_box ${ var Builtin.Int32 }
  %2 = project_box %1 : ${ var Builtin.Int32 }, 0
  store %0 to %2 : $*Builtin.Int32
  dealloc_box %1 : ${ var Builtin.Int32 }
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @simple_nontrivial_stack : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] :
// CHECK-NEXT: strong_release [[ARG]]
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK: } // end sil function 'simple_nontrivial_stack'
sil @simple_nontrivial_stack : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.NativeObject):
  %1 = alloc_stack $Builtin.NativeObject
  store %0 to %1 : $*Builtin.NativeObject
  destroy_addr %1 : $*Builtin.NativeObject
  dealloc_stack %1 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this today, since we do not understand that we need to treat
// the strong_release of the alloc_box as a destroy_addr of the entire value.
//
// FIXME: We should be able to handle this.
//
// CHECK-LABEL: sil @simple_nontrivial_init_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: alloc_box
// CHECK: } // end sil function 'simple_nontrivial_init_box'
sil @simple_nontrivial_init_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.NativeObject):
  %1 = alloc_box ${ var Builtin.NativeObject }
  %2 = project_box %1 : ${ var Builtin.NativeObject }, 0
  store %0 to %2 : $*Builtin.NativeObject
  strong_release %1 : ${ var Builtin.NativeObject }
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @simple_nontrivial_uninit_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] :
// CHECK-NEXT: strong_release [[ARG]]
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK: } // end sil function 'simple_nontrivial_uninit_box'
sil @simple_nontrivial_uninit_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.NativeObject):
  %1 = alloc_box ${ var Builtin.NativeObject }
  %2 = project_box %1 : ${ var Builtin.NativeObject }, 0
  store %0 to %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_box %1 : ${ var Builtin.NativeObject }
  %9999 = tuple()
  return %9999 : $()
}
