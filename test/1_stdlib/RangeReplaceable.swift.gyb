// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/RangeReplaceable.swift
// RUN: %S/../../utils/line-directive %t/RangeReplaceable.swift -- %target-build-swift %t/RangeReplaceable.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/RangeReplaceable.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest

var RangeReplaceableTestSuite = TestSuite("RangeReplaceable")

RangeReplaceableTestSuite.test("append/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.append(OpaqueValue(2))
  expectCustomizable(tester, tester.log.append)
}

RangeReplaceableTestSuite.test("appendContentsOf/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.appendContentsOf([ 2, 3 ].map(OpaqueValue.init))
  expectCustomizable(tester, tester.log.appendContentsOf)
}

RangeReplaceableTestSuite.test("insert/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.insert(OpaqueValue(2), atIndex: tester.base.startIndex)
  expectCustomizable(tester, tester.log.insert)
}

RangeReplaceableTestSuite.test("insertContentsOf/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.insertContentsOf(
    [ 2, 3 ].map(OpaqueValue.init),
    at: tester.base.endIndex)
  expectCustomizable(tester, tester.log.insertContentsOf)
}

RangeReplaceableTestSuite.test("removeAtIndex/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeAtIndex(tester.base.startIndex)
  expectCustomizable(tester, tester.log.removeAtIndex)
}

RangeReplaceableTestSuite.test("removeLast/whereIndexIsBidirectional/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  _ = tester.removeLast()
  expectCustomizable(tester, tester.log._customRemoveLast)
}

RangeReplaceableTestSuite.test("removeRange/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester(
    [ 1, 2, 3 ].map(OpaqueValue.init))
  tester.removeRange(tester.base.startIndex..<tester.base.endIndex)
  expectCustomizable(tester, tester.log.removeRange)
}

RangeReplaceableTestSuite.test("removeFirst/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeFirst()
  expectCustomizable(tester, tester.log.removeFirst)
}

RangeReplaceableTestSuite.test("removeFirst(n)/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeFirst(1)
  expectCustomizable(tester, tester.log.removeFirstN)
}

RangeReplaceableTestSuite.test("removeAll/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeAll(keepCapacity: false)
  expectCustomizable(tester, tester.log.removeAll)
}

RangeReplaceableTestSuite.test("reserveCapacity/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester(Array<Int>())
  tester.reserveCapacity(10)
  expectCustomizable(tester, tester.log.reserveCapacity)
}

func identity(element: OpaqueValue<Int>) -> OpaqueValue<Int> {
  return element
}
func identityEq(element: MinimalEquatableValue) -> MinimalEquatableValue {
  return element
}

% for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:
%   for base_kind in [ 'Defaulted', 'Minimal' ]:
// This comment is a workaround for <rdar://problem/18900352> gyb miscompiles nested loops
%     Base = "%s%sRangeReplaceableCollection" % (base_kind, traversal)

if true {
  var resiliencyChecks = CollectionMisuseResiliencyChecks.all
  resiliencyChecks.creatingOutOfBoundsIndicesBehavior = .ExpectationFailure

  RangeReplaceableTestSuite.add${traversal}RangeReplaceableCollectionTests(
    makeCollection: { (elements: [OpaqueValue<Int>]) in
      return ${Base}(elements: elements)
    },
    wrapValue: identity,
    extractValue: identity,
    makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
      return ${Base}(elements: elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    resiliencyChecks: resiliencyChecks)

  RangeReplaceableTestSuite.add${traversal}RangeReplaceableCollectionTests(
    makeCollection: { (elements: [LifetimeTracked]) in
      return ${Base}(elements: elements)
    },
    wrapValue: { (element: OpaqueValue<Int>) in LifetimeTracked(element.value) },
    extractValue: { (element: LifetimeTracked) in OpaqueValue(element.value) },
    makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
      // FIXME: use LifetimeTracked.
      return ${Base}(elements: elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    resiliencyChecks: resiliencyChecks)
}

%   end
% end

runAllTests()

