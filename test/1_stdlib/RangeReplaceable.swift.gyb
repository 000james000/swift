// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/RangeReplaceable.swift
// RUN: %S/../../utils/line-directive %t/RangeReplaceable.swift -- %target-build-swift %t/RangeReplaceable.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/RangeReplaceable.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest

var RangeReplaceableTestSuite = TestSuite("RangeReplaceable")

RangeReplaceableTestSuite.test("append/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.append(OpaqueValue(2))
  expectCustomizable(tester, tester.log.append)
}

RangeReplaceableTestSuite.test("extend/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.extend([ 2, 3 ].map { OpaqueValue($0) })
  expectCustomizable(tester, tester.log.extend)
}

RangeReplaceableTestSuite.test("insert/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.insert(OpaqueValue(2), atIndex: tester.base.startIndex)
  expectCustomizable(tester, tester.log.insert)
}

RangeReplaceableTestSuite.test("splice/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.splice(
    [ 2, 3 ].map { OpaqueValue($0) },
    atIndex: tester.base.endIndex)
  expectCustomizable(tester, tester.log.splice)
}

RangeReplaceableTestSuite.test("removeAtIndex/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeAtIndex(tester.base.startIndex)
  expectCustomizable(tester, tester.log.removeAtIndex)
}

RangeReplaceableTestSuite.test("removeLast/whereIndexIsBidirectional/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  _ = tester.removeLast()
  expectCustomizable(tester, tester.log._customRemoveLast)
}

RangeReplaceableTestSuite.test("removeRange/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester(
    [ 1, 2, 3 ].map { OpaqueValue($0) })
  tester.removeRange(tester.base.startIndex..<tester.base.endIndex)
  expectCustomizable(tester, tester.log.removeRange)
}

RangeReplaceableTestSuite.test("removeFirst/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeFirst()
  expectCustomizable(tester, tester.log.removeFirst)
}

RangeReplaceableTestSuite.test("removeFirst(n)/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeFirst(1)
  expectCustomizable(tester, tester.log.removeFirstN)
}

RangeReplaceableTestSuite.test("removeAll/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester([ OpaqueValue(1) ])
  tester.removeAll(keepCapacity: false)
  expectCustomizable(tester, tester.log.removeAll)
}

RangeReplaceableTestSuite.test("reserveCapacity/dispatch") {
  var tester = RangeReplaceableCollectionLog.dispatchTester(Array<Int>())
  tester.reserveCapacity(10)
  expectCustomizable(tester, tester.log.reserveCapacity)
}

func identity(element: OpaqueValue<Int>) -> OpaqueValue<Int> {
  return element
}
func identityEq(element: MinimalEquatableValue) -> MinimalEquatableValue {
  return element
}

% for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:
%   for base_kind in [ 'Defaulted', 'Minimal' ]:
// This comment is a workaround for <rdar://problem/18900352> gyb miscompiles nested loops
%     Base = "%s%sRangeReplaceableCollection" % (base_kind, traversal)

RangeReplaceableTestSuite.add${traversal}RangeReplaceableCollectionTests(
  makeCollection: { (elements: [OpaqueValue<Int>]) in
    return ${Base}(elements)
  },
  wrapValue: identity,
  extractValue: identity,
  makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
    return ${Base}(elements)
  },
  wrapValueIntoEquatable: identityEq,
  extractValueFromEquatable: identityEq)

RangeReplaceableTestSuite.add${traversal}RangeReplaceableCollectionTests(
  makeCollection: { (elements: [LifetimeTracked]) in
    return ${Base}(elements)
  },
  wrapValue: { (element: OpaqueValue<Int>) in LifetimeTracked(element.value) },
  extractValue: { (element: LifetimeTracked) in OpaqueValue(element.value) },
  makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
    // FIXME: use LifetimeTracked.
    return ${Base}(elements)
  },
  wrapValueIntoEquatable: identityEq,
  extractValueFromEquatable: identityEq)

%   end
% end

runAllTests()

