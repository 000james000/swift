// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb %s -o %t/out.swift
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-build-swift %t/out.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest

// Check that the generic parameter is called 'Bound'.
protocol TestProtocol1 {}

extension Range where Bound : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

extension CountableRange where Bound : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

var RangeTestSuite = TestSuite("Range")

% for (Self, Bound) in [
%  ('Range', 'MinimalComparableValue'),
%  ('CountableRange', 'MinimalStrideableValue'),
% ]:

RangeTestSuite.test("${Self}/Equatable") {
  let _1 = ${Bound}(1)
  let _2 = ${Bound}(2)

  let instances: [${Self}<${Bound}>] = [
    _1..<_1,
    _1..<_2,
    _2..<_2,
  ]
  checkEquatable(instances, oracle: { $0 == $1 })
}

RangeTestSuite.test("${Self}: '..<' traps when upperBound < lowerBound")
  .crashOutputMatches("Can't form Range with upperBound < lowerBound")
  .code {
  let _1 = ${Bound}(1)
  let _2 = ${Bound}(2)
  expectCrashLater()
  let range: ${Self}<${Bound}> = _2..<_1
  _blackHole(range)
}

% end

/*
// FIXME: swift-3-indexing-model: fix the printing test.

// Something to test with that distinguishes debugDescription from description
struct X<T : ForwardIndex> : ForwardIndex, CustomStringConvertible, CustomDebugStringConvertible {
  init(_ a: T) {
    self.a = a
  }

  func successor() -> X {
    return X(a.successor())
  }

  var description: String {
    return String(a)
  }

  var debugDescription: String {
    return "X(\(String(reflecting: a)))"
  }

  var a: T
}

func == <T : ForwardIndex>(lhs: X<T>, rhs: X<T>) -> Bool {
  return lhs.a == rhs.a
}

RangeTestSuite.test("Printing") {
  expectEqual("0..<10", String(X(0)..<X(10)))
  expectEqual("Range(X(0)..<X(10))", String(reflecting: Range(X(0)..<X(10))))

  // No separate representation for closed Ranges yet
  expectEqual("10..<42", String(X(10)...X(41)))
  expectEqual("Range(X(10)..<X(42))", String(reflecting: Range(X(10)...X(41))))
}
*/

RangeTestSuite.test("Pattern matching") {
  let x = 0..<20
  expectTrue(x ~= 10)
  expectFalse(x ~= 20)
  expectFalse(x ~= -1)

  // <rdar://21091371>.  Timeouts should make this test fail if this
  // ends up doing a linear search.
  expectFalse(1_000_000..<(1_000_000_000_000 as Int64) ~= 1)
}

RangeTestSuite.test("map()") {
  // <rdar://problem/17054014> map method should exist on ranges
  var result = (1..<4).map { $0*2 }
  expectType(Array<Int>.self, &result)
  expectEqualSequence([ 2, 4, 6 ], result)
}

RangeTestSuite.test("reversed()") {
  var result = (0..<10).lazy.reversed()
  typealias Expected = LazyRandomAccessCollection<
    ReversedRandomAccessCollection<CountableRange<Int>>>
    expectType(Expected.self, &result)
  expectEqualSequence(
    [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],
    result)
}

RangeTestSuite.test("CountableRange: CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable") {
  var r: CountableRange<CustomPrintableValue> =
    CustomPrintableValue(1)..<CustomPrintableValue(2)
  expectPrinted(
    "(value: 1).description..<(value: 2).description", r)
  expectDebugPrinted(
    "CountableRange(" +
      "(value: 1).debugDescription..<(value: 2).debugDescription" +
    ")",
    r)
  expectDumped(
    "▿ CountableRange((value: 1).debugDescription..<(value: 2).debugDescription)\n" +
    "  ▿ lowerBound: (value: 1).debugDescription\n" +
    "    - value: 1\n" +
    "    - identity: 0\n" +
    "  ▿ upperBound: (value: 2).debugDescription\n" +
    "    - value: 2\n" +
    "    - identity: 0\n",
    r)
}

RangeTestSuite.test("Range: CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable") {
  var r: Range<CustomPrintableValue> =
    CustomPrintableValue(1)..<CustomPrintableValue(2)
  expectPrinted(
    "(value: 1).description..<(value: 2).description", r)
  expectDebugPrinted(
    "Range(" +
      "(value: 1).debugDescription..<(value: 2).debugDescription" +
    ")",
    r)
  expectDumped(
    "▿ Range((value: 1).debugDescription..<(value: 2).debugDescription)\n" +
    "  ▿ lowerBound: (value: 1).debugDescription\n" +
    "    - value: 1\n" +
    "    - identity: 0\n" +
    "  ▿ upperBound: (value: 2).debugDescription\n" +
    "    - value: 2\n" +
    "    - identity: 0\n",
    r)
}

// FIXME: swift-3-indexing-model: check that CountableRange is a collection.
/*
func assertCollection<C: Collection>(_: C) {}
assertCollection(0..<10)
*/

// FIXME: swift-3-indexing-model: this test does not belong in this file.
RangeTestSuite.test("stride") {
  var result = [Double]()
  for i in stride(from: 1.4, through: 3.4, by: 1) {
    result.append(i)
  }
  expectEqual([ 1.4, 2.4, 3.4 ], result)
}

runAllTests()

