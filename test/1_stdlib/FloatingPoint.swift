// RUN: rm -rf %t && mkdir -p %t
// RUN: %target-build-swift %s -parse-stdlib -Xfrontend -disable-access-control -o %t/FloatingPoint
// RUN: %target-run %t/FloatingPoint

// XFAIL: interpret
// XFAIL: linux

import Swift
import StdlibUnittest

#if arch(i386) || arch(x86_64)

struct Float80Bits : Equatable, Printable {
  var signAndExponent: UInt16
  var significand: UInt64

  init(_ signAndExponent: UInt16, _ significand: UInt64) {
    self.signAndExponent = signAndExponent
    self.significand = significand
  }

  var description: String {
    return "(\(String(signAndExponent, radix: 16)) \(String(significand, radix: 16))))"
  }
}

func == (lhs: Float80Bits, rhs: Float80Bits) -> Bool {
  return
    lhs.signAndExponent == rhs.signAndExponent &&
    lhs.significand == rhs.significand
}

extension Float80 {
  func _toBitPattern() -> Float80Bits {
    let bits = Builtin.bitcast_FPIEEE80_Int80(self.value)
    let sixtyFour = Builtin.zextOrBitCast_Int64_Int80((64 as Int64).value)
    return Float80Bits(
      UInt16(Builtin.truncOrBitCast_Int80_Int16(
        Builtin.lshr_Int80(bits, sixtyFour))),
      UInt64(Builtin.truncOrBitCast_Int80_Int64(bits)))
  }

  static func _fromBitPattern(bits: Float80Bits) -> Float80 {
    var result = Builtin.shl_Int80(
      Builtin.zextOrBitCast_Int16_Int80(bits.signAndExponent.value),
      Builtin.zextOrBitCast_Int64_Int80((64 as Int64).value))
    result = Builtin.or_Int80(
      result, Builtin.zextOrBitCast_Int64_Int80(bits.significand.value))
    return Float80(_bits: Builtin.bitcast_Int80_FPIEEE80(result))
  }
}

#endif

func noinlinePlusZero() -> Float {
  return 0.0
}

func noinlineMinusZero() -> Float {
  return -0.0
}

func noinlinePlusZero() -> Double {
  return 0.0
}

func noinlineMinusZero() -> Double {
  return -0.0
}

var FloatingPoint = TestSuite("FloatingPoint")

// Tests the float and int conversions work correctly. Each case is special.
FloatingPoint.test("Float/UInt8") {
  expectEqual(UInt8.min, UInt8(Float(UInt8.min)))
  expectEqual(UInt8.max, UInt8(Float(UInt8.max)))
}

FloatingPoint.test("Float/Int8") {
  expectEqual(Int8.min, Int8(Float(Int8.min)))
  expectEqual(Int8.max, Int8(Float(Int8.max)))
}

FloatingPoint.test("Float/UInt16") {
  expectEqual(UInt16.min, UInt16(Float(UInt16.min)))
  expectEqual(UInt16.max, UInt16(Float(UInt16.max)))
}

FloatingPoint.test("Float/Int16") {
  expectEqual(Int16.min, Int16(Float(Int16.min)))
  expectEqual(Int16.max, Int16(Float(Int16.max)))
}

FloatingPoint.test("Float/UInt32") {
  expectEqual(UInt32.min, UInt32(Float(UInt32.min)))
  expectCrashLater()
  expectEqual(UInt32.max, UInt32(Float(UInt32.max)))
}

FloatingPoint.test("Float/Int32") {
  expectEqual(Int32.min, Int32(Float(Int32.min)))
  expectCrashLater()
  expectEqual(Int32.max, Int32(Float(Int32.max)))
}

FloatingPoint.test("Float/UInt64") {
  expectEqual(UInt64.min, UInt64(Float(UInt64.min)))
  expectCrashLater()
  expectEqual(UInt64.max, UInt64(Float(UInt64.max)))
}

FloatingPoint.test("Float/Int64") {
  expectEqual(Int64.min, Int64(Float(Int64.min)))
  expectCrashLater()
  expectEqual(Int64.max, Int64(Float(Int64.max)))
}

FloatingPoint.test("Double/UInt8") {
  expectEqual(UInt8.min, UInt8(Double(UInt8.min)))
  expectEqual(UInt8.max, UInt8(Double(UInt8.max)))
}

FloatingPoint.test("Double/Int8") {
  expectEqual(Int8.min, Int8(Double(Int8.min)))
  expectEqual(Int8.max, Int8(Double(Int8.max)))
}

FloatingPoint.test("Double/UInt16") {
  expectEqual(UInt16.min, UInt16(Double(UInt16.min)))
  expectEqual(UInt16.max, UInt16(Double(UInt16.max)))
}

FloatingPoint.test("Double/Int16") {
  expectEqual(Int16.min, Int16(Double(Int16.min)))
  expectEqual(Int16.max, Int16(Double(Int16.max)))
}

FloatingPoint.test("Double/UInt32") {
  expectEqual(UInt32.min, UInt32(Double(UInt32.min)))
  expectEqual(UInt32.max, UInt32(Double(UInt32.max)))
}

FloatingPoint.test("Double/Int32") {
  expectEqual(Int32.min, Int32(Double(Int32.min)))
  expectEqual(Int32.max, Int32(Double(Int32.max)))
}

FloatingPoint.test("Double/UInt64") {
  expectEqual(UInt64.min, UInt64(Double(UInt64.min)))
  expectCrashLater()
  expectEqual(UInt64.max, UInt64(Double(UInt64.max)))
}

FloatingPoint.test("Double/Int64") {
  expectEqual(Int64.min, Int64(Double(Int64.min)))
  expectCrashLater()
  expectEqual(Int64.max, Int64(Double(Int64.max)))
}

FloatingPoint.test("Float/HashValueZero") {
  let zero: Float = noinlinePlusZero()
  let negativeZero: Float = noinlineMinusZero()
  expectEqual(zero.hashValue, negativeZero.hashValue)
}

FloatingPoint.test("Double/HashValueZero") {
  let zero: Double = noinlinePlusZero()
  let negativeZero: Double = noinlineMinusZero()
  expectEqual(zero.hashValue, negativeZero.hashValue)
}

// FIXME: implement Float80 tests after Float80 is implemented.

FloatingPoint.test("Float32/Literals") {
  if true {
    let f: Float32 = 0.0
    expectEqual(0x0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -0.0
    expectEqual(0x8000_0000, f._toBitPattern())
  }

  if true {
    let f: Float32 = 1.0
    expectEqual(0x3f80_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -1.0
    expectEqual(0xbf80_0000, f._toBitPattern())
  }

  if true {
    let f: Float32 = 0.999999
    expectEqual(0x3f7fffef, f._toBitPattern())
  }
  if true {
    let f: Float32 = 0.9999999
    expectEqual(0x3f7ffffe, f._toBitPattern())
  }
  if true {
    let f: Float32 = 0.99999999
    expectEqual(0x3f80_0000, f._toBitPattern())
  }

  // Infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float32 = 1.0e999
    expectEqual(0x7f80_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -1.0e999
    expectEqual(0xff80_0000, f._toBitPattern())
  }

  // Smallest subnormal.
  if true {
    let f: Float32 = 1.4e-45
    expectEqual(0x0000_0001, f._toBitPattern())
  }
  if true {
    let f: Float32 = -1.4e-45
    expectEqual(0x8000_0001, f._toBitPattern())
  }

  // Rounded to zero.
  if true {
    let f: Float32 = 0.7e-45
    expectEqual(0x0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -0.7e-45
    expectEqual(0x8000_0000, f._toBitPattern())
  }

  // Second largest normal.
  if true {
    let f: Float32 = 3.4028232e+38
    expectEqual(0x7f7f_fffe, f._toBitPattern())
  }
  if true {
    let f: Float32 = -3.4028232e+38
    expectEqual(0xff7f_fffe, f._toBitPattern())
  }

  // Largest normal.
  if true {
    let f: Float32 = 3.4028234e+38
    expectEqual(0x7f7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = 340282340000000000000000000000000000000.0
    expectEqual(0x7f7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = 340282340000000000000000000000000000000
    expectEqual(0x7f7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = -3.4028234e+38
    expectEqual(0xff7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = -340282340000000000000000000000000000000.0
    expectEqual(0xff7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = -340282340000000000000000000000000000000
    expectEqual(0xff7f_ffff, f._toBitPattern())
  }

  // Smallest decimal that is rounded to infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float32 = 3.4028236e+38
    expectEqual(0x7f80_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -3.4028236e+38
    expectEqual(0xff80_0000, f._toBitPattern())
  }
}

FloatingPoint.test("Float64/Literals") {
  if true {
    let f: Float64 = 0.0
    expectEqual(0x0000_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -0.0
    expectEqual(0x8000_0000_0000_0000, f._toBitPattern())
  }

  if true {
    let f: Float64 = 1.0
    expectEqual(0x3ff0_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.0
    expectEqual(0xbff0_0000_0000_0000, f._toBitPattern())
  }

  if true {
    let f: Float64 = 0.999999999999999
    expectEqual(0x3fef_ffff_ffff_fff7, f._toBitPattern())
  }
  if true {
    let f: Float64 = 0.9999999999999999
    expectEqual(0x3fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = 0.99999999999999999
    expectEqual(0x3ff0_0000_0000_0000, f._toBitPattern())
  }

  // Infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float64 = 1.0e999
    expectEqual(0x7ff0_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.0e999
    expectEqual(0xfff0_0000_0000_0000, f._toBitPattern())
  }

  // Smallest subnormal.
  if true {
    let f: Float64 = 4.0e-324
    expectEqual(0x0000_0000_0000_0001, f._toBitPattern())
  }
  if true {
    let f: Float64 = -4.0e-324
    expectEqual(0x8000_0000_0000_0001, f._toBitPattern())
  }

  // Rounded to zero.
  if true {
    let f: Float64 = 2.4e-324
    expectEqual(0x0000_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -2.4e-324
    expectEqual(0x8000_0000_0000_0000, f._toBitPattern())
  }

  // Second largest normal.
  if true {
    let f: Float64 = 1.79769313486231551e+308
    expectEqual(0x7fef_ffff_ffff_fffe, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.79769313486231551e+308
    expectEqual(0xffef_ffff_ffff_fffe, f._toBitPattern())
  }

  // Largest normal.
  if true {
    let f: Float64 = 1.7976931348623157e+308
    expectEqual(0x7fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(0x7fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    expectEqual(0x7fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.7976931348623157e+308
    expectEqual(0xffef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(0xffef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    expectEqual(0xffef_ffff_ffff_ffff, f._toBitPattern())
  }

  // Smallest decimal that is rounded to infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float64 = 1.7976931348623159e+308
    expectEqual(0x7ff0_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.7976931348623159e+308
    expectEqual(0xfff0_0000_0000_0000, f._toBitPattern())
  }
}

#if arch(i386) || arch(x86_64)

FloatingPoint.test("Float80/Literals") {
  if true {
    let f: Float80 = 0.0
    expectEqual(Float80Bits(0x0000, 0x0000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -0.0
    expectEqual(Float80Bits(0x8000, 0x0000_0000_0000_0000), f._toBitPattern())
  }

  if true {
    let f: Float80 = 1.0
    expectEqual(Float80Bits(0x3fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.0
    expectEqual(Float80Bits(0xbfff, 0x8000_0000_0000_0000), f._toBitPattern())
  }

  if true {
    let f: Float80 = 0.999999999999999999
    expectEqual(Float80Bits(0x3ffe, 0xffff_ffff_ffff_ffee), f._toBitPattern())
  }
  if true {
    let f: Float80 = 0.9999999999999999999
    expectEqual(Float80Bits(0x3ffe, 0xffff_ffff_ffff_fffe), f._toBitPattern())
  }
  if true {
    let f: Float80 = 0.99999999999999999995
    expectEqual(Float80Bits(0x3ffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = 0.99999999999999999999
    expectEqual(Float80Bits(0x3fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }

  // Infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float80 = 1.0e19999
    expectEqual(Float80Bits(0x7fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.0e19999
    expectEqual(Float80Bits(0xffff, 0x8000_0000_0000_0000), f._toBitPattern())
  }

  // Smallest subnormal.
  if true {
    // 3.645199531882474602528e-4951
    let f: Float80 = 3.6e-4951
    expectEqual(Float80Bits(0x0000, 0x0000_0000_0000_0001), f._toBitPattern())
  }
  if true {
    let f: Float80 = -3.6e-4951
    expectEqual(Float80Bits(0x8000, 0x0000_0000_0000_0001), f._toBitPattern())
  }

  // Rounded to zero.
  if true {
    let f: Float80 = 1.8e-4951
    expectEqual(Float80Bits(0x0000, 0x0000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.8e-4951
    expectEqual(Float80Bits(0x8000, 0x0000_0000_0000_0000), f._toBitPattern())
  }

  // Largest normal.
  if true {
    let f: Float80 = 1.189731495357231765e+4932
    expectEqual(Float80Bits(0x7ffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = 1189731495357231765000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(Float80Bits(0x7ffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.189731495357231765e+4932
    expectEqual(Float80Bits(0xfffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1189731495357231765000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(Float80Bits(0xfffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }

  // Smallest decimal that is rounded to infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float80 = 1.18973149535723176515e+4932
    expectEqual(Float80Bits(0x7fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.18973149535723176515e+4932
    expectEqual(Float80Bits(0xffff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
}

#endif

runAllTests()

