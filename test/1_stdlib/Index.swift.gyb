//===--- Index.swift - tests for Index types and operations ---------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Index.swift
// RUN: %S/../../utils/line-directive %t/Index.swift -- %target-build-swift %t/Index.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/Index.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest

struct DistanceToTest {
  let startIndex: Int
  let endIndex: Int
  let expectedDistance: Int
  let loc: SourceLoc

  init(startIndex: Int, endIndex: Int, expectedDistance: Int,
    file: String = __FILE__, line: UInt = __LINE__) {
    self.startIndex = startIndex
    self.endIndex = endIndex
    self.expectedDistance = expectedDistance
    self.loc = SourceLoc(file, line, comment: "distanceTo() test data")
  }
}

struct AdvancedByTest {
  let startIndex: Int
  let distance: Int
  let limit: Int?
  let expectedIndex: Int
  let loc: SourceLoc
  init(startIndex: Int, distance: Int, expectedIndex: Int,
    limit: Int? = nil, file: String = __FILE__, line: UInt = __LINE__) {
    self.startIndex = startIndex
    self.distance = distance
    self.expectedIndex = expectedIndex
    self.limit = limit
    self.loc = SourceLoc(file, line, comment: "advancedBy() test data")
  }
}

let distanceToTests = [
  DistanceToTest(
    startIndex: 0,
    endIndex: 0,
    expectedDistance: 0
  ),
  DistanceToTest(
    startIndex: 10,
    endIndex: 10,
    expectedDistance: 0
  ),
  DistanceToTest(
    startIndex: 10,
    endIndex: 13,
    expectedDistance: 3
  ),
  DistanceToTest(
    startIndex: 7,
    endIndex: 10,
    expectedDistance: 3
  ),
]

let advancedByTests = [
  AdvancedByTest(
    startIndex: 0,
    distance: 0,
    expectedIndex: 0
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: -1,
    expectedIndex: -1
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: 0,
    expectedIndex: 0,
    limit: 0
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: 0,
    expectedIndex: 0,
    limit: 10
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: 10,
    expectedIndex: 0,
    limit: 0
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: -10,
    expectedIndex: 0,
    limit: 0
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: 10,
    expectedIndex: 10,
    limit: 10
  ),
  AdvancedByTest(
    startIndex: 0,
    distance: 20,
    expectedIndex: 10,
    limit: 10
  ),
  AdvancedByTest(
    startIndex: 777,
    distance: -999,
    expectedIndex: 0,
    limit: 0
  ),
]

var Index = TestSuite("Index")

% for Kind in ['Forward', 'Bidirectional', 'RandomAccess']:

%   if Kind in ['Forward', 'Bidirectional']:
Index.test("${Kind}IndexType/distanceTo/dispatch") {
  var start = ${Kind}IndexLog.dispatchTester(0)
  var end = ${Kind}IndexLog.dispatchTester(10)
  _ = start.distanceTo(end)
  expectCustomizable(start, start.log.distanceTo)
}
%   end

Index.test("${Kind}IndexType/distanceTo/semantics") {
  for test in distanceToTests {
    let start = Minimal${Kind}Index(
      position: test.startIndex,
      startIndex: -1000,
      endIndex: 1000)
    let end = Minimal${Kind}Index(
      position: test.endIndex,
      startIndex: -1000,
      endIndex: 1000)
    let d = start.distanceTo(end)
    expectEqual(test.expectedDistance, d,
      stackTrace: SourceLocStack().with(test.loc))
  }
}

%   if Kind in ['Forward', 'Bidirectional']:
Index.test("${Kind}IndexType/advancedBy(n)/dispatch") {
  var start = ${Kind}IndexLog.dispatchTester(0)
  _ = start.advancedBy(10)
  expectCustomizable(start, start.log.advancedBy)
}
%   end

Index.test("${Kind}IndexType/advancedBy(n)/semantics") {
  for test in advancedByTests.filter({$0.limit == nil}) {
    let start = Minimal${Kind}Index(
      position: test.startIndex,
      startIndex: -1000,
      endIndex: 1000)
    let expected = Minimal${Kind}Index(
      position: test.expectedIndex,
      startIndex: -1000,
      endIndex: 1000)
%   if Kind == 'Forward':
    if test.distance < 0 {
      expectCrashLater()
    }
%   end
    let new = start.advancedBy(test.distance)
    expectEqual(expected, new,
      stackTrace: SourceLocStack().with(test.loc))
  }
}

%   if Kind in ['Forward', 'Bidirectional']:
Index.test("${Kind}IndexType/advancedBy(n, limit:)/dispatch") {
  let start = ${Kind}IndexLog.dispatchTester(0)
  let limit = ${Kind}IndexLog.dispatchTester(5)
  _ = start.advancedBy(10, limit: limit)
  expectCustomizable(start, start.log.advancedByWithLimit)
}
%   end

Index.test("${Kind}IndexType/advancedBy(n, limit:)/semantics") {
  for test in advancedByTests.filter({$0.limit != nil}) {
    let startIndex = test.startIndex
    let endIndex = test.startIndex + test.distance
    let start = Minimal${Kind}Index(
      position: test.startIndex,
      startIndex: -1000,
      endIndex: 1000)
    let limit = Minimal${Kind}Index(
      position: test.limit!,
      startIndex: -1000,
      endIndex: 1000)
%   if Kind == 'Forward':
    if test.distance < 0 {
      expectCrashLater()
    }
%   end
    let new = start.advancedBy(test.distance, limit: limit)
    let expected = Minimal${Kind}Index(
      position: test.expectedIndex,
      startIndex: -1000,
      endIndex: 1000)
    expectEqual(expected, new,
      stackTrace: SourceLocStack().with(test.loc))
  }
}

% end

runAllTests()
