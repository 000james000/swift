//===--- Lazy.swift - Tests for LazySequence and LazyCollection -----------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t
// RUN: mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Lazy.swift
// RUN: %S/../../utils/line-directive %t/Lazy.swift -- %target-build-swift %t/Lazy.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/Lazy.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest

var LazyTestSuite = TestSuite("Lazy")

protocol TestProtocol1 {}

//===----------------------------------------------------------------------===//
// Repeat
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Element'.
extension Repeat where Element : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("Repeat") {
  checkRandomAccessCollection(
    [] as Array<OpaqueValue<Int>>,
    Repeat(count: 0, repeatedValue: OpaqueValue(42)))
    { $0.value == $1.value }

  checkRandomAccessCollection(
    [ OpaqueValue(42) ] as Array<OpaqueValue<Int>>,
    Repeat(count: 1, repeatedValue: OpaqueValue(42)))
    { $0.value == $1.value }

  checkRandomAccessCollection(
    [ OpaqueValue(42), OpaqueValue(42), OpaqueValue(42) ] as Array<OpaqueValue<Int>>,
    Repeat(count: 3, repeatedValue: OpaqueValue(42)))
    { $0.value == $1.value }
}

// FIXME: trap tests.

//===----------------------------------------------------------------------===//
// CollectionOfOne
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Element'.
extension CollectionOfOne where Element : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("CollectionOfOne") {
  checkRandomAccessCollection(
    [ OpaqueValue(42) ],
    CollectionOfOne(OpaqueValue(42))) { $0.value == $1.value }
}

// FIXME: trap tests.

//===----------------------------------------------------------------------===//
// GeneratorOfOne
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Element'.
extension GeneratorOfOne where Element : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("GeneratorOfOne") {
  checkGenerator(
    [] as Array<OpaqueValue<Int>>,
    GeneratorOfOne(nil as Optional<OpaqueValue<Int>>)) { $0.value == $1.value }

  checkGenerator(
    [ OpaqueValue(42) ] as Array<OpaqueValue<Int>>,
    GeneratorOfOne(OpaqueValue(42))) { $0.value == $1.value }
}

//===----------------------------------------------------------------------===//
// EmptyCollection
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Element'.
extension EmptyCollection where Element : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("EmptyCollection") {
  checkRandomAccessCollection(
    [],
    EmptyCollection<OpaqueValue<Int>>()) { $0.value == $1.value }
}

// FIXME: trap tests.

//===----------------------------------------------------------------------===//
// EmptyGenerator
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Element'.
extension EmptyGenerator where Element : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("EmptyGenerator") {
  checkGenerator(
    [] as Array<OpaqueValue<Int>>,
    EmptyGenerator<OpaqueValue<Int>>())
    { $0.value == $1.value }
}

// FIXME: trap tests.

//===----------------------------------------------------------------------===//
// lazy()
//===----------------------------------------------------------------------===//

LazyTestSuite.test("isEmpty") {
  expectTrue(lazy(0..<0).isEmpty)
  expectFalse(lazy(0...0).isEmpty)
}

LazyTestSuite.test("firstLast") {
  expectOptionalEqual(7 as Int, lazy(7..<42).first)
  expectOptionalEqual(41 as Int, lazy(7..<42).last)
  expectEmpty(lazy(7..<7).first)
  expectEmpty(lazy(7..<7).last)
}

//===----------------------------------------------------------------------===//
// LazySequence
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension LazySequence where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("LazySequence<Sequence>/underestimateCount") {
  let s = MinimalSequence(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazySeq = lazy(s)
  expectType(LazySequence<MinimalSequence<OpaqueValue<Int>>>.self, &lazySeq)
  expectEqual(42, lazySeq.underestimateCount())
}

%for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:

LazyTestSuite.test("LazySequence<${traversal}Collection>/underestimateCount") {
  let s = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazySeq = lazy(s)
  expectType(
    Lazy${traversal}Collection<
      Minimal${traversal}Collection<OpaqueValue<Int>>
    >.self,
    &lazySeq)
  expectEqual(42, lazySeq.underestimateCount())
}

%end

//===----------------------------------------------------------------------===//
// MapSequence
//===----------------------------------------------------------------------===//

LazyTestSuite.test("MapSequence<Sequence>/underestimateCount") {
  let s = MinimalSequence(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazyMap = lazy(s).map { OpaqueValue(Int32($0.value)) }
  expectType(
    LazySequence<
      MapSequence<
        MinimalSequence<OpaqueValue<Int>>,
        OpaqueValue<Int32>
      >
    >.self,
    &lazyMap)
  expectEqual(42, lazyMap.underestimateCount())
}

struct SequenceWithCustomUnderestimateCount : SequenceType {
  init(_ data: [Int]) {
    self._data = MinimalSequence(data.map { OpaqueValue($0) })
  }

  func generate() -> MinimalSequence<OpaqueValue<Int>>.Generator {
    return _data.generate()
  }

  func underestimateCount() -> Int {
    ++SequenceWithCustomUnderestimateCount.timesUnderestimateCountWasCalled
    return _data.underestimateCount()
  }

  static var timesUnderestimateCountWasCalled: Int = 0

  let _data: MinimalSequence<OpaqueValue<Int>>
}

LazyTestSuite.test("LazySequence.array") {
  SequenceWithCustomUnderestimateCount.timesUnderestimateCountWasCalled = 0

  let base = SequenceWithCustomUnderestimateCount([ 0, 30, 10, 90 ])
  let lazySequence = LazySequence(base)
  let arrayFromLazy = lazySequence.array

  expectEqual([ 0, 30, 10, 90 ], arrayFromLazy.map { $0.value })

  // Lazy sequences should use underestimated count to preallocate array
  // storage.
  expectEqual(1, SequenceWithCustomUnderestimateCount.timesUnderestimateCountWasCalled)

  expectEqualSequence(
    [], Array(base).map { $0.value }, "sequence should be consumed")
}

%for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:

LazyTestSuite.test("MapCollection<${traversal}Collection>/underestimateCount") {
  let s = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazyMap = lazy(s).map {
    (input: OpaqueValue<Int>) -> OpaqueValue<Int32> in
    OpaqueValue(Int32(input.value))
  }
  expectType(
    Lazy${traversal}Collection<
      MapCollection<
        Minimal${traversal}Collection<OpaqueValue<Int>>,
        OpaqueValue<Int32>
      >
    >.self,
    &lazyMap)
  expectEqual(42, lazyMap.underestimateCount())
}

%end

//===----------------------------------------------------------------------===//
// LazyCollection
//===----------------------------------------------------------------------===//

%for (traversal, ReversedType) in [
%    ('Forward', None),
%    ('Bidirectional', 'ReverseCollection'),
%    ('RandomAccess', 'ReverseRandomAccessCollection')
%]:

// Check that the generic parameter is called 'Base'.
extension Lazy${traversal}Collection where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("Lazy${traversal}Collection.array") {
  let base = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ], underestimatedCount: .Value(42))
  let lazyCollection = Lazy${traversal}Collection(base)
  let arrayFromLazy = lazyCollection.array

  expectEqual([ 0, 30, 10, 90 ], arrayFromLazy)

  // Lazy collections should not use underestimated count to preallocate array
  // storage, since they have access to real count instead.
  expectLE(4, arrayFromLazy.capacity)
  expectGE(40, arrayFromLazy.capacity)
}

%  if ReversedType is not None:
LazyTestSuite.test("Lazy${traversal}Collection.reverse()") {
  let base = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  let lazyCollection = Lazy${traversal}Collection(base)
  var reversed = lazyCollection.reverse()
  expectType(
    Lazy${traversal}Collection<${ReversedType}<Minimal${traversal}Collection<OpaqueValue<Int>>>>.self,
    &reversed)

  check${traversal}Collection(
    [ 90, 10, 30, 0 ].map { OpaqueValue($0) } as [OpaqueValue<Int>],
    reversed) { $0.value == $1.value }

  var reversedTwice = reversed.reverse()
  expectType(
    Lazy${traversal}Collection<${ReversedType}<${ReversedType}<Minimal${traversal}Collection<OpaqueValue<Int>>>>>.self,
    &reversedTwice)

  check${traversal}Collection(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) } as [OpaqueValue<Int>],
    reversedTwice) { $0.value == $1.value }
}
%  end

%end

//===----------------------------------------------------------------------===//
// ReverseCollection
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension ReverseCollection where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

//===----------------------------------------------------------------------===//
// ReverseIndex
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension ReverseIndex where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

//===----------------------------------------------------------------------===//
// RandomAccessReverseCollection
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension ReverseRandomAccessCollection where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

//===----------------------------------------------------------------------===//
// ReverseRandomAccessIndex
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension ReverseRandomAccessIndex where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

var tests = TestSuite("NewLazy")

tests.test("LazySequence/SequenceType") {
  let expected = (0..<100).map { OpaqueValue($0) }
  var actual = MinimalSequence(expected)._prext_lazy
  
  expectType(
    _prext_LazySequence<MinimalSequence<OpaqueValue<Int>>>.self, &actual)

  // Asking for .lazy again doesn't re-wrap the type
  var again = actual._prext_lazy
  expectType(
    _prext_LazySequence<MinimalSequence<OpaqueValue<Int>>>.self, &again)
  
  var elements = actual.elements

  // Expect .elements to strip a lazy wrapper
  expectType(MinimalSequence<OpaqueValue<Int>>.self, &elements)

  checkSequence(expected, actual, resiliencyChecks: .none) {
    $0.value == $1.value
  }
}

func expectSequencePassthrough<
  S : SequenceType, Base : SequenceType
  where S : _prext_LazySequenceType, Base : LoggingType,
    Base.Generator.Element == S.Generator.Element
>(s: S, base: Base, arbitraryElement: S.Generator.Element, count: Int) {
  let baseType = base.dynamicType

  SequenceLog.generate.expectIncrement(baseType) { _ = s.generate() }
  SequenceLog.underestimateCount.expectIncrement(baseType) {
    _ = s.underestimateCount()
  }
  SequenceLog._customContainsEquatableElement.expectIncrement(baseType) {
    _ = s._customContainsEquatableElement(arbitraryElement)
  }
  SequenceLog._copyToNativeArrayBuffer.expectIncrement(baseType) {
    _ = s._copyToNativeArrayBuffer()
  }
  
  SequenceLog._initializeTo.expectIncrement(baseType) { ()->Void in
    let buf = UnsafeMutablePointer<S.Generator.Element>.alloc(count)
  
    let end = s._initializeTo(buf)
    expectTrue(end <= buf + count)
    buf.destroy(end - buf)
    buf.dealloc(count)
  }
}

tests.test("LazySequence/Passthrough") {
  // Test that operations that might be optimized are passed
  // through to the underlying sequence.
  let a = (0..<100).map { OpaqueValue($0) }
  let base = LoggingSequence(a)
  
  expectSequencePassthrough(
    base._prext_lazy,
    base: base, arbitraryElement: OpaqueValue(0), count: a.count)
}

% for traversal in 'Forward', 'Bidirectional', 'RandomAccess':
tests.test("LazyCollection/CollectionType/${traversal}") {
  let expected = (0..<100).map { OpaqueValue($0) }
  let base = Minimal${traversal}Collection(expected)
  var actual = base._prext_lazy
  
  expectType(
    _prext_LazyCollection<Minimal${traversal}Collection<OpaqueValue<Int>>>.self,
    &actual)

  // Asking for .lazy again doesn't re-wrap the type
  var again = actual._prext_lazy
  expectType(
    _prext_LazyCollection<Minimal${traversal}Collection<OpaqueValue<Int>>>.self,
    &again)
  
  check${traversal}Collection(
    expected, base._prext_lazy, resiliencyChecks: .none
  ) { $0.value == $1.value }

  var elements = base._prext_lazy.elements
  expectType(Minimal${traversal}Collection<OpaqueValue<Int>>.self, &elements)
}
% end

tests.test("LazyCollection/Passthrough") {
  let expected = (0..<100).map { OpaqueValue($0) }
  let base = LoggingCollection(expected)
  
  expectSequencePassthrough(
    base._prext_lazy,
    base: base._prext_lazy._base,
    arbitraryElement: OpaqueValue(0),
    count: Int(expected.count))

  let s = base._prext_lazy
  let baseType = base.dynamicType
  let startIndex = CollectionLog.startIndex.expectIncrement(baseType) {
    s.startIndex
  }
  
  let endIndex = CollectionLog.endIndex.expectIncrement(baseType) {
    s.endIndex
  }
  
  CollectionLog.subscriptIndex.expectIncrement(baseType) { _ = s[startIndex] }
  CollectionLog.subscriptRange.expectUnchanged(baseType) {
    _ = s[startIndex..<endIndex]
  }
  CollectionLog.isEmpty.expectIncrement(baseType) { _ = s.isEmpty }
  CollectionLog.count.expectIncrement(baseType) { _ = s.count }
  CollectionLog._customIndexOfEquatableElement.expectIncrement(baseType) {
    _ = s._customIndexOfEquatableElement(OpaqueValue(0))
  }
  CollectionLog.first.expectIncrement(baseType) { _ = s.first }
}

//===--- Sequences --------------------------------------------------------===//

tests.test("MapSequence") {
  let base = MinimalSequence(
    [2, 3, 5, 7, 11].map { OpaqueValue($0) })._prext_lazy

  var mapped = base.map { OpaqueValue(Double($0.value) / 2.0) }
  
  expectType(
    _prext_MapSequence<
      MinimalSequence<OpaqueValue<Int>>, 
      OpaqueValue<Double>>.self,
    &mapped)
  
  let expected = [ 1.0, 1.5, 2.5, 3.5, 5.5 ].map {OpaqueValue($0)}
  
  checkSequence(expected, mapped, resiliencyChecks: .none) {
    $0.value == $1.value
  }
}

//===--- Collections ------------------------------------------------------===//

% for traversal in 'Forward', 'Bidirectional', 'RandomAccess':
tests.test("MapCollection/${traversal}") {
  let base = Minimal${traversal}Collection(
    [2, 3, 5, 7, 11].map { OpaqueValue($0) })._prext_lazy

  var mapped = base.map { OpaqueValue(Double($0.value) / 2.0) }
  
  expectType(
    _prext_MapCollection<
      Minimal${traversal}Collection<OpaqueValue<Int>>, 
      OpaqueValue<Double>>.self,
    &mapped)
  
  let expected = [ 1.0, 1.5, 2.5, 3.5, 5.5 ].map {OpaqueValue($0)}
  
  check${traversal}Collection(expected, mapped, resiliencyChecks: .none) {
    $0.value == $1.value
  }
}
%end

tests.test("ReverseCollection") {

  let expected = Array(stride(from: 11, through: 0, by: -1))
  let r = 0..<12
  checkRandomAccessCollection(
    expected,
    r._prext_reverse)
  
  checkBidirectionalCollection(
    "raboof".characters,
    "foobar".characters._prext_reverse)
}

runAllTests()

