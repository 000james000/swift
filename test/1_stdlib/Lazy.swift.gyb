//===--- Lazy.swift - Tests for LazySequence and LazyCollection -----------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t
// RUN: mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Lazy.swift
// RUN: %S/../../utils/line-directive %t/Lazy.swift -- %target-build-swift %t/Lazy.swift -o %t/a.out_Debug
// RUN: %S/../../utils/line-directive %t/Lazy.swift -- %target-build-swift %t/Lazy.swift -o %t/a.out_Release -O
//
// RUN: %S/../../utils/line-directive %t/Lazy.swift -- %target-run %t/a.out_Debug
// RUN: %S/../../utils/line-directive %t/Lazy.swift -- %target-run %t/a.out_Release
// REQUIRES: executable_test

import StdlibUnittest

var LazyTestSuite = TestSuite("Lazy")

protocol TestProtocol1 {}

//===----------------------------------------------------------------------===//
// Repeat
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Element'.
extension Repeat where Element : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

LazyTestSuite.test("Repeat") {
  checkRandomAccessCollection(
    [],
    Repeat(count: 0, repeatedValue: OpaqueValue(42)),
    { $0.value == $1.value })

  checkRandomAccessCollection(
    [ OpaqueValue(42) ],
    Repeat(count: 1, repeatedValue: OpaqueValue(42)),
    { $0.value == $1.value })

  checkRandomAccessCollection(
    [ OpaqueValue(42), OpaqueValue(42), OpaqueValue(42) ],
    Repeat(count: 3, repeatedValue: OpaqueValue(42)),
    { $0.value == $1.value })
}

// FIXME: trap tests.

//===----------------------------------------------------------------------===//
// lazy()
//===----------------------------------------------------------------------===//

LazyTestSuite.test("isEmpty") {
  expectTrue(lazy(0..<0).isEmpty)
  expectFalse(lazy(0...0).isEmpty)
}

LazyTestSuite.test("firstLast") {
  expectOptionalEqual(7, lazy(7..<42).first)
  expectOptionalEqual(41, lazy(7..<42).last)
  expectEmpty(lazy(7..<7).first)
  expectEmpty(lazy(7..<7).last)
}

//===----------------------------------------------------------------------===//
// LazySequence
//===----------------------------------------------------------------------===//

LazyTestSuite.test("LazySequence<Sequence>/underestimateCount") {
  let s = MinimalSequence(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazySeq = lazy(s)
  expectType(LazySequence<MinimalSequence<OpaqueValue<Int>>>.self, &lazySeq)
  expectEqual(42, lazySeq.underestimateCount())
}

%for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:

LazyTestSuite.test("LazySequence<${traversal}Collection>/underestimateCount") {
  let s = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazySeq = lazy(s)
  expectType(
    Lazy${traversal}Collection<
      Minimal${traversal}Collection<OpaqueValue<Int>>
    >.self,
    &lazySeq)
  expectEqual(42, lazySeq.underestimateCount())
}

%end

//===----------------------------------------------------------------------===//
// MapSequenceView
//===----------------------------------------------------------------------===//

LazyTestSuite.test("MapSequenceView<Sequence>/underestimateCount") {
  let s = MinimalSequence(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazyMap = lazy(s).map { OpaqueValue(Int32($0.value)) }
  expectType(
    LazySequence<
      MapSequenceView<
        MinimalSequence<OpaqueValue<Int>>,
        OpaqueValue<Int32>
      >
    >.self,
    &lazyMap)
  expectEqual(42, lazyMap.underestimateCount())
}

struct SequenceWithCustomUnderestimateCount : SequenceType {
  init(_ data: [Int]) {
    self._data = MinimalSequence(data.map { OpaqueValue($0) })
  }

  func generate() -> MinimalSequence<OpaqueValue<Int>>.Generator {
    return _data.generate()
  }

  func underestimateCount() -> Int {
    ++SequenceWithCustomUnderestimateCount.timesUnderestimateCountWasCalled
    return _data.underestimateCount()
  }

  static var timesUnderestimateCountWasCalled: Int = 0

  let _data: MinimalSequence<OpaqueValue<Int>>
}

LazyTestSuite.test("LazySequence.array") {
  SequenceWithCustomUnderestimateCount.timesUnderestimateCountWasCalled = 0

  let base = SequenceWithCustomUnderestimateCount([ 0, 30, 10, 90 ])
  let lazySequence = LazySequence(base)
  let arrayFromLazy = lazySequence.array

  expectEqual([ 0, 30, 10, 90 ], arrayFromLazy.map { $0.value })

  // Lazy sequences should use underestimated count to preallocate array
  // storage.
  expectEqual(1, SequenceWithCustomUnderestimateCount.timesUnderestimateCountWasCalled)

  expectEqualSequence([], Array(base).map { $0.value }) {
    "sequence should be consumed"
  }
}

%for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:

LazyTestSuite.test("MapCollectionView<${traversal}Collection>/underestimateCount") {
  let s = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(42))
  var lazyMap = lazy(s).map { OpaqueValue(Int32($0.value)) }
  expectType(
    Lazy${traversal}Collection<
      MapCollectionView<
        Minimal${traversal}Collection<OpaqueValue<Int>>,
        OpaqueValue<Int32>
      >
    >.self,
    &lazyMap)
  expectEqual(42, lazyMap.underestimateCount())
}

LazyTestSuite.test("Lazy${traversal}Collection.array") {
  let base = Minimal${traversal}Collection(
    [ 0, 30, 10, 90 ], underestimatedCount: .Value(42))
  let lazyCollection = Lazy${traversal}Collection(base)
  let arrayFromLazy = lazyCollection.array

  expectEqual([ 0, 30, 10, 90 ], arrayFromLazy)

  // Lazy collections should not use underestimated count to preallocate array
  // storage, since they have access to real count instead.
  expectLE(4, arrayFromLazy.capacity)
  expectGE(40, arrayFromLazy.capacity)
}

%end

runAllTests()

