//===--- NumericParsing.swift.gyb ----------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb -Dtarget_ptrsize=%target-ptrsize %s -o %t/NumericParsing.swift
// RUN: %S/../../utils/line-directive %t/NumericParsing.swift -- %target-build-swift %t/NumericParsing.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/NumericParsing.swift -- %target-run %t/a.out
%{
from SwiftIntTypes import *

word_bits = int(target_ptrsize)
  
def maskOfWidth(n):
  return (1 << n) - 1

def inRadix(radix, n, zero = '0'):
  """
Represent the int n in the given radix.  
Note: the third parameter, zero, is not for user consumption.
  """
  if n < 0: return '-' + inRadix(radix, -n, '')
  elif n == 0: return zero
  else:
    r = n % radix
    digit = chr((ord('0') + r) if r < 10 else (ord('a') + r - 10))
    return inRadix(radix, n / radix, '') + digit

# The maximal legal radix
max_radix = ord('z') - ord('a') + 1 + 10

# Test a few important radices
radices_to_test = [2, 8, 10, 16, max_radix]

# How many values to test in each radix?  A nice prime number of course.
number_of_values = 23
}% 

import StdlibUnittest

var tests = TestSuite("NumericParsing")

% for type in all_integer_types(word_bits):
%   Self = type.stdlib_name
%   maxValue = maskOfWidth((type.bits - 1) if type.is_signed else type.bits)
%   minValue = -maxValue - 1 if type.is_signed else 0
%   required_values = [minValue, 0, maxValue]
tests.test("${Self}/success") {
  let isSigned = ${str(type.is_signed).lower()}

  // Check some important special cases
  expectEqual(0, ${Self}("0"))
  expectEqual(10, ${Self}("10"))
  expectEqual(10, ${Self}("010"))
  expectEqual(15, ${Self}("00F", radix: 16))
  expectEqual(${-128 if type.is_signed else 'nil'}, ${Self}("-0080", radix: 16))
  expectEqual(isSigned ? 0 : nil, ${Self}("-0"))
  expectEqual(isSigned ? 0 : nil, ${Self}("-00", radix: 16))
  expectEqual(${max_radix} - 1, ${Self}("z", radix: ${max_radix}))
  expectEqual(nil, ${Self}("${maxValue + 1}"))
  expectEqual(nil, ${Self}("${minValue - 1}"))

  // Do more exhaustive testing
  % for radix in radices_to_test:
  %   for n in required_values + range(
  %     minValue + 1, maxValue - 1,
  %     (maxValue - minValue - 2) / (number_of_values - len(required_values))):
  // This line is a workaround for a gyb parsing bug.
  %     text = inRadix(radix, n)
  expectEqual(${n}, ${Self}("${text}", radix: ${radix}))
  %     if text != text.upper():
  expectEqual(${n}, ${Self}("${text.upper()}", radix: ${radix}))
  %     end
  %   end
  % end
}

tests.test("${Self}/radixTooLow") {
  ${Self}("0", radix: 2)
  expectCrashLater()
  ${Self}("0", radix: 1)
}

tests.test("${Self}/radixTooHigh") {
  let maxRadix = ${ord('z') - ord('a') + 1 + 10}
  ${Self}("0", radix: maxRadix)
  expectCrashLater()
  let y = ${Self}("0", radix: maxRadix + 1)
}

% end

runAllTests()
