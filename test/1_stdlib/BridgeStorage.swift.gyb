//===--- BridgeStorage.swift.gyb ------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
//  Bridged types are notionally single-word beasts that either store
//  an objc class or a native Swift class.  We'd like to be able to
//  distinguish these cases efficiently.
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb %s -o %t/out.swift
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-build-swift -parse-stdlib -module-cache-path %t/clang-module-cache %t/out.swift -o %t/a.out

import Swift

//===--- Code destined for stdlib -----------------------------------------===//
import SwiftShims

protocol BridgeStorage {
  typealias Native : AnyObject
  typealias ObjC : AnyObject

  init(native: Native, bits: Int)
  init(objC: ObjC)

  mutating func isUniquelyReferencedNative() -> Bool
  var isNative: Bool {get}
  var isObjC: Bool {get}
  var nativeInstance: Native {get}
  var objCInstance: ObjC {get}
  var spareBits: Int {get}
}

extension _BridgeStorage : BridgeStorage {}


struct BridgeObject<NativeType: AnyObject, ObjCType: AnyObject>
  : BridgeStorage {
  
  typealias Native = NativeType
  typealias ObjC = ObjCType

  init(native: Native, bits: Int) {
    _sanityCheck(
      bits >= 0 && bits < 3,
      "BridgeObject can't store bits outside the range 0-2")
    
    self.object = native
    self.bits = UInt8(truncatingBitPattern: bits)
  }
  
  init(objC: ObjC) {
    self.object = objC
    self.bits = 0
  }

  mutating func isUniquelyReferencedNative() -> Bool {
    return _swift_isUniquelyReferencedNonObjC_nonNull(
      UnsafePointer(rawObject)) != 0
  }

  var isNative: Bool {
    return _swift_usesNativeSwiftReferenceCounting_nonNull(
      UnsafePointer(rawObject)) != 0
  }

  var isObjC: Bool {
    return !isNative
  }
  
  var nativeInstance: Native {
    precondition(isNative)
    return Builtin.bridgeFromRawPointer(rawObject)
  }
    
  var objCInstance: ObjC {
    precondition(isObjC)
    return Builtin.bridgeFromRawPointer(rawObject)
  }
    
  var spareBits: Int {
    return Int(bits)
  }
  
  var rawObject: Builtin.RawPointer {
    return Builtin.bridgeToRawPointer(object)
  }
  
  let object: AnyObject
  let bits: UInt8
}

//===----------------------------------------------------------------------===//
//===--- Testing code -----------------------------------------------------===//
//===----------------------------------------------------------------------===//
import StdlibUnittest
var allTests = TestSuite("DiscriminatedBridgeObject")

// CHECK: testing...
println("testing...")

class C {
  deinit {
    println("bye C!")
  }
}
import Foundation

func isOSNewerThan(major: Int, minor: Int, patch: Int = 0) -> Bool {
  let vers = (majorVersion: major, minorVersion: minor, patchVersion: patch)
  // isOperatingSystemAtLeastVersion() is unavailable on some OS versions.
  let procInfo: AnyObject = NSProcessInfo.processInfo()
  return procInfo.isOperatingSystemAtLeastVersion?(
                    NSOperatingSystemVersion(vers)
                  ) == true
}

func expectTagged(s: NSString, expected: Bool) -> NSString {
#if arch(x86_64)
  let mask: UWord = 0x8000000000000001
#elseif arch(arm64)
  let mask: UWord = 0x8000000000000000
#else
  let mask: UWord = 0
#endif

  var taggedStringsSupported: Bool
#if os(iOS)
  // NSTaggedPointerString is not yet enabled as of iOS 8.0.
  taggedStringsSupported = false
#elseif os(OSX)
  // NSTaggedPointerString is enabled starting in OS X 10.10.
  taggedStringsSupported = isOSNewerThan(10,10)  &&  mask != 0
#endif

  let tagged = unsafeBitCast(s, UWord.self) & mask != 0

  if taggedStringsSupported  &&  expected == tagged {
    // okay
  } else if !taggedStringsSupported  &&  !tagged {
    // okay
  } else {
    let un = !tagged ? "un" : ""
    fatalError("Unexpectedly \(un)tagged pointer for string \"\(s)\"")
  }

  return s
}

var taggedNSString : NSString {
  return expectTagged(NSString(format: "foo"), true)
}

var unTaggedNSString : NSString {
  return expectTagged("fûtbōl" as NSString, false)
}

% for Self in '_BridgeStorage', 'BridgeObject':
allTests.test("${Self}") {
  typealias B = ${Self}<C,NSString>
  
  for i in 0..<3 {
    var b = B(native: C(), bits: i)
    expectEmpty(b.objCInstance)
    expectNotEmpty(b.nativeInstance)
    expectTrue(b.isUniquelyReferencedNative())
    expectEqual(i, b.spareBits)
  }
  
  var b = B(native: C(), bits: 0)
  expectTrue(b.isUniquelyReferencedNative())
  
  // Add a reference and verify that it's still native but no longer unique
  var c = b
  expectFalse(b.isUniquelyReferencedNative())
  _fixLifetime(c) // make sure c is not killed early
  
  var d = B(objC: taggedNSString)
  expectFalse(d.isUniquelyReferencedNative())
  expectEmpty(d.nativeInstance)
  expectNotEmpty(d.objCInstance)

  d = B(objC: unTaggedNSString)
  expectFalse(d.isUniquelyReferencedNative())
  expectEmpty(d.nativeInstance)
  expectNotEmpty(d.objCInstance)
}
% end

runAllTests()
println("done.") // CHECK- NEXT: done
