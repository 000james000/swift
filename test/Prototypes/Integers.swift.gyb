//===--- Integers.swift.gyb -----------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-build-swift -parse-stdlib %t/out.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test
import Swift

//===--- Low-level integers -----------------------------------------------===//
// Nominal types that expose the LLVM integer builtins in a uniform manner,
// with a protocol conformance.

%{
#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)

# Number of bits in the Builtin.Word type
word_bits = int(WORD_BITS) # int(CMAKE_SIZEOF_VOID_P) * 8
IntWord = 'Int%s' % word_bits
  
# Number of bits in integer literals.
builtinIntLiteralBits = 2048
IntLiteral = 'Int%s' % builtinIntLiteralBits

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

fixedBitWidths = [2**x for x in range(3, 8) if 2**x <= 2 * word_bits]
minFixedBits = fixedBitWidths[0]
maxFixedBits = fixedBitWidths[-1]

# Enumerate all the builtin operations that apply to integers
builtinBinaryOperations = [
  'add',  'and',  'ashr',  'lshr',  'or',  'mul',  'sdiv',  'sdiv_exact',
  'shl', 'srem',  'sub',  'udiv',  'udiv_exact',  'urem',  'xor']

builtinBinaryOperationsWithOverflow = [
  'sadd', 'uadd',  'ssub', 'usub',  'smul', 'umul']
  
builtinUnaryOperations = ['assumeNonNegative']
  
builtinBinaryPredicates = [
  'cmp_eq',  'cmp_ne',  'cmp_sle',  'cmp_slt',  'cmp_sge',  'cmp_sgt',
  'cmp_ule',  'cmp_ult',  'cmp_uge',  'cmp_ugt']

builtinSILOperations = ['gep']

builtinMiscOperations = ['atomicrmw']  
}%

/// A low-level 2's complement integer.
public protocol LLVMInteger
  : Equatable,
    IntegerLiteralConvertible, _BuiltinIntegerLiteralConvertible, 
    CustomStringConvertible
{
  /// A LLVMInt type that accomodates more bits of precision than
  /// any instance of `Self`.
  typealias Extended

  /// A LLVMInt type that accomodates fewer bits of precision than
  /// any instance of `Self`.
  typealias Truncated
  
  /// Creates an instance with value 0
  init()

% for operation in builtinBinaryOperations:
  mutating func ${operation}_InPlace(rhs: Self)
% end

% for operation in builtinBinaryOperationsWithOverflow:
  mutating func ${operation}_InPlaceReturningOverflow(
    rhs: Self, trapOverflow: Bool) -> Bool
% end

  /// The most significant bit that is set, or -1 if self == 0
  var mostSignificant1Bit: LLVMWord {get}
  
  /// The most significant bit that is not set, or -1 if self == -1
  var mostSignificant0Bit: LLVMWord {get}

  func isLessThanSigned(rhs: Self) -> Bool
  func isLessThanUnsigned(rhs: Self) -> Bool
  
  /// Returns `self` while informing the optimizer that the high bit
  /// is not set.
  ///
  /// - Requires: the high bit is not set.
  var assumingNonNegative : Self { get }

  /// Returns `self`, trapping if the high bit is set
  func checkingNonNegative() -> Self
  
  var signExtended : Extended { get }
  var zeroExtended : Extended { get }
  
  var truncated : Truncated { get }

  
  var lowWord: LLVMWord { get }
  var countWords: LLVMWord { get }
  func nthWord(n: LLVMWord) -> LLVMWord
  
  init(truncating: LLVMWord)
}

extension LLVMInteger {
  @transparent
  public init(_ other: Self) {
    self = other
  }

  public var description: String {
    if self == 0 {
      return "0"
    }
    let chars: [Character] = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    var buf: [Character] = []

    var x = self
    repeat {
      let r = x.urem(10)
      x = x.udiv(10)
      buf.append(chars[Int(r.lowWord.storage)])
    }
    while x != 0
    return String(buf.reverse())
  }

% for operation in builtinBinaryOperations:
  @transparent
  public func ${operation}(rhs: Self) -> Self {
    var result = self
    result.${operation}_InPlace(rhs)
    return result
  }
% end

% for operation in builtinBinaryOperationsWithOverflow:
  @transparent
  public func ${operation}(rhs: Self) -> Self? {
    var result = self
    let overflow = result.${operation}_InPlaceReturningOverflow(
      rhs, trapOverflow: false)
    if _fastPath(!overflow) { return result }
    return nil
  }

  @transparent
  public func ${operation}TrappingOverflow(rhs: Self) -> Self {
    var result = self
    _ = result.${operation}_InPlaceReturningOverflow(rhs, trapOverflow: true)
    return result
  }
% end


}

public protocol LLVMFixedWidthInteger : LLVMInteger {
  /// A type used as `Self`'s representation
  typealias Storage

  /// Creates an instance with the given storage representation
  init(_: Storage)

  /// The number of bits `Self` can store
  static var bitWidth : LLVMWord { get }
  
  /// The entire storage of `self`'s value.  
  var storage: Storage { get set }
}

extension LLVMFixedWidthInteger {
  public var countWords: LLVMWord {
    return Self.bitWidth.add(
      LLVMWord(${word_bits}).sub(1)).udiv(${word_bits})
  }
  public func nthWord(n: LLVMWord) -> LLVMWord {
    return self.lshr(Self(truncating: n).mul(${word_bits})).lowWord
  }
}

// Only needed outside the stdlib
extension Bool {
  @transparent
  public init(_ value: Builtin.Int1) {
    self.init(_builtinBooleanLiteral: value)
  }
  
  @transparent
  public var value : Builtin.Int1 {
    return Builtin.trunc_${IntWord}_Int1((self ? 1 : 0).value)
  }
}

% for bits in fixedBitWidths:
%   # Until we have BitInt, the widest Int sign-extends into itself.
%   extendedBits = bits * 2 if bits != maxFixedBits else bits
%   narrowedBits = bits / 2 if bits != minFixedBits else bits
%   toWord = 'trunc' if word_bits < bits else 'zext'
%   fromWord = 'trunc' if word_bits > bits else 'zext'
public struct LLVMInt${bits} : LLVMFixedWidthInteger {
  public typealias Self_ = LLVMInt${bits}
  public typealias Extended = LLVMInt${extendedBits}
  public typealias Narrowed = LLVMInt${narrowedBits}
  public typealias Storage = Builtin.Int${bits}

  public init() {
    let zero: Builtin.Int${bits} = Builtin.zeroInitializer()
    self.storage = zero
  }

  public init(_builtinIntegerLiteral x: Builtin.${IntLiteral}) {
    storage = Builtin.truncOrBitCast_${IntLiteral}_Int${bits}(x)
  }

  /// Create an instance initialized to `value`.
  public init(integerLiteral value: Self_) {
    self = value
  }
  
  public init(_ storage: Storage) {
    self.storage = storage
  }
  
  public var storage: Storage
  
  public static var bitWidth : LLVMWord { return ${bits} }
  
% for operation in builtinBinaryOperations:
  public mutating func ${operation}_InPlace(rhs: Self_) {
    storage = Builtin.${operation}_Int${bits}(storage, rhs.storage)
  }
% end

% for operation in builtinBinaryOperationsWithOverflow:
  public mutating func ${operation}_InPlaceReturningOverflow(
    rhs: Self_, trapOverflow: Bool
  ) -> Bool {
    let (newStorage, overflow) = Builtin.${operation}_with_overflow_Int${bits}(
      storage, rhs.storage, trapOverflow.value)
    if trapOverflow {
      Builtin.condfail(overflow)
    }
    storage = newStorage
    return Bool(overflow)
  }
% end

  /// The most significant bit that is set, or -1 if self == 0
  public var mostSignificant1Bit: LLVMWord {
    let leadingZeros = Self_(_leadingZeros(storage)).lowWord
    return Self_.bitWidth.sub(leadingZeros).sub(1)
  }
  
  /// The most significant bit that is unset, or -1 if self == -1
  public var mostSignificant0Bit: LLVMWord {
    return self.xor(-1).mostSignificant1Bit
  }
    
% for sz in 'sign', 'zero':
  public var ${sz}Extended: Extended {
    return Extended(
      Builtin.${sz[0]}extOrBitCast_Int${bits}_Int${extendedBits}(storage)
    )
  }
% end

% for (srcSigned, srcS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  public func isLessThan${srcSigned}(rhs: Self_) -> Bool {
    return Bool(
      Builtin.cmp_${srcS}lt_Int${bits}(
        self.storage, rhs.storage))
  }
  
  % for (dstSigned, dstS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  public func checkingNarrow${srcSigned}To${dstSigned}() -> Narrowed {
    let (result, error) 
      = Builtin.${srcS}_to_${dstS}_checked_trunc_Int${bits}_Int${narrowedBits}(
          storage)
    Builtin.condfail(error)
    return Narrowed(result)
  }
  % end
% end
  
  public var assumingNonNegative : Self_ {
    return Self_(Builtin.assumeNonNegative_Int${bits}(storage))
  }
  
  public func checkingNonNegative() -> Self_ {
    let (result, error) = Builtin.s_to_u_checked_conversion_Int${bits}(storage)
    Builtin.condfail(error)
    return Self_(result)
  }

  public var truncated: Narrowed {
    return Narrowed(
      Builtin.truncOrBitCast_Int${bits}_Int${narrowedBits}(storage)
    )
  }

  public init(truncating other: LLVMWord) {
    self.init(
      Builtin.${fromWord}OrBitCast_${IntWord}_Int${bits}(other.storage))
  }
}

public func == (lhs: LLVMInt${bits}, rhs: LLVMInt${bits}) -> Bool {
  return Bool(Builtin.cmp_eq_Int${bits}(lhs.storage, rhs.storage))
}


extension LLVMInt${bits} {
  public var lowWord: LLVMWord {
    return LLVMWord(
      Builtin.${toWord}OrBitCast_Int${bits}_${IntWord}(self.storage))
  }
}

% end

public typealias LLVMWord = LLVMInt${word_bits}

//===--- Low-level BigInt -------------------------------------------------===//
// A basic array-of-words implementation of LLVMInteger
public struct LLVMBigInt : LLVMInteger {
  /// A LLVMInt type that accomodates more bits of precision than
  /// any instance of `Self`.
  public typealias Extended = LLVMBigInt

  /// A LLVMInt type that accomodates fewer bits of precision than
  /// any instance of `Self`.
  public typealias Truncated = LLVMBigInt

  public typealias Self_ = LLVMBigInt
  
  /// Creates an instance with value 0
  public init() {
    words = []
  }

  public init(_builtinIntegerLiteral x: Builtin.${IntLiteral}) {
   let isNegative = Bool(
      Builtin.cmp_slt_${IntLiteral}(
        x, Builtin.zext_${IntWord}_${IntLiteral}(0.value)))
    
    if !isNegative {
      self.init(_nonNegativeIntegerLiteral: x)
    }
    else {
      self.init(_negativeIntegerLiteral: x)
    }
  }
  
  internal init(_nonNegativeIntegerLiteral x: Builtin.${IntLiteral}) {
    words = []
    
    let mask = Builtin.zext_${IntWord}_${IntLiteral}(Int(-1).value)
    let wordBits = Builtin.zext_${IntWord}_${IntLiteral}(${word_bits}.value)
    let zero = Builtin.zext_${IntWord}_${IntLiteral}(0.value)

    var rest = x
    var digit: LLVMWord = 0
    while (
      digit.isLessThanSigned(0)
      || !Bool(Builtin.cmp_eq_${IntLiteral}(zero, rest))
    ) {
      digit = LLVMWord(
        Builtin.trunc_${IntLiteral}_${IntWord}(Builtin.and_${IntLiteral}(rest, mask)))
      words.append(digit)
      rest = Builtin.lshr_${IntLiteral}(rest, wordBits)
    }
  }
  
  internal init(_negativeIntegerLiteral x: Builtin.${IntLiteral}) {
    words = []

    let mask = Builtin.zext_${IntWord}_${IntLiteral}(Int(-1).value)
    let wordBits = Builtin.zext_${IntWord}_${IntLiteral}(${word_bits}.value)
    let target = Builtin.sext_${IntWord}_${IntLiteral}(Int(-1).value)

    var rest = x
    var digit: LLVMWord
    repeat {
      digit = LLVMWord(
        Builtin.trunc_${IntLiteral}_${IntWord}(
          Builtin.and_${IntLiteral}(rest, mask)))
      words.append(digit)
      rest = Builtin.ashr_${IntLiteral}(rest, wordBits)
    }
    while (
      !digit.isLessThanSigned(0)
      || !Bool(Builtin.cmp_eq_${IntLiteral}(target, rest)))
  }

  /// Create an instance initialized to `value`.
  public init(integerLiteral value: Self_) {
    self = value
  }
  
  @inline(__always)
  public mutating func add_InPlace(rhs: Self_) {
    var r = Self_()
    r.words.reserveCapacity(max(self.words.capacity, rhs.words.capacity))
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func and_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func ashr_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func lshr_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func or_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func mul_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func sdiv_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func sdiv_exact_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func shl_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func srem_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func sub_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func udiv_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func udiv_exact_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func urem_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func xor_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

% for operation in builtinBinaryOperationsWithOverflow:
  @inline(__always)
  public mutating func ${operation}_InPlaceReturningOverflow(
    rhs: Self_, trapOverflow: Bool) -> Bool {
    fatalError("implement me")
  }
% end

  /// The most significant bit that is set, or -1 if self == 0
  public var mostSignificant1Bit: LLVMWord {
    fatalError("implement me")
  }
  
  /// The most significant bit that is not set, or -1 if self == -1
  public var mostSignificant0Bit: LLVMWord {
    fatalError("implement me")
  }
  
  public func isLessThanSigned(rhs: Self_) -> Bool {
    fatalError("implement me")
  }
  public func isLessThanUnsigned(rhs: Self_) -> Bool {
    fatalError("implement me")
  }
  
  /// Returns `self` while informing the optimizer that the high bit
  /// is not set.
  ///
  /// - Requires: the high bit is not set.
  public var assumingNonNegative : Self_ {
    fatalError("implement me")
  }

  /// Returns `self`, trapping if the high bit is set
  public func checkingNonNegative() -> Self_  {
    fatalError("implement me")
  }
  
  public var signExtended : Extended { return self }
  public var zeroExtended : Extended { return self }
  
  public var truncated : Truncated { return self }
  
  internal var words: ContiguousArray<LLVMWord>

  public var lowWord: LLVMWord {
    fatalError("implement me")
  }

  public var countWords: LLVMWord {
    return LLVMWord(words.count.value)
  }
  
  public func nthWord(n: LLVMWord) -> LLVMWord {
    return LLVMWord(words[Int(n.storage)])
  }

  public init(truncating other: LLVMWord) {
    words = [other]
  }
}

public func == (lhs: LLVMBigInt, rhs: LLVMBigInt) -> Bool {
  fatalError("implement me")
}

//===--- tests ------------------------------------------------------------===//
import StdlibUnittest
var tests = TestSuite("Integers")

func expectBigInt(
  expected: [LLVMWord], _ actual: LLVMBigInt,
  @autoclosure _ message: ()->String = "",
  file: String = __FILE__, line: UInt = __LINE__
) {
  expectEqualSequence(
    expected, actual.words.reverse(), message(), file: file, line: line)
}

tests.test("LLVMBigInt.Literals") {
  expectBigInt([], 0)
  expectBigInt([1], 1)
  expectBigInt([-1], -1)
  expectBigInt([${(1 << (word_bits-1)) - 1}], ${(1 << (word_bits-1)) - 1})
  expectBigInt([0, ${1 << (word_bits-1)}], ${(1 << (word_bits-1))})
  expectBigInt([1, 0], ${1 << word_bits})
  expectBigInt([${-1 << (word_bits - 1)}], ${-1 << (word_bits - 1)})
  expectBigInt([-1, 0], ${-1 << word_bits})
  expectBigInt([-1, 1], ${(-1 << word_bits) + 1})
  expectBigInt([-2, -1], ${(-1 << word_bits) - 1})
}

tests.test("Basics") {
  typealias I8 = LLVMInt8
  typealias W = LLVMInt${word_bits}
  typealias W2 = LLVMInt${word_bits * 2}

  expectEqual(sizeof(W.self), sizeof(Int.self))
  expectEqual(sizeof(W2.self), 2 * sizeof(Int.self))

  let b8: I8 = 0b1_0_11_0_111
  expectEqual(b8, 0b1_0_11_0_111)
  expectEqual(b8, 183)
  expectNotEqual(b8, I8())
  expectEqual(I8(), 0)
  expectEqual(8, I8.bitWidth)

  /// Create a fibonacci sequence
  var a: [I8] = []
  var prior: I8 = 0
  var current: I8 = 1
  while true {
    let next = I8((UInt8(prior.storage) &+ UInt8(current.storage)).value)
    
    expectEqual(next, current.add(prior))
    expectEqual(next, prior.add(current))

    expectEqual(String(next), String(UInt8(next.storage)))
    
    if UInt8(next.storage) <= UInt8(prior.storage) { break }
    
    a.append(next)
    prior = current
    current = next
  }
  checkEquatable(a, oracle: { $0 == $1})
  
  let x = LLVMInt${word_bits}()
  let y = LLVMInt${word_bits * 2}()
  let z = LLVMInt16()
}

runAllTests()

