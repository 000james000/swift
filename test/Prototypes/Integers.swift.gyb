//===--- Integers.swift.gyb -----------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-build-swift -parse-stdlib %t/out.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test
import Swift

//===--- Low-level integers -----------------------------------------------===//
// Nominal types that expose the LLVM integer builtins in a uniform manner,
// with a protocol conformance.

%{
#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)

# Number of bits in the Builtin.Word type
word_bits = int(WORD_BITS) # int(CMAKE_SIZEOF_VOID_P) * 8

# Number of bits in integer literals.
builtinIntLiteralBits = 2048

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

fixedBitWidths = [2**x for x in range(3, 8) if 2**x <= 2 * word_bits]
minFixedBits = fixedBitWidths[0]
maxFixedBits = fixedBitWidths[-1]

# Enumerate all the builtin operations that apply to integers
builtinBinaryOperations = [
  'add',  'and',  'ashr',  'lshr',  'or',  'mul',  'sdiv',  'sdiv_exact',
  'shl', 'srem',  'sub',  'udiv',  'udiv_exact',  'urem',  'xor']

builtinBinaryOperationsWithOverflow = [
  'sadd_with_overflow', 'uadd_with_overflow',  'ssub_with_overflow',
  'usub_with_overflow',  'smul_with_overflow', 'umul_with_overflow']
  
builtinUnaryOperations = ['assumeNonNegative']
  
builtinBinaryPredicates = [
  'cmp_eq',  'cmp_ne',  'cmp_sle',  'cmp_slt',  'cmp_sge',  'cmp_sgt',
  'cmp_ule',  'cmp_ult',  'cmp_uge',  'cmp_ugt']

builtinSILOperations = ['gep']

builtinMiscOperations = ['atomicrmw']  
}%

/// A low-level 2's complement integer.
public protocol _LowLevelInteger
  : Equatable,
    IntegerLiteralConvertible, _BuiltinIntegerLiteralConvertible 
{
  /// A _LowLevelInt type that accomodates more bits of precision than
  /// any instance of `Self`.
  typealias Extended

  /// A _LowLevelInt type that accomodates fewer bits of precision than
  /// any instance of `Self`.
  typealias Truncated
  
  /// Creates an instance with value 0
  init()

% for operation in builtinBinaryOperations:
  func ${operation}(rhs: Self) -> Self
% end

% for operation in builtinBinaryOperationsWithOverflow:
  func ${operation}(rhs: Self, overflowIsError: Bool) -> (Self, Bool)
% end

  func isLessThanSigned(rhs: Self) -> Bool
  func isLessThanUnsigned(rhs: Self) -> Bool
  
  /// Returns `self` while informing the optimizer that the high bit
  /// is not set.
  ///
  /// - Requires: the high bit is not set.
  var assumingNonNegative : Self { get }

  /// Returns `self`, trapping if the high bit is set
  func checkingNonNegative() -> Self
  
#if false
  var maxUnsetBit : Swift.Int { get }
  var maxSetBit : Swift.Int { get }
#endif
  var signExtended : Extended { get }
  var zeroExtended : Extended { get }
  
  var truncated : Truncated { get }
}

extension _LowLevelInteger {
  public init(_ other: Self) {
    self = other
  }
}

protocol _FixedWidthInteger : _LowLevelInteger {
  /// A type used as `Self`'s representation
  typealias Storage

  /// Creates an instance with the given storage representation
  init(_: Storage)

  /// The number of bits `Self` can store
  static var bitWidth : Swift.Int { get }
  
  /// The entire storage of `self`'s value.  
  var storage: Storage { get set }
}

// Only needed outside the stdlib
extension Bool {
  init(_ value: Builtin.Int1) {
    self.init(_builtinBooleanLiteral: value)
  }
  var value : Builtin.Int1 {
    return Builtin.trunc_Int${word_bits}_Int1((self ? 1 : 0).value)
  }
}

% for bits in fixedBitWidths:
%   # Until we have BitInt, the widest Int sign-extends into itself.
%   extendedBits = bits * 2 if bits != maxFixedBits else bits
%   narrowedBits = bits / 2 if bits != minFixedBits else bits
public struct _LowLevelInt${bits} : _FixedWidthInteger {
  public typealias Self_ = _LowLevelInt${bits}
  public typealias Extended = _LowLevelInt${extendedBits}
  public typealias Narrowed = _LowLevelInt${narrowedBits}
  public typealias Storage = Builtin.Int${bits}

  public init() {
    let zero: Builtin.Int${bits} = Builtin.zeroInitializer()
    self.storage = zero
  }

  public init(_builtinIntegerLiteral x: Builtin.Int${builtinIntLiteralBits}) {
    storage = Builtin.truncOrBitCast_Int${builtinIntLiteralBits}_Int${bits}(x)
  }

  /// Create an instance initialized to `value`.
  public init(integerLiteral value: Self_) {
    self = value
  }
  
  public init(_ storage: Storage) {
    self.storage = storage
  }
  
  public var storage: Storage
  
  public static var bitWidth : Swift.Int { return ${bits} }
  
% for operation in builtinBinaryOperations:
  public func ${operation}(rhs: Self_) -> Self_ {
    return Self_(Builtin.${operation}_Int${bits}(storage, rhs.storage))
  }
% end

% for operation in builtinBinaryOperationsWithOverflow:
  public func ${operation}(rhs: Self_, overflowIsError: Bool) -> (Self_, Bool) {
    let r = Builtin.${operation}_Int${bits}(
      storage, rhs.storage, overflowIsError.value)
    return (Self_(r.0), Bool(r.1))
  }
% end
  
% for sz in 'sign', 'zero':
  public var ${sz}Extended: Extended {
    return Extended(
      Builtin.${sz[0]}extOrBitCast_Int${bits}_Int${extendedBits}(storage)
    )
  }
% end

% for (srcSigned, srcS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  public func isLessThan${srcSigned}(rhs: Self_) -> Bool {
    return Bool(
      Builtin.cmp_${srcS}lt_Int${bits}(
        self.storage, rhs.storage))
  }
  
  % for (dstSigned, dstS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  public func checkingNarrow${srcSigned}To${dstSigned}() -> Narrowed {
    let (result, error) 
      = Builtin.${srcS}_to_${dstS}_checked_trunc_Int${bits}_Int${narrowedBits}(
          storage)
    Builtin.condfail(error)
    return Narrowed(result)
  }
  % end
% end
  
  public var assumingNonNegative : Self_ {
    return Self_(Builtin.assumeNonNegative_Int${bits}(storage))
  }
  
  public func checkingNonNegative() -> Self_ {
    let (result, error) = Builtin.s_to_u_checked_conversion_Int${bits}(storage)
    Builtin.condfail(error)
    return Self_(result)
  }

  public var truncated: Narrowed {
    return Narrowed(
      Builtin.truncOrBitCast_Int${bits}_Int${narrowedBits}(storage)
    )
  }
}

public func == (lhs: _LowLevelInt${bits}, rhs: _LowLevelInt${bits}) -> Bool {
  return Bool(Builtin.cmp_eq_Int${bits}(lhs.storage, rhs.storage))
}

% end

//===--- tests ------------------------------------------------------------===//
import StdlibUnittest
var tests = TestSuite("Integers")


tests.test("Dummy") {
  let x = _LowLevelInt${word_bits}()
  let y = _LowLevelInt${word_bits * 2}()
  let z = _LowLevelInt16()
}

runAllTests()
