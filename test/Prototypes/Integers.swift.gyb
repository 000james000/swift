//===--- Integers.swift.gyb -----------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-build-swift -parse-stdlib %t/out.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-run %t/a.out
// REQUIRES: executable_test
// REQUIRES: rdar22835350
import Swift

//===--- Low-level integers -----------------------------------------------===//
// Nominal types that expose the LLVM integer builtins in a uniform manner,
// with a protocol conformance.

%{
#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)

# Number of bits in the Builtin.Word type
word_bits = int(WORD_BITS) # int(CMAKE_SIZEOF_VOID_P) * 8
IntWord = 'Int%s' % word_bits
  
# Number of bits in integer literals.
builtinIntLiteralBits = 2048
IntLiteral = 'Int%s' % builtinIntLiteralBits

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

fixedBitWidths = [2**x for x in range(3, 8) if 2**x <= 2 * word_bits]
minFixedBits = fixedBitWidths[0]
maxFixedBits = fixedBitWidths[-1]

# Enumerate all the builtin operations that apply to integers
builtinBinaryOperations = [
  'add',  'and',  'ashr',  'lshr',  'or',  'mul',  'sdiv',  'sdiv_exact',
  'shl', 'srem',  'sub',  'udiv',  'udiv_exact',  'urem',  'xor']

builtinBinaryOperationsWithOverflow = [
  'sadd', 'uadd',  'ssub', 'usub',  'smul', 'umul']
  
builtinUnaryOperations = ['assumeNonNegative']
  
builtinBinaryPredicates = [
  'cmp_eq',  'cmp_ne',  'cmp_sle',  'cmp_slt',  'cmp_sge',  'cmp_sgt',
  'cmp_ule',  'cmp_ult',  'cmp_uge',  'cmp_ugt']

builtinSILOperations = ['gep']

builtinMiscOperations = ['atomicrmw']  
}%

/// A low-level 2's complement integer.
public protocol LLVMIntegerType
  : Equatable,
    IntegerLiteralConvertible, _BuiltinIntegerLiteralConvertible, 
    CustomStringConvertible
{
  /// A LLVMInt type that accomodates more bits of precision than
  /// any instance of `Self`.
  typealias Extended

  /// A LLVMInt type that accomodates fewer bits of precision than
  /// any instance of `Self`.
  typealias Truncated
  
  /// Creates an instance with value 0
  init()

% for operation in builtinBinaryOperations:
  mutating func ${operation}_InPlace(rhs: Self)
% end

% for operation in builtinBinaryOperationsWithOverflow:
  mutating func ${operation}_InPlaceReturningOverflow(
    rhs: Self, trapOverflow: Bool) -> Bool
% end

  /// The most significant bit that is set, or -1 if self == 0
  var mostSignificant1Bit: LLVMWord {get}
  
  /// The most significant bit that is not set, or -1 if self == -1
  var mostSignificant0Bit: LLVMWord {get}

  func isLessThanSigned(rhs: Self) -> Bool
  func isLessThanUnsigned(rhs: Self) -> Bool
  
  /// Returns `self` while informing the optimizer that the high bit
  /// is not set.
  ///
  /// - Requires: the high bit is not set.
  var assumingNonNegative : Self { get }

  /// Returns `self`, trapping if the high bit is set
  func checkingNonNegative() -> Self
  
  var signExtended : Extended { get }
  var zeroExtended : Extended { get }
  
  var truncated : Truncated { get }

  
  var countWords: LLVMWord { get }
  func signedWord(n: LLVMWord) -> LLVMWord
  func unsignedWord(n: LLVMWord) -> LLVMWord
  mutating func sext_WordInPlace(n: LLVMWord)
  
  init(truncatingSigned: LLVMWord)
  init(truncatingUnsigned: LLVMWord)
  
  init<Other: LLVMIntegerType>(truncatingSigned source: Other)
  init<Other: LLVMIntegerType>(truncatingUnsigned source: Other)
  init<Other: LLVMIntegerType>(signed source: Other)
  init<Other: LLVMIntegerType>(unsigned source: Other)
}

extension LLVMIntegerType {
  @transparent
  public init(_ other: Self) {
    self = other
  }

  public var description: String {
    if self == 0 {
      return "0"
    }
    let chars: [Character] = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
    var buf: [Character] = []

    var x = self
    repeat {
      let r = x.urem(10)
      x = x.udiv(10)
      buf.append(chars[Int(r.unsignedWord(0).storage)])
    }
    while x != 0
    return String(buf.reverse())
  }

% for operation in builtinBinaryOperations:
  @transparent
  public func ${operation}(rhs: Self) -> Self {
    var result = self
    result.${operation}_InPlace(rhs)
    return result
  }
% end

% for operation in builtinBinaryOperationsWithOverflow:
  @transparent
  public func ${operation}(rhs: Self) -> Self? {
    var result = self
    let overflow = result.${operation}_InPlaceReturningOverflow(
      rhs, trapOverflow: false)
    if _fastPath(!overflow) { return result }
    return nil
  }

  @transparent
  public func ${operation}TrappingOverflow(rhs: Self) -> Self {
    var result = self
    _ = result.${operation}_InPlaceReturningOverflow(rhs, trapOverflow: true)
    return result
  }
% end
}

public protocol LLVMFixedWidthIntegerType : LLVMIntegerType {
  /// A type used as `Self`'s representation
  typealias Storage

  /// Creates an instance with the given storage representation
  init(_: Storage)

  /// The number of bits `Self` can store
  static var bitWidth : LLVMWord { get }
  
  /// The entire storage of `self`'s value.  
  var storage: Storage { get set }
}

extension LLVMFixedWidthIntegerType {
  @transparent
  public var countWords: LLVMWord {
    return Self.bitWidth.add(
      LLVMWord(${word_bits}).sub(1)).udiv(${word_bits})
  }
  
  /// Generalized truncating construction from another LLVMIntegerType
  @inline(__always)
  public init<Other: LLVMIntegerType>(truncatingUnsigned source: Other) {
    self = 0
    self._replaceLow(self._minWordCount(source), unsignedWordsWith: source)
  }

  /// Generalized truncating construction from another LLVMIntegerType
  @inline(__always)
  public init<Other: LLVMIntegerType>(truncatingSigned source: Other) {
    if !LLVMWord(${word_bits}).isLessThanUnsigned(Self.bitWidth) {
      self.init(truncatingSigned: source.signedWord(0))
    }
    else {
      self.init(truncatingUnsigned: source)
      self.self.sext_WordInPlace(self._minWordCount(source))
    }
  }

  @inline(__always)
  internal func _minWordCount<Other: LLVMIntegerType>(source: Other) -> LLVMWord {
    let n = source.countWords
    return countWords.isLessThanUnsigned(n) ? countWords : n
  }

  @inline(__always)
  internal mutating func _replaceLow<Other: LLVMIntegerType>(
    var n: LLVMWord, unsignedWordsWith source: Other
  ) {
    while n != 0 {
      n.sub_InPlace(1)
      self.shl_InPlace(${word_bits})
      self.or_InPlace(Self(truncatingUnsigned: source.unsignedWord(n)))
    }
  }
  
  /// Generalized construction from an unsigned LLVMIntegerType, trapping
  /// on overflow.
  @inline(__always)
  public init<Other: LLVMIntegerType>(unsigned source: Other) {
    self.init(truncatingUnsigned: source)
    Builtin.condfail(
      Self.bitWidth.isLessThanSigned(source.mostSignificant1Bit)._value)
  }

  /// Generalized construction from a signed LLVMIntegerType, trapping on
  /// overflow.
  @inline(__always)
  public init<Other: LLVMIntegerType>(signed source: Other) {
    self.init(truncatingSigned: source)
    Builtin.condfail(
      (Other(truncatingSigned: self) != source)._value
    )
  }
}

// Only needed outside the stdlib
extension Bool {
  @transparent
  public init(_ value: Builtin.Int1) {
    self.init(_builtinBooleanLiteral: value)
  }
  
  @transparent
  public var _value: Builtin.Int1 {
    return Builtin.trunc_${IntWord}_Int1((self ? 1 : 0)._value)
  }
}

% for bits in fixedBitWidths:

%{
# Until we have BigInt, the widest Int sign-extends into itself.
extendedBits = bits * 2 if bits != maxFixedBits else bits
narrowedBits = bits / 2 if bits != minFixedBits else bits
if word_bits < bits:
  toUnsignedWord = toSignedWord = 'trunc'
  fromUnsignedWord = 'zext'
  fromSignedWord = 'sext'
else:
  toUnsignedWord = 'zext'
  toSignedWord = 'sext'
  fromUnsignedWord = fromSignedWord = 'trunc'
}%

public struct LLVMInt${bits} : LLVMFixedWidthIntegerType {
  public typealias Self_ = LLVMInt${bits}
  public typealias Extended = LLVMInt${extendedBits}
  public typealias Narrowed = LLVMInt${narrowedBits}
  public typealias Storage = Builtin.Int${bits}

  @transparent
  public init() {
    let zero: Builtin.Int${bits} = Builtin.zeroInitializer()
    self.storage = zero
  }

  @transparent
  public init(_builtinIntegerLiteral x: Builtin.${IntLiteral}) {
    storage = Builtin.truncOrBitCast_${IntLiteral}_Int${bits}(x)
  }

  /// Create an instance initialized to `value`.
  @transparent
  public init(integerLiteral value: Self_) {
    self = value
  }
  
  @transparent
  public init(_ storage: Storage) {
    self.storage = storage
  }
  
  public var storage: Storage
  
  @transparent
  public static var bitWidth : LLVMWord { return ${bits} }
  
% for operation in builtinBinaryOperations:
  @transparent
  public mutating func ${operation}_InPlace(rhs: Self_) {
    storage = Builtin.${operation}_Int${bits}(storage, rhs.storage)
  }
% end

% for operation in builtinBinaryOperationsWithOverflow:
  @transparent
  public mutating func ${operation}_InPlaceReturningOverflow(
    rhs: Self_, trapOverflow: Bool
  ) -> Bool {
    let (newStorage, overflow) = Builtin.${operation}_with_overflow_Int${bits}(
      storage, rhs.storage, trapOverflow._value)
    if trapOverflow {
      Builtin.condfail(overflow)
    }
    storage = newStorage
    return Bool(overflow)
  }
% end

  /// The most significant bit that is set, or -1 if self == 0
  @transparent
  public var mostSignificant1Bit: LLVMWord {
    let leadingZeros = Self_(_leadingZeros(storage)).unsignedWord(0)
    return Self_.bitWidth.sub(leadingZeros).sub(1)
  }
  
  /// The most significant bit that is unset, or -1 if self == -1
  @transparent
  public var mostSignificant0Bit: LLVMWord {
    return self.xor(-1).mostSignificant1Bit
  }
    
% for sz in 'sign', 'zero':
  @transparent
  public var ${sz}Extended: Extended {
    return Extended(
      Builtin.${sz[0]}extOrBitCast_Int${bits}_Int${extendedBits}(storage)
    )
  }
% end

% for (srcSigned, srcS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  @transparent
  public func isLessThan${srcSigned}(rhs: Self_) -> Bool {
    return Bool(
      Builtin.cmp_${srcS}lt_Int${bits}(
        self.storage, rhs.storage))
  }
  
  % for (dstSigned, dstS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  @transparent
  public func checkingNarrow${srcSigned}To${dstSigned}() -> Narrowed {
    let (result, error) 
      = Builtin.${srcS}_to_${dstS}_checked_trunc_Int${bits}_Int${narrowedBits}(
          storage)
    Builtin.condfail(error)
    return Narrowed(result)
  }
  % end
% end
  
  @transparent
  public var assumingNonNegative : Self_ {
    return Self_(Builtin.assumeNonNegative_Int${bits}(storage))
  }
  
  @transparent
  public func checkingNonNegative() -> Self_ {
    let (result, error) = Builtin.s_to_u_checked_conversion_Int${bits}(storage)
    Builtin.condfail(error)
    return Self_(result)
  }

  @transparent
  public var truncated: Narrowed {
    return Narrowed(
      Builtin.truncOrBitCast_Int${bits}_Int${narrowedBits}(storage)
    )
  }

  @transparent
  public init(truncatingUnsigned other: LLVMWord) {
    self.init(
      Builtin.${fromUnsignedWord}OrBitCast_${IntWord}_Int${bits}(other.storage))
  }

  @transparent
  public init(truncatingSigned other: LLVMWord) {
    self.init(
      Builtin.${fromSignedWord}OrBitCast_${IntWord}_Int${bits}(other.storage))
  }

  @transparent
  public func signedWord(n: LLVMWord) -> LLVMWord {
    return LLVMWord(
      Builtin.${toSignedWord}OrBitCast_Int${bits}_${IntWord}(
        self.ashr(Self_(truncatingUnsigned: n).mul(${word_bits})).storage)
    )
  }
  
  @transparent
  public func unsignedWord(n: LLVMWord) -> LLVMWord {
    return LLVMWord(
      Builtin.${toUnsignedWord}OrBitCast_Int${bits}_${IntWord}(
        self.lshr(Self_(truncatingUnsigned: n).mul(${word_bits})).storage)
    )
  }

  @transparent
  public mutating func sext_WordInPlace(n: LLVMWord) {
    % if bits > word_bits:
    self.or_InPlace(Self_(
      Builtin.sext_${IntWord}_Int${bits}(self.unsignedWord(n).storage)
    ).ashr(${word_bits}).shl(
        Self_(truncatingUnsigned: n).add(1).mul(${word_bits})))
    % end
  }
}

public func == (lhs: LLVMInt${bits}, rhs: LLVMInt${bits}) -> Bool {
  return Bool(Builtin.cmp_eq_Int${bits}(lhs.storage, rhs.storage))
}


% end

public typealias LLVMWord = LLVMInt${word_bits}

//===--- Low-level BigInt -------------------------------------------------===//
// A basic array-of-words implementation of LLVMIntegerType
public struct LLVMBigInt : LLVMIntegerType {
  /// A LLVMInt type that accomodates more bits of precision than
  /// any instance of `Self`.
  public typealias Extended = LLVMBigInt

  /// A LLVMInt type that accomodates fewer bits of precision than
  /// any instance of `Self`.
  public typealias Truncated = LLVMBigInt

  public typealias Self_ = LLVMBigInt
  
  /// Creates an instance with value 0
  @inline(__always)
  public init() {
    words = []
  }

  @inline(__always)
  public init(_builtinIntegerLiteral x: Builtin.${IntLiteral}) {
   let isNegative = Bool(
      Builtin.cmp_slt_${IntLiteral}(
        x, Builtin.zext_${IntWord}_${IntLiteral}(0._value)))
    
    if !isNegative {
      self.init(_nonNegativeIntegerLiteral: x)
    }
    else {
      self.init(_negativeIntegerLiteral: x)
    }
  }
  
  internal init(_nonNegativeIntegerLiteral x: Builtin.${IntLiteral}) {
    words = []
    
    let mask = Builtin.zext_${IntWord}_${IntLiteral}(Int(-1)._value)
    let wordBits = Builtin.zext_${IntWord}_${IntLiteral}(${word_bits}._value)
    let zero = Builtin.zext_${IntWord}_${IntLiteral}(0._value)

    var rest = x
    var digit: LLVMWord = 0
    while (
      digit.isLessThanSigned(0)
      || !Bool(Builtin.cmp_eq_${IntLiteral}(zero, rest))
    ) {
      digit = LLVMWord(
        Builtin.trunc_${IntLiteral}_${IntWord}(Builtin.and_${IntLiteral}(rest, mask)))
      words.append(digit)
      rest = Builtin.lshr_${IntLiteral}(rest, wordBits)
    }
  }
  
  internal init(_negativeIntegerLiteral x: Builtin.${IntLiteral}) {
    words = []

    let mask = Builtin.zext_${IntWord}_${IntLiteral}(Int(-1)._value)
    let wordBits = Builtin.zext_${IntWord}_${IntLiteral}(${word_bits}._value)
    let target = Builtin.sext_${IntWord}_${IntLiteral}(Int(-1)._value)

    var rest = x
    var digit: LLVMWord
    repeat {
      digit = LLVMWord(
        Builtin.trunc_${IntLiteral}_${IntWord}(
          Builtin.and_${IntLiteral}(rest, mask)))
      words.append(digit)
      rest = Builtin.ashr_${IntLiteral}(rest, wordBits)
    }
    while (
      !digit.isLessThanSigned(0)
      || !Bool(Builtin.cmp_eq_${IntLiteral}(target, rest)))
  }

  /// Create an instance initialized to `value`.
  @inline(__always)
  public init(integerLiteral value: Self_) {
    self = value
  }
  
  @inline(__always)
  public mutating func add_InPlace(rhs: Self_) {
    words.reserveCapacity(rhs.words.capacity)
  }

  @inline(__always)
  public mutating func and_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func ashr_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func lshr_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func or_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func mul_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func sdiv_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func sdiv_exact_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func shl_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func srem_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func sub_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func udiv_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func udiv_exact_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func urem_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

  @inline(__always)
  public mutating func xor_InPlace(rhs: Self_) {
    fatalError("implement me")
  }

% for operation in builtinBinaryOperationsWithOverflow:
  @inline(__always)
  public mutating func ${operation}_InPlaceReturningOverflow(
    rhs: Self_, trapOverflow: Bool) -> Bool {
    fatalError("implement me")
  }
% end

  /// The most significant bit that is set, or -1 if self == 0
  @transparent // FIXME: should be @inline(__always)
  public var mostSignificant1Bit: LLVMWord {
    fatalError("implement me")
  }
  
  /// The most significant bit that is not set, or -1 if self == -1
  @transparent // FIXME: should be @inline(__always)
  public var mostSignificant0Bit: LLVMWord {
    fatalError("implement me")
  }
  
  @inline(__always)
  public func isLessThanSigned(rhs: Self_) -> Bool {
    fatalError("implement me")
  }
  @inline(__always)
  public func isLessThanUnsigned(rhs: Self_) -> Bool {
    fatalError("implement me")
  }
  
  /// Returns `self` while informing the optimizer that the high bit
  /// is not set.
  ///
  /// - Requires: the high bit is not set.
  @transparent // FIXME: should be @inline(__always)
  public var assumingNonNegative : Self_ {
    fatalError("implement me")
  }

  /// Returns `self`, trapping if the high bit is set
  @inline(__always)
  public func checkingNonNegative() -> Self_  {
    fatalError("implement me")
  }
  
  @transparent // FIXME: should be @inline(__always)
  public var signExtended : Extended { return self }
  @transparent // FIXME: should be @inline(__always)
  public var zeroExtended : Extended { return self }
  
  @transparent // FIXME: should be @inline(__always)
  public var truncated : Truncated { return self }
  
  internal var words: ContiguousArray<LLVMWord>

  @transparent // FIXME: should be @inline(__always)
  public var lowWord: LLVMWord {
    fatalError("implement me")
  }

  @transparent // FIXME: should be @inline(__always)
  public var countWords: LLVMWord {
    return LLVMWord(words.count._value)
  }
  
  @inline(__always)
  public func unsignedWord(n: LLVMWord) -> LLVMWord {
    return LLVMWord(words[Int(n.storage)])
  }

  @inline(__always)
  public func signedWord(n: LLVMWord) -> LLVMWord {
    return LLVMWord(words[Int(n.storage)])
  }

  @inline(__always)
  public init(truncatingSigned other: LLVMWord) {
    words = [other]
  }

  @inline(__always)
  public init(truncatingUnsigned other: LLVMWord) {
    words = [other]
  }

  /// Generalized truncating construction from another LLVMIntegerType
  ///
  /// This implementation never truncates
  @inline(__always)
  public init<Other: LLVMIntegerType>(truncatingUnsigned source: Other) {
    let countWords = source.countWords
    words = []
    words.reserveCapacity(Int(countWords.storage))
    for var i: LLVMWord = 0; i != countWords; i.add_InPlace(1) {
      words.append(source.unsignedWord(i))
    }
  }
  
  @inline(__always)
  public init<Other: LLVMIntegerType>(truncatingSigned source: Other) {
    let countWords = source.countWords
    words = []
    words.reserveCapacity(Int(countWords.storage))
    for var i: LLVMWord = 0; i != countWords; i.add_InPlace(1) {
      words.append(source.signedWord(i))
    }
  }
  
  /// Generalized construction from an unsigned LLVMIntegerType, trapping
  /// on overflow.
  ///
  /// This implementation never traps
  @inline(__always)
  public init<Other: LLVMIntegerType>(unsigned source: Other) {
    self.init(truncatingUnsigned: source)
  }

  /// Generalized construction from a signed LLVMIntegerType, trapping on
  /// overflow.
  ///
  /// This implementation never traps
  @inline(__always)
  public init<Other: LLVMIntegerType>(signed source: Other) {
    self.init(truncatingSigned: source)
  }

  @transparent
  public mutating func sext_WordInPlace(n: LLVMWord) {
    if !signedWord(n).isLessThanSigned(0) { return }
    for i in Int(n.add(1).storage)..<words.count {
      words[i] = -1
    }
  }
}

public func == (lhs: LLVMBigInt, rhs: LLVMBigInt) -> Bool {
  fatalError("implement me")
}

typealias LLVMDoubleWord = LLVMInt${word_bits*2}

//===--- tests ------------------------------------------------------------===//
import StdlibUnittest
var tests = TestSuite("Integers")

func expectBigInt(
  expected: [LLVMWord], _ actual: LLVMBigInt,
  @autoclosure _ message: ()->String = "",
  file: String = __FILE__, line: UInt = __LINE__
) {
  expectEqualSequence(
    expected, actual.words.reverse(), message(), file: file, line: line)
}

tests.test("LLVMInt.countWords") {
  expectEqual(1, LLVMInt8(0).countWords)
  expectEqual(1, LLVMInt16(0).countWords)
  expectEqual(1, LLVMInt32(0).countWords)
  expectEqual(1, LLVMInt${word_bits}(0).countWords)
  expectEqual(2, LLVMInt${word_bits*2}(0).countWords)
}

tests.test("LLVMInt._minWordCount") {
  expectEqual(1, LLVMInt8(0)._minWordCount(LLVMInt16(0xBEEF)))
  expectEqual(1, LLVMInt16(0)._minWordCount(LLVMInt8(0xBEEF)))
  expectEqual(1, LLVMInt16(0)._minWordCount(LLVMInt16(0xBEEF)))
  expectEqual(1, LLVMInt16(0)._minWordCount(LLVMInt16(0xBEEF)))
  expectEqual(1, LLVMInt${word_bits}(0)._minWordCount(LLVMInt${word_bits*2}(0)))
  expectEqual(1, LLVMInt${word_bits*2}(0)._minWordCount(LLVMInt${word_bits}(0)))
  expectEqual(
    2, LLVMInt${word_bits*2}(0)._minWordCount(LLVMInt${word_bits*2}(0)))
}

tests.test("LLVMBigInt.Literals") {
  expectBigInt([], 0)
  expectBigInt([1], 1)
  expectBigInt([-1], -1)
  expectBigInt([${(1 << (word_bits-1)) - 1}], ${(1 << (word_bits-1)) - 1})
  expectBigInt([0, ${1 << (word_bits-1)}], ${(1 << (word_bits-1))})
  expectBigInt([1, 0], ${1 << word_bits})
  expectBigInt([${-1 << (word_bits - 1)}], ${-1 << (word_bits - 1)})
  expectBigInt([-1, 0], ${-1 << word_bits})
  expectBigInt([-1, 1], ${(-1 << word_bits) + 1})
  expectBigInt([-2, -1], ${(-1 << word_bits) - 1})
}

tests.test("Truncating.ToLLVMBigInt") {
  expectBigInt([-1], LLVMBigInt(truncatingSigned: LLVMWord(-1)))
  expectBigInt([-1], LLVMBigInt(truncatingUnsigned: LLVMWord(-1)))
  expectBigInt([-1], LLVMBigInt(truncatingSigned: LLVMInt8(-1)))
  expectBigInt([0xFF], LLVMBigInt(truncatingUnsigned: LLVMInt8(-1)))
  expectBigInt([-1, -1], LLVMBigInt(truncatingSigned: LLVMDoubleWord(-1)))
  expectBigInt([-1, -1], LLVMBigInt(truncatingUnsigned: LLVMDoubleWord(-1)))
}

tests.test("signedWord") {
  expectEqual(-1, LLVMInt8(0xFF).signedWord(0))
  expectEqual(-2, LLVMInt8(0xFE).signedWord(0))
  expectEqual(-3, LLVMInt8(0xFD).signedWord(0))
  
  expectEqual(-256, LLVMInt16(0xFF00).signedWord(0))
  expectEqual(-255, LLVMInt16(0xFF01).signedWord(0))
  expectEqual(-512, LLVMInt16(0xFE00).signedWord(0))
  expectEqual(-511, LLVMInt16(0xFE01).signedWord(0))
  expectEqual(-1024, LLVMInt16(0xFC00).signedWord(0))
  expectEqual(-1023, LLVMInt16(0xFC01).signedWord(0))

}

tests.test("Truncating.16to8") {
  expectEqual(-1, LLVMInt8(truncatingSigned: LLVMInt16(-1)))
  expectEqual(-1, LLVMInt8(truncatingUnsigned: LLVMInt16(-1)))
  expectEqual(1, LLVMInt8(truncatingSigned: LLVMInt16(1)))
  expectEqual(1, LLVMInt8(truncatingUnsigned: LLVMInt16(1)))
  
  expectEqual(0xEF, LLVMInt8(truncatingSigned: LLVMInt16(0xBEEF)))
  expectEqual(0xEF, LLVMInt8(truncatingUnsigned: LLVMInt16(0xBEEF)))
  expectEqual(0xEF, LLVMInt8(truncatingSigned: LLVMInt16(0x0DEF)))
  expectEqual(0xEF, LLVMInt8(truncatingUnsigned: LLVMInt16(0x0DEF)))
}

tests.test("Truncating.16to16") {
  expectEqual(-1, LLVMInt16(truncatingSigned: LLVMInt16(-1)))
  expectEqual(-1, LLVMInt16(truncatingUnsigned: LLVMInt16(-1)))
  expectEqual(1, LLVMInt16(truncatingSigned: LLVMInt16(1)))
  expectEqual(1, LLVMInt16(truncatingUnsigned: LLVMInt16(1)))
  expectEqual(0xBEEF, LLVMInt16(truncatingSigned: LLVMInt16(0xBEEF)))
  expectEqual(0xBEEF, LLVMInt16(truncatingUnsigned: LLVMInt16(0xBEEF)))
  expectEqual(0x0DEF, LLVMInt16(truncatingSigned: LLVMInt16(0x0DEF)))
  expectEqual(0x0DEF, LLVMInt16(truncatingUnsigned: LLVMInt16(0x0DEF)))
}

tests.test("Truncating.8to16") {
  expectEqual(-1, LLVMInt16(truncatingSigned: LLVMInt8(-1)))
  expectEqual(0xFF, LLVMInt16(truncatingUnsigned: LLVMInt8(-1)))
  expectEqual(1, LLVMInt16(truncatingSigned: LLVMInt8(1)))
  expectEqual(1, LLVMInt16(truncatingUnsigned: LLVMInt8(1)))
}

tests.test("Truncating.DoubleWordToWord") {
  expectEqual(-1, LLVMWord(truncatingSigned: LLVMDoubleWord(-1)))
  expectEqual(-1, LLVMWord(truncatingUnsigned: LLVMDoubleWord(-1)))
}

tests.test("Truncating.WordToDoubleWord") {
  expectEqual(-1, LLVMDoubleWord(truncatingSigned: LLVMWord(-1)))
  expectEqual(
    LLVMDoubleWord(-1).lshr(${word_bits}),
    LLVMDoubleWord(truncatingUnsigned: LLVMWord(-1)))
}

tests.test("Basics") {
  typealias I8 = LLVMInt8
  typealias W = LLVMInt${word_bits}
  typealias W2 = LLVMInt${word_bits * 2}

  expectEqual(sizeof(W.self), sizeof(Int.self))
  expectEqual(sizeof(W2.self), 2 * sizeof(Int.self))

  let b8: I8 = 0b1_0_11_0_111
  expectEqual(b8, 0b1_0_11_0_111)
  expectEqual(b8, 183)
  expectNotEqual(b8, I8())
  expectEqual(I8(), 0)
  expectEqual(8, I8.bitWidth)
  expectEqual(16, LLVMInt16.bitWidth)
  expectEqual(32, LLVMInt32.bitWidth)

  /// Create a fibonacci sequence
  var a: [I8] = []
  var prior: I8 = 0
  var current: I8 = 1
  while true {
    let next = I8((UInt8(prior.storage) &+ UInt8(current.storage))._value)
    
    expectEqual(next, current.add(prior))
    expectEqual(next, prior.add(current))

    expectEqual(String(next), String(UInt8(next.storage)))
    
    if UInt8(next.storage) <= UInt8(prior.storage) { break }
    
    a.append(next)
    prior = current
    current = next
  }
  checkEquatable(a, oracle: { $0 == $1})
  
  let x = LLVMInt${word_bits}()
  let y = LLVMInt${word_bits * 2}()
  let z = LLVMInt16()
}

runAllTests()

