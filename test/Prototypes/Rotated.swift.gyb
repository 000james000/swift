//===--- Rotated.swift.gyb ------------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %gyb -DWORD_BITS=%target-ptrsize %s -o %t/out.swift
// RUN: %line-directive %t/out.swift -- %target-build-swift -parse-stdlib %t/out.swift -o %t/a.out -Onone
// RUN: %line-directive %t/out.swift -- %target-run %t/a.out
// --stdlib-unittest-filter DoubleWidth/

// REQUIRES: executable_test

import Swift
import StdlibUnittest

%{

from gyb_stdlib_support import (
    TRAVERSALS,
    collectionForTraversal,
    defaultIndicesForTraversal,
    sliceTypeName
)

}%

//===----------------------------------------------------------------------===//
// ConcatenatedCollection
//===----------------------------------------------------------------------===//

/// Represents a position in either the first or second collection of a 
/// `ConcatenatedCollection`.
internal enum _ConcatenatedCollectionIndexRepresentation<
  I1 : Comparable, I2 : Comparable
> {
  case first(I1)
  case second(I2)
}

/// A position in a `ConcatenatedCollection` collection.
public struct ConcatenatedCollectionIndex<
  C1 : Collection, C2 : Collection
> : Comparable {
  /// Creates a new index into the first underlying collection.
  internal init(first i: C1.Index) {
    _position = .first(i)
  }

  /// Creates a new index into the second underlying collection.
  internal init(second i: C2.Index) {
    _position = .second(i)
  }

  internal let _position:
    _ConcatenatedCollectionIndexRepresentation<C1.Index, C2.Index>
}

public func < <C1: Collection, C2: Collection>(
  lhs: ConcatenatedCollectionIndex<C1, C2>,
  rhs: ConcatenatedCollectionIndex<C1, C2>
) -> Bool {
  switch (lhs._position, rhs._position) {
  case (.first, .second):
    return true
  case (.second, .first):
    return false
  case let (.first(l), .first(r)):
    return l < r
  case let (.second(l), .second(r)):
    return l < r
  }
}

public func == <C1: Collection, C2: Collection>(
  lhs: ConcatenatedCollectionIndex<C1, C2>,
  rhs: ConcatenatedCollectionIndex<C1, C2>
) -> Bool {
  switch (lhs._position, rhs._position) {
  case let (.first(l), .first(r)):
    return l == r
  case let (.second(l), .second(r)):
    return l == r
  default:
    return false
  }
}

% for Traversal in TRAVERSALS:
%   Collection = collectionForTraversal(Traversal)
%   Self = "Concatenated" + Collection

/// A concatenation of two collections with the same element type.
public struct ${Self}<C1 : ${Collection}, C2: ${Collection}
  where C1.Iterator.Element == C2.Iterator.Element>: ${Collection} {

  init(_base1: C1, base2: C2) {
    self._base1 = _base1
    self._base2 = base2
  }
  
  public typealias Index = ConcatenatedCollectionIndex<C1, C2>
  
  public var startIndex: Index {
    return ConcatenatedCollectionIndex(first: _base1.startIndex)
  }
  
  public var endIndex: Index {
    return ConcatenatedCollectionIndex(second: _base2.endIndex)
  }
  
  public subscript(i: Index) -> C1.Iterator.Element {
    switch i._position {
    case let .first(i):
      return _base1[i]
    case let .second(i):
      return _base2[i]
    }
  }

  public func index(after i: Index) -> Index {
    switch i._position {
    case let .first(i):
      let next = _base1.index(after: i)
      return next == _base1.endIndex
        ? ConcatenatedCollectionIndex(second: _base2.startIndex)
        : ConcatenatedCollectionIndex(first: next)
    case let .second(i):
      return ConcatenatedCollectionIndex(second: _base2.index(after: i))
    }
  }

%   if Traversal in ['Bidirectional', 'RandomAccess']:
  public func index(before i: Index) -> Index {
    assert(i != startIndex, "Can't advance before startIndex")
    switch i._position {
    case let .first(i):
      return ConcatenatedCollectionIndex(first: _base1.index(before: i))
    case let .second(i):
      return i == _base2.startIndex
        ? ConcatenatedCollectionIndex(
            first: _base1.index(before: _base1.endIndex))
        : ConcatenatedCollectionIndex(second: _base2.index(before: i))
    }
  }
%   end

%   if Traversal is 'RandomAccess':
  public func index(_ i: Index, offsetBy n: ${Self}.IndexDistance) -> Index {
    if n == 0 { return i }
    return n > 0 ? _offsetForward(i, by: n) : _offsetBackward(i, by: -n)
  }

  internal func _offsetForward(_ i: Index, by n: ${Self}.IndexDistance) -> Index {
    switch i._position {
    case let .first(i):
      let d: ${Self}.IndexDistance = numericCast(
        _base1.distance(from: i, to: _base1.endIndex))
      if n < d {
        return ConcatenatedCollectionIndex(
          first: _base1.index(i, offsetBy: numericCast(n)))
      } else {
        return ConcatenatedCollectionIndex(
          second: _base2.index(_base2.startIndex, offsetBy: numericCast(n - d)))
      }
    case let .second(i):
      return ConcatenatedCollectionIndex(
        second: _base2.index(i, offsetBy: numericCast(n)))
    }
  }
  
  internal func _offsetBackward(_ i: Index, by n: ${Self}.IndexDistance) -> Index {
    switch i._position {
    case let .first(i):
      return ConcatenatedCollectionIndex(
        first: _base1.index(i, offsetBy: -numericCast(n)))
    case let .second(i):
      let d: ${Self}.IndexDistance = numericCast(
        _base2.distance(from: _base2.startIndex, to: i))
      if n <= d {
        return ConcatenatedCollectionIndex(
          second: _base2.index(i, offsetBy: -numericCast(n)))
      } else {
        return ConcatenatedCollectionIndex(
          first: _base1.index(_base1.endIndex, offsetBy: -numericCast(n - d)))
      }
    }
  }
%   end

  let _base1: C1
  let _base2: C2
}

/// Returns a new collection that presents a view onto the elements of the
/// first collection and then the elements of the second collection.
func concatenate<
  C1 : ${Collection}, C2 : ${Collection}
  where C1.Iterator.Element == C2.Iterator.Element
>(_ first: C1, _ second: C2) -> ${Self}<C1, C2> {
  return ${Self}(_base1: first, base2: second)
}

% end


//===----------------------------------------------------------------------===//
// RotatedCollection
//===----------------------------------------------------------------------===//

/// A position in a rotated collection.
public struct RotatedCollectionIndex<
  Base : Collection where Base.SubSequence: Collection
> : Comparable {
  internal let _index:
    ConcatenatedCollectionIndex<Base.SubSequence, Base.SubSequence>
}

public func < <Base: Collection where Base.SubSequence: Collection>(
  lhs: RotatedCollectionIndex<Base>, rhs: RotatedCollectionIndex<Base>
) -> Bool {
  return lhs._index < rhs._index
}

public func == <Base: Collection where Base.SubSequence: Collection>(
  lhs: RotatedCollectionIndex<Base>, rhs: RotatedCollectionIndex<Base>
) -> Bool {
  return lhs._index == rhs._index
}

% for Traversal in TRAVERSALS:
%   Collection = collectionForTraversal(Traversal)
%   Self = "Rotated" + Collection

/// A rotated view onto a `${Collection}`.
public struct ${Self}<
  Base : ${Collection} where Base.SubSequence: ${Collection}
> : ${Collection} {
  let _concatenation: Concatenated${Collection}<
    Base.SubSequence, Base.SubSequence>
  
  init(_base: Base, shiftingFirstFrom i: Base.Index) {
    _concatenation = concatenate(_base.suffix(from: i), _base.prefix(upTo: i))
  }
  
  public typealias Index = RotatedCollectionIndex<Base>
  
  public var startIndex: Index {
    return RotatedCollectionIndex(_index: _concatenation.startIndex)
  }
  
  public var endIndex: Index {
    return RotatedCollectionIndex(_index: _concatenation.endIndex)
  }
  
  public subscript(i: Index) -> Base.SubSequence.Iterator.Element {
    return _concatenation[i._index]
  }
  
  public func index(after i: Index) -> Index {
    return RotatedCollectionIndex(_index: _concatenation.index(after: i._index))
  }

%   if Traversal in ['Bidirectional', 'RandomAccess']:
  public func index(before i: Index) -> Index {
    return RotatedCollectionIndex(
      _index: _concatenation.index(before: i._index))
  }
%   end

  public func index(_ i: Index, offsetBy n: ${Self}.IndexDistance) -> Index {
    return RotatedCollectionIndex(
      _index: _concatenation.index(i._index, offsetBy: n))
  }

  /// The shifted position of the base collection's `startIndex`.
  public var shiftedStartIndex: Index {
    return RotatedCollectionIndex(
      _index: ConcatenatedCollectionIndex(
        second: _concatenation._base2.startIndex)
    )
  }
}

extension ${Collection} where SubSequence: ${Collection} {
  /// Returns a view of this collection with the elements reordered such the
  /// element at the given position ends up first.
  ///
  /// The subsequence of the collection up to `i` is shifted to after the
  /// subsequence starting at `i`. The order of the elements within each
  /// partition is otherwise unchanged.
  ///
  ///     let a = [10, 20, 30, 40, 50, 60, 70]
  ///     let r = a.rotated(shiftingFirstFrom: 3)
  ///     // r.elementsEqual([40, 50, 60, 70, 10, 20, 30])
  ///
  /// - Parameter i: The position in the collection that should be first in the
  ///   result. `i` must be a valid index of the collection.
  /// - Returns: A rotated view on the elements of this collection, such that
  ///   the element at `i` is first.
  func rotated(shiftingFirstFrom i: Index) -> ${Self}<Self> {
    return ${Self}(_base: self, shiftingFirstFrom: i)
  }
}

% end

//===----------------------------------------------------------------------===//
// Tests
//===----------------------------------------------------------------------===//

var suite = TestSuite("Rotated")

suite.test("concatenate") {
  let c = concatenate([1, 2, 3, 4, 5], 6...10)
  expectEqual(Array(1...10), Array(c))

  let h = "Hello, "
  let w = "world!"
  let hw = concatenate(h.characters, w.characters)
  expectEqual("Hello, world!", String(hw))
}

suite.test("rotated") {
  let range = 1...10
  let i = range.index(range.startIndex, offsetBy: 3)
  let rotated = range.rotated(shiftingFirstFrom: i)
  expectEqual([4, 5, 6, 7, 8, 9, 10, 1, 2, 3], Array(rotated))
  expectEqual(1, rotated[rotated.shiftedStartIndex])
}

runAllTests()
