// RUN: %swift %s -emit-sil | FileCheck %s

import Builtin
import swift

// Linkage types.

// CHECK: sil clang_thunk @clang_thunk : $() -> ()
sil clang_thunk @clang_thunk : $() -> ()

// CHECK: sil internal @internal_fn : $() -> Int
sil internal @internal_fn : $() -> Int

// Type references

// Some cyclic type references between SIL function bodies.
class Class1 { var a : Class2 }
class Class2 { var b : Class1 }

sil @type_ref1 : $(a : Class1, b : Int) -> ()  // CHECK: $(a : Class1, b : Int64)


// Instructions

sil @test1 : $() -> () {              // CHECK: sil @test1 : $() -> ()
bb0:                                  // CHECK: bb0:
  %0 = tuple ()                       // CHECK:   %0 = tuple ()
  %a = br bb1                         // CHECK: br bb1
bb1:
  %1 = return %0 : $()                // CHECK:   %2 = return %0 : $()
}

// Forward referenced values.
sil @test2 : $() -> () {              // CHECK: sil @test2 : $() -> ()
bb0:
  %0 = br bb2
bb1:
  %b = return %a : $()                // CHECK:   %1 = return %2 : $()
bb2:
  %a = tuple ()                       // CHECK:   %2 = tuple ()
  %1 = br bb1                         // CHECK:   %3 = br bb1
}

sil @named_tuple : $() -> (x : Builtin.Int64, Builtin.Int64) {
  %0 = integer_literal $Builtin.Int64, 42      // CHECK: integer_literal $Builtin.Int64, 42
  %9 = tuple $(x : Builtin.Int64, Builtin.Int64) (%0, %0)
  %10 = return %9 : $(x : Builtin.Int64, Builtin.Int64)
}

sil @return_int : $[thin] (a : Int64) -> Int64 { // CHECK: $[thin] (a : Int64) -> Int64 {
bb0(%0 : $Int64):                          // CHECK: bb0(%0 : $Int64):
  %1 = alloc_var stack $Int64              // CHECK: alloc_var stack $Int64
  %2 = store %0 to %1 : $*Int64            // CHECK: %2 = store %0 to %1 : $*Int64
  %3 = load %1 : $*Int64                   // CHECK: load {{.*}} : $*Int64
  %4 = dealloc_var stack %1 : $*Int64      // CHECK: dealloc_var stack {{.*}} : $*Int64
  %5 = return %3 : $Int64                  // CHECK: return {{.*}} : $Int64
}

sil @call_fn_pointer : $[thin] (a : () -> Int64) -> Int64 {
bb0(%0 : $() -> Int64):
  %1 = alloc_var stack $() -> Int64        // CHECK: alloc_var stack $() -> Int64
  %2 = store %0 to %1 : $*() -> Int64      // CHECK: store %0 to %1 : $*() -> Int64
  %3 = load %1 : $*() -> Int64             // CHECK: load %1 : $*() -> Int64
  %4 = retain %3 : $() -> Int64            // CHECK: retain %3 : $() -> Int64
  %5 = apply %3() : $() -> Int64           // CHECK: apply %3() : $() -> Int64
  %6 = load %1 : $*() -> Int64             // CHECK: load %1 : $*() -> Int64
  %7 = release %6 : $() -> Int64           // CHECK: release {{.*}} : $() -> Int64
  %8 = dealloc_var stack %1 : $*() -> Int64// CHECK: dealloc_var stack %1 : $*() -> Int64
  %9 = return %5 : $Int64                  // CHECK: return %5 : $Int64
}

sil @return_constant : $[thin] () -> Int64 {  // CHECK: @return_constant
bb0:                                         // CHECK: bb0:
  // CHECK: function_ref @_TSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $[thin] ((val : Builtin.Int64), Int64.metatype) -> Int64
  %1 = function_ref @_TSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $[thin] ((val : Builtin.Int64), Int64.metatype) -> Int64

  // CHECK: metatype $Int64.metatype
  %2 = metatype $Int64.metatype

  // CHECK: integer_literal $Builtin.Int64, 1
  %3 = integer_literal $Builtin.Int64, 1
  
  // CHECK: apply
  %4 = apply %1(%3, %2) : $[thin] ((val : Builtin.Int64), Int64.metatype) -> Int64
  // CHECK: return
  %5 = return %4 : $Int64
}

sil @_TSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $[thin] ((val : Builtin.Int64), Int64.metatype) -> Int64

// Parse SIL generated from the following swift program:
// func x(a : Bool) -> Int { if a { return 4 } else {return 5} }
sil @_TSb13getLogicValuefRSbFT_Bi1_ : $[cc(method), thin] ((), [byref] Bool) -> Builtin.Int1
sil @_TSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64

// CHECK: @_T4test1xFT1aSb_Si
sil @_T4test1xFT1aSb_Si : $[thin] (a : Bool) -> Int64 {
// CHECK: bb0(%0 : $Bool):
bb0(%0 : $Bool):
  // CHECK: alloc_var stack $Bool
  %1 = alloc_var stack $Bool
  // CHECK: store
  %2 = store %0 to %1 : $*Bool
  // CHECK: function_ref @_TSb13getLogicValuefRSbFT_Bi1_ : $[cc(method), thin] ((), [byref] Bool) -> Builtin.Int1
  %3 = function_ref @_TSb13getLogicValuefRSbFT_Bi1_ : $[cc(method), thin] ((), [byref] Bool) -> Builtin.Int1
  // CHECK: apply
  %4 = apply %3(%1) : $[cc(method), thin] ((), [byref] Bool) -> Builtin.Int1
  // CHECK: condbranch
  %5 = condbranch %4, bb1, bb2

// CHECK: bb1:
bb1:
  // CHECK: function_ref @_TSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64
  %6 = function_ref @_TSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64
  // CHECK: metatype $Int64.metatype
  %7 = metatype $Int64.metatype
  // CHECK: integer_literal $Builtin.Int128, 4
  %8 = integer_literal $Builtin.Int128, 4
  // CHECK: apply
  %9 = apply %6(%8, %7) : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64
  // CHECK: dealloc_var
  %10 = dealloc_var stack %1 : $*Bool
  // CHECK: return
  %11 = return %9 : $Int64

// CHECK: bb2:
bb2:
  // CHECK: function_ref @_TSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64
  %12 = function_ref @_TSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64
  // CHECK: metatype $Int64.metatype
  %13 = metatype $Int64.metatype
  // CHECK: integer_literal $Builtin.Int128, 5
  %14 = integer_literal $Builtin.Int128, 5
  // CHECK: apply
  %15 = apply %12(%14, %13) : $[thin] ((val : Builtin.Int128), Int64.metatype) -> Int64
  // CHECK: dealloc_var
  %16 = dealloc_var stack %1 : $*Bool
  // CHECK: return
  %17 = return %15 : $Int64
}


protocol P {
  func doIt()
}

sil @existentials : $[thin] (n : P) -> () {
bb0(%0 : $*P):
  %1 = project_existential %0 : $*P   // CHECK: project_existential %0

//  %2 = protocol_method %0, @doIt.1
//  %3 = apply %2(%1) : $[cc(method)] ((), Builtin.OpaquePointer) -> ()
  %4 = tuple ()                       // CHECK: tuple ()
  %5 = destroy_addr %0 : $*P          // CHECK: destroy_addr %0 : $*P
  %6 = return %4 : $()                // CHECK: return 
}


class C {
  func doIt() {}
}

sil @classes : $[thin] () -> () {
bb0:
  %0 = alloc_ref heap $C                                      // CHECK: %0 = alloc_ref heap $C
  %1 = ref_to_object_pointer %0 : $C, $Builtin.ObjectPointer  // CHECK: ref_to_object_pointer %0 : $C, $Builtin.ObjectPointer
}
