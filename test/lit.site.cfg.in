import sys
import platform
import re

## Autogenerated by Swift configuration.
# Do not edit!
config.llvm_src_root = "@LLVM_MAIN_SRC_DIR@"
config.llvm_obj_root = "@LLVM_BINARY_DIR@"
config.llvm_tools_dir = "@LLVM_TOOLS_DIR@"
config.llvm_libs_dir = "@LLVM_LIBS_DIR@"
config.lit_tools_dir = "@LLVM_LIT_TOOLS_DIR@"
config.swift_obj_root = "@SWIFT_BINARY_DIR@"
config.target_triple = "@TARGET_TRIPLE@"
config.targets_to_build = "@TARGETS_TO_BUILD@"

# Support substitution of the tools and libs dirs with user parameters. This is
# used when we can't determine the tool dir at configuration time.
try:
    config.llvm_tools_dir = config.llvm_tools_dir % lit_config.params
    config.llvm_libs_dir = config.llvm_libs_dir % lit_config.params
except KeyError:
    e = sys.exc_info()[1]
    key, = e.args
    lit_config.fatal("unable to find %r parameter, use '--param=%s=VALUE'" % (key,key))

# Enable Darwin SDK-dependent tests if we have an SDK.
# On Linux, assume that SDK path does not point to the Darwin SDK.
if "@MODULES_SDK@" != "" and platform.system() != 'Linux':
  config.available_features.add("sdk")
  config.substitutions.append(('%sdk', "@MODULES_SDK@"))

if "@SWIFT_RUN_LONG_TESTS@" != "OFF" and "@SWIFT_RUN_LONG_TESTS@" != "NO":
  config.available_features.add("long_tests")

if "@SWIFT_ASAN_BUILD@" != "OFF" and "@SWIFT_ASAN_BUILD@" != "NO":
  config.available_features.add("asan")

if "@SWIFT_NEW_DRIVER@" != "ON" and "@SWIFT_NEW_DRIVER@" != "YES":
  config.swift_new_driver = False
else:
  config.swift_new_driver = True

# Let the main config do the real work.
lit_config.load_config(config, "@SWIFT_SOURCE_DIR@/test/lit.cfg")

# Add each available build target CPU as a feature.
for target in config.targets_to_build.split():
  config.available_features.add(target)

# Add the run target CPU and OS as features.
config.test_triple = lit_config.params.get('test_triple', None)
(run_cpu, run_vendor, run_os, run_vers) = re.match('([^-]+)-([^-]+)-([^0-9]+)(.*)', config.test_triple).groups()
config.available_features.add("CPU=" + run_cpu)
config.available_features.add("OS=" + run_os)


# Enable interpreter-based tests on platforms where the interpreter is known to
# work.
if platform.system() == 'Darwin' and (run_os == 'macosx' or run_os == 'darwin'):
  config.available_features.add('swift_interpreter')
  config.available_features.add('swift_repl')

if '@SWIFT_ASSERTS@' == 'ON':
  config.available_features.add('swift_stdlib_asserts')

# Substitutions for running on a target machine that is not the build machine.
# %target-run          (run a command on the target machine)
# %target-build-swift  (compile and link swift files for the target platform)
# %target-run-simple-swift (build and run one test file on the target platform)

# These substitutions must use the new swift driver, 
# but cannot depend on %swift to get it.
if (config.swift_new_driver):
    driver = config.swift
else:
    driver = config.swift_driver

if run_vendor == 'apple':
    test_stdlib = lit_config.params.get('test_stdlib')
    if not test_stdlib:
        lit_config.fatal("No --param test_stdlib specified")
    lit_config.note('testing stdlib ' + test_stdlib)
    if 'arm' in run_cpu:
        # iOS device
        lit_config.note('testing iOS device ' + config.test_triple)
        if not config.swift_ios_test:
        config.target_build_swift = (
            'xcrun -sdk iphoneos %s -target %s '
            '-Xlinker -rpath -Xlinker %s -I %s -L %s '
            % (driver, config.test_triple, 
               '/tmp/swifttest-device/lib', test_stdlib, test_stdlib))
        config.target_run = (
            '/usr/bin/env %r --source-dir=%%S --test-dir=%%T --' 
            % (config.swift_ios_test))

    elif run_os == 'ios':
        # iOS simulator
        lit_config.note("testing iOS simulator " + config.test_triple)
        config.target_build_swift = (
            'xcrun -sdk iphonesimulator %s -target %s '
            '-Xlinker -rpath -Xlinker %s -I %s -L %s'
            % (driver, config.test_triple, 
               test_stdlib, test_stdlib, test_stdlib))
        # FIXME: simulator libc writes directly to tty?
        # `script` captures tty output so it can be piped to FileCheck
        config.target_run = '/usr/bin/script -q /dev/null /usr/bin/env DYLD_ROOT_PATH=`xcrun -sdk iphonesimulator --show-sdk-path`'

    elif run_os == 'macosx':
        # OS X
        lit_config.note("testing OS X " + config.test_triple)
        config.target_build_swift = (
            'xcrun -sdk macosx %s -target %s '
            '-Xlinker -rpath -Xlinker %s -I %s -L %s'
            % (driver, config.test_triple, 
               test_stdlib, test_stdlib, test_stdlib))
        config.target_run = ''

    else:
        lit_config.fatal("Unknown Apple OS '" + run_os + "' " + 
                         "(from " + config.test_triple + ")")

else:
    # not Apple
    lit_config.fatal("Don't know how to define target_run and "
                     "target_build_swift for platform " + config.test_triple)

config.target_run_simple_swift = (
    'rm -rf %%t && mkdir -p %%t && '
    '%s -module-cache-path %%t/clang-module-cache %%s -o %%t/a.out && '
    '%s %%t/a.out'
    % (config.target_build_swift, config.target_run))

config.substitutions.append(('%target-run-simple-swift', config.target_run_simple_swift))
config.substitutions.append(('%target-run', config.target_run))
config.substitutions.append(('%target-build-swift', config.target_build_swift))
