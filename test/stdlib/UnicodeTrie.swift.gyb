// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb -DunicodeGraphemeBreakPropertyFile=%S/../../utils/UnicodeData/GraphemeBreakProperty.txt -DunicodeGraphemeBreakTestFile=%S/../../utils/UnicodeData/GraphemeBreakTest.txt %s -o %t/UnicodeTrie.swift
// RUN: %S/../../utils/line-directive %t/UnicodeTrie.swift -- %target-build-swift -module-cache-path %t/clang-module-cache %t/UnicodeTrie.swift -o %t/a.out -g
// RUN: %target-run %t/a.out | %S/../../utils/line-directive %t/UnicodeTrie.swift -- FileCheck %t/UnicodeTrie.swift

%{

from GYBUnicodeDataUtils import *

grapheme_cluster_break_property_table = \
    GraphemeClusterBreakPropertyTable(unicodeGraphemeBreakPropertyFile)

}%

import StdlibUnittest
import Darwin
import Foundation
/*
var graphemeBreakPropertyTable = [
% for start_code_point,end_code_point,value in grapheme_cluster_break_property_table.property_value_ranges:
  (${start_code_point}, ${end_code_point}, _GraphemeClusterBreakPropertyValue.${value}),
% end
]
*/
var UnicodeTrie = TestCase("UnicodeTrie")
/*
UnicodeTrie.test("_UnicodeGraphemeClusterBreakPropertyTrie") {
  var trie = _UnicodeGraphemeClusterBreakPropertyTrie()

  var expected = [_GraphemeClusterBreakPropertyValue](count: 0x110000,
      repeatedValue: _GraphemeClusterBreakPropertyValue.Other)
  for (startCodePoint, endCodePoint, value) in graphemeBreakPropertyTable {
    for cp in startCodePoint...endCodePoint {
      expected[cp] = value
    }
  }

  for cp in UInt32(0)...UInt32(0x10ffff) {
    if cp % 0x10000 == 0 {
      println("\(cp)...")
    }
    expectEqual(expected[Int(cp)], trie.getPropertyValue(cp)) {
      "code point \(cp)"
    }
  }
}
*/
%{

grapheme_cluster_break_tests = \
    get_grapheme_cluster_break_tests_as_unicode_scalars(unicodeGraphemeBreakTestFile)

}%

// The most simple subclass of NSString that CoreFoundation does not know
// about.
class NonContiguousNSString : NSString {
  init(_ value: [UInt16]) {
    _value = value
    super.init()
  }

  convenience init(_ scalars: [UInt32]) {
    var encoded: [UInt16] = []
    var g = scalars.generate()
    let hadError = transcode(UTF32.self, UTF16.self, g,
        SinkOf {
          encoded += $0
        },
        stopOnError: true)
    expectFalse(hadError)
    self.init(encoded)
  }

  @objc override func copyWithZone(zone: NSZone) -> AnyObject {
    // Ensure that copying this string produces a class that CoreFoundation
    // does not know about.
    return self
  }

  @objc override var length: Int {
    return _value.count
  }

  @objc override func characterAtIndex(index: Int) -> unichar {
    return _value[index]
  }

  var _value: [UInt16]
}

func checkGraphemeClusterSegmentation(
    expectedBoundaries: [Int], subject: String, stackTrace: SourceLocStack
) {
  var actualBoundaries: [Int] = [ 0 ]
  var unicodeScalarCount = 0
  for c in subject {
    let currentClusterSize = countElements(String(c).unicodeScalars)
    unicodeScalarCount += currentClusterSize
    actualBoundaries += [ unicodeScalarCount ]
  }
  expectEqual(expectedBoundaries, actualBoundaries,
      stackTrace: stackTrace.withCurrentLoc()) {
    "scalars: \(asHex(lazy(subject.unicodeScalars).map { $0.value }.array))"
  }

  var expectedCharacters: [Character] = Array(subject)
  checkSliceableWithBidirectionalIndex(expectedCharacters, subject,
      stackTrace.withCurrentLoc())
}

func checkGraphemeClusterSegmentation(
    expectedBoundaries: [Int], #scalars: [UInt32], stackTrace: SourceLocStack
) {
  let subject: String = NonContiguousNSString(scalars)
  checkGraphemeClusterSegmentation(expectedBoundaries, subject,
      stackTrace.withCurrentLoc())
}

func checkGraphemeClusterSegmentation(
    expectedBoundaries: [Int], #codeUnits: [UInt16], stackTrace: SourceLocStack
) {
  let subject: String = NonContiguousNSString(codeUnits)
  checkGraphemeClusterSegmentation(expectedBoundaries, subject,
      stackTrace.withCurrentLoc())
}

UnicodeTrie.test("GraphemeClusterSegmentation") {
% for code_points,expected_boundaries in grapheme_cluster_break_tests:
  if true {
    let scalars: [UInt32] = [ ${", ".join([ str(cp) for cp in code_points ])} ]
    let expectedBoundaries: [Int] = [ ${", ".join([ str(x) for x in expected_boundaries ])} ]
    checkGraphemeClusterSegmentation(expectedBoundaries, scalars: scalars,
        SourceLocStack().withCurrentLoc())
  }

% end
}

UnicodeTrie.test("GraphemeClusterSegmentation/Extra") {
  // U+D800 (high-surrogate)
  checkGraphemeClusterSegmentation(
      [ 0, 1 ],
      codeUnits: [ 0xd800 ],
      SourceLocStack().withCurrentLoc())

  // U+D800 (high-surrogate)
  // U+D800 (high-surrogate)
  checkGraphemeClusterSegmentation(
      [ 0, 1, 2 ],
      codeUnits: [ 0xd800, 0xd800 ],
      SourceLocStack().withCurrentLoc())

  // U+0041 LATIN CAPITAL LETTER A
  // U+D800 (high-surrogate)
  checkGraphemeClusterSegmentation(
      [ 0, 1, 2 ],
      codeUnits: [ 0x0041, 0xd800 ],
      SourceLocStack().withCurrentLoc())

  // U+D800 (high-surrogate)
  // U+0041 LATIN CAPITAL LETTER A
  checkGraphemeClusterSegmentation(
      [ 0, 1, 2 ],
      codeUnits: [ 0xd800, 0x0041 ],
      SourceLocStack().withCurrentLoc())

  // U+0041 LATIN CAPITAL LETTER A
  // U+0301 COMBINING ACUTE ACCENT
  // U+D800 (high-surrogate)
  checkGraphemeClusterSegmentation(
      [ 0, 2, 3 ],
      codeUnits: [ 0x0041, 0x0301, 0xd800 ],
      SourceLocStack().withCurrentLoc())

  // U+D800 (high-surrogate)
  // U+0041 LATIN CAPITAL LETTER A
  // U+0301 COMBINING ACUTE ACCENT
  checkGraphemeClusterSegmentation(
      [ 0, 1, 3 ],
      codeUnits: [ 0xd800, 0x0041, 0x0301 ],
      SourceLocStack().withCurrentLoc())
}

UnicodeTrie.run()
// CHECK: {{^}}UnicodeTrie: All tests passed

