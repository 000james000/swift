//===--- CommonMethods.swift.gyb ------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb %s -o %t/out.swift
// RUN: %S/../../utils/line-directive %t/out.swift -- %target-build-swift -module-cache-path %t/clang-module-cache %t/out.swift -o %t/a.out
// RUN: %target-run %t/a.out

import StdlibUnittest

var allTests = TestSuite("CommonMethods")

struct SequenceLimiter<S: SequenceType> : SequenceType {
  init(_ x: S) {
    s = x
  }
  func generate() -> S.Generator {
    return s.generate()
  }
  var s: S
}

% traversals = 'Forward', 'Bidirectional', 'RandomAccess'
% for Traversal in traversals:
struct ${Traversal}IndexLimiter<I: ${Traversal}IndexType>
: ${Traversal}IndexType {

  typealias Distance = I.Distance
  
  init(_ x: I) {
    i = x
  }
  func successor() -> ${Traversal}IndexLimiter {
    return ${Traversal}IndexLimiter(i.successor())
  }
  
  % if Traversal != 'Forward':
  func predecessor() -> ${Traversal}IndexLimiter {
    return ${Traversal}IndexLimiter(i.predecessor())
  }
  % end

  % if Traversal == 'RandomAccess':
  func advancedBy(n: Distance) -> ${Traversal}IndexLimiter {
    return ${Traversal}IndexLimiter(i.advancedBy(n))
  }
  func distanceTo(other: ${Traversal}IndexLimiter) ->  Distance {
    return i.distanceTo(other.i)
  }
  % end
  var i: I
}

func == <I: ${Traversal}IndexType>(
  lhs: ${Traversal}IndexLimiter<I>, rhs: ${Traversal}IndexLimiter<I>
) -> Bool {
  return lhs.i == rhs.i
}

struct ${Traversal}CollectionLimiter<
  C: CollectionType where C.Index: ${Traversal}IndexType
> : CollectionType {
  init(_ x: C) {
    c = x
  }
  func generate() -> C.Generator {
    return c.generate()
  }
  typealias Index = ${Traversal}IndexLimiter<C.Index>
  var startIndex: Index {
    return Index(c.startIndex)
  }
  var endIndex: Index {
    return Index(c.endIndex)
  }
  subscript(i: Index) -> C.Generator.Element {
    return c[i.i]
  }
  var c: C
}
% end

func expectType<T>(_: T.Type, inout x: T) {}

% arrays = ['Array(%s)', 'Slice(%s)', 'ContiguousArray(%s)']
% limiters = ['Sequence'] + [ x+'Collection' for x in traversals ]
% for Self in ['lazy('+x+'Limiter(%s))' for x in limiters] + arrays:
allTests.test("${Self} any/all") {
  let c = ${Self%'0..<4'}
  if true {
    var anyResult = c.any { $0 > 2 }
    var allResult = c.all { $0 > 2 }
    expectType(Bool.self, &anyResult)
    expectType(Bool.self, &allResult)
  }
  expectTrue(c.any { $0 > 2 })
  expectFalse(c.any { $0 > 4 })
  expectTrue(c.all { $0 > -1 })
  expectFalse(c.all { $0 > 4 })
}
%end

runAllTests()
