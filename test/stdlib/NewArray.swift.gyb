%# -*- mode: swift -*-
//===--- Array.swift ------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN-DISABLED: %target-run-simple-swift | FileCheck %s
// RUN: rm -rf %t && mkdir -p %t && %S/../../utils/gyb %s -o %t/NewArray.swift
// RUN: %S/../../utils/line-directive %t/NewArray.swift -- %target-build-swift -module-cache-path %t/clang-module-cache %t/NewArray.swift -o %t/a.out
// RUN: %target-run %t/a.out | %S/../../utils/line-directive %t/NewArray.swift -- FileCheck %t/NewArray.swift

var xCount = 0
var xSerial = 0

// Instead of testing with Int elements, we use this wrapper class
// that can help us track allocations and find issues with object
// lifetime inside Array implementations.
class X : ForwardIndex, Comparable, Printable {
  init(_ value: Int) {
    ++xCount
    serial = ++xSerial
    self.value = value
  }
  
  deinit {
    assert(serial > 0, "double destruction!")
    --xCount
    serial = -serial
  }

  var description: String {
    assert(serial > 0, "dead X!")
    return value.description
  }

  func succ() -> X {
    return X(self.value.succ())
  }
  
  var value: Int
  var serial: Int
}

func == (x: X, y: X) -> Bool {
  return x.value == y.value
}

func < (x: X, y: X) -> Bool {
  return x.value < y.value
}

extension Int {
  @conversion
  func __conversion() -> X {
    return X(self)
  }
}

//===----------------------------------------------------------------------===//

func printSequence<T: Sequence>(x: T) {
  print("[")
  var prefix = ""
  for a in x {
    print(prefix)
    print(a)
    prefix = ", "
  }
  println("]")
}

func bufferID<T : ArrayType>(x: T) -> Int {
  return reinterpretCast(x.buffer.elementStorage) as Int
}

func checkReallocation<T : ArrayType>(
  x: T, lastBuffer: Int, reallocationExpected: Bool
) -> Int {
  let currentBuffer = bufferID(x)
  if (currentBuffer != lastBuffer) != reallocationExpected {
    let message = reallocationExpected ? "lack of" : ""
    println("unexpected \(message) reallocation")
  }
  return currentBuffer
}

func checkEqual<
    S1 : Sequence, S2 : Sequence
  where 
    S1.GeneratorType.Element == S2.GeneratorType.Element,
    S1.GeneratorType.Element : Equatable
>(a1: S1, a2: S2, expected: Bool) {
  if equal(a1, a2) != expected {
    let un = expected ? "un" : ""
    println("unexpectedly \(un)equal sequences!")
  }
}

func test<
  T: ArrayType
where T.GeneratorType.Element == T.Buffer.Element,
          T.Buffer.Element == T.Element,
          T.Element == X,
          T.IndexType == Int
>(_: T.Type, label: String) {
  print("test: \(label)...")

  var x: T = [1, 2, 3, 4, 5]
  
  checkEqual(x, 1...5, true)

  x.reserveCapacity(x.count + 2)
  checkEqual(x, 1...5, true)
  
  let bufferId0 = bufferID(x)

  // Append a range of integers
  x += 0..2
  let bufferId1 = checkReallocation(x, bufferId0, false)
  
  for i in x.count..(x.capacity + 1) {
    let bufferId1a = checkReallocation(x, bufferId1, false)
    x += 13
  }
  let bufferId2 = checkReallocation(x, bufferId1, true)

  let y = x
  x[x.endIndex.pred()] = 17
  let bufferId3 = checkReallocation(x, bufferId2, false)
  checkEqual(x, y, true)

  if x !== y {
    println("unexpectedly, x !== y")
  }

  x += 42
  checkEqual(x, y, false)
  if x === y {
    println("unexpectedly, x === y")
  }
  
  println("done.")
}

println("testing...")
// CHECK: testing...

test(ContiguousArray<X>.self, "ContiguousArray")
// CHECK-NEXT: test: ContiguousArray...done

test(Array<X>.self, "Array")
// CHECK-NEXT: test: Array...done

test(Slice<X>.self, "Slice")
// CHECK-NEXT: test: Slice...done

func testAsArray() {
  println("== AsArray ==")
  var w: ContiguousArray<X> = [4, 2, 1]
  // CHECK: == AsArray == 
  
  let x = ContiguousArray(w)
  println(bufferID(w) == bufferID(x))
  // CHECK-NEXT: false
  
  let y = Array(x)
  println(bufferID(x) == bufferID(y))
  // CHECK-NEXT: false

  // Because of their indirection, arrays of classes can share
  // buffers.  
  let y1 = Array(y)
  println(bufferID(y1) == bufferID(y))
  // However, I'm not implementing that optimization yet, thus false.
  // CHECK-NEXT: false
  
  let z = Slice(y)
  println(bufferID(y) == bufferID(z))
  // CHECK-NEXT: false

  w = ContiguousArray(z)
  println(bufferID(w) == bufferID(z))
  // CHECK-NEXT: false
}
testAsArray()

import Foundation

func nsArrayOfStrings() -> Array<NSString> {
  let src: ContiguousArray<NSString> = ["foo", "bar", "baz"]

  let ns =  NSArray(
    objects: UnsafePointer(src.buffer.elementStorage),
    count: src.count)

  return Array(ArrayBuffer(reinterpretCast(ns) as _CocoaArray))
}

func testCocoa() {
  println("== Cocoa ==")
  // CHECK: == Cocoa ==

  var a = nsArrayOfStrings()
  printSequence(a)
  // CHECK-NEXT: [foo, bar, baz]
  
  a += "qux"
  printSequence(a)
  // CHECK-NEXT: [foo, bar, baz, qux]

  a = nsArrayOfStrings()
  printSequence(a)
  // CHECK-NEXT: [foo, bar, baz]
  
  var b = a
  
  a[1] = "garply"
  printSequence(a)
  // CHECK-NEXT: [foo, garply, baz]

  // Mutating an element in a changes b, too
  printSequence(b)
  // CHECK-NEXT: [foo, garply, baz]
  
  a = nsArrayOfStrings()
  a.insert(2, newElement: "bag")
  printSequence(a)
  // CHECK-NEXT: [foo, bar, bag, baz]

  a = nsArrayOfStrings()
  a.reserveCapacity(30)
  printSequence(a)
  // CHECK-NEXT: [foo, bar, baz]
  
  println(a.capacity >= 30)
  // CHECK-NEXT: true
}
testCocoa()

extension Slice {
  mutating func qsort(compare: (T,T)->Bool) {
    quickSort(&self, indices(self), compare)
  }
}

func testSlice() {
  println("== Slice ==")
  // CHECK: == Slice ==
  
  // do some tests on the shared semantics
  var b = ContiguousArray(X(0)..X(7))

  // Slice it
  var bSlice = b[3..5]
  println("<\(bSlice.count)>")
  // CHECK-NEXT: <2>
  printSequence(bSlice)
  // CHECK-NEXT: [3, 4]

  // bSlice += X(11)..X(13)

  // Writing into b changes bSlice
  b[4] = 41        
  printSequence(bSlice)           // CHECK-NEXT: [3, 41]

  // Writing into bSlice changes b
  bSlice[1] = 42                  // CHECK-NEXT: [3, 42]
  printSequence(bSlice) 
  printSequence(b)                // CHECK-NEXT: [0, 1, 2, 3, 42, 5, 6]

  var c = b
  b[4..b.count].qsort(<)
  printSequence(b)                // CHECK-NEXT: [0, 1, 2, 3, 5, 6, 42]
  printSequence(c)                // CHECK-NEXT: [0, 1, 2, 3, 5, 6, 42]

  // Now a bridged slice
  var a = Array<NSString>(
    ArrayBuffer(nsArrayOfStrings()._asCocoaArray()))
  
  printSequence(a)                // CHECK-NEXT: [foo, bar, baz]
  
  var aSlice = a[1..3]           // CHECK-NEXT: [bar, baz]
  printSequence(aSlice)  

  // Writing into aSlice works
  aSlice[0] = "buzz"              // CHECK-NEXT: [buzz, baz]
  printSequence(aSlice)  

  // ...and also changes a with reference semantics
  printSequence(a)                // CHECK-NEXT: [foo, buzz, baz]

  // Appending to aSlice works...
  aSlice += "fodder"              
  println("<\(aSlice.count)>")    // CHECK-NEXT: <3>
  printSequence(aSlice)           // CHECK-NEXT: [buzz, baz, fodder]

  // And doesn't change a
  printSequence(a)                // CHECK-NEXT: [foo, buzz, baz]
}
testSlice()

//===--- sub-range replacement --------------------------------------------===//

// Size of the array on which we're going to test "replace."
// testing time grows roughly as the cube of this constant
let testWidth = 11

%for A in ['ContiguousArray', 'Array', 'Slice']:

// FIXME: When <rdar://problem/16530674> is handled we can stop
// gybbing and go back to using a generic function here
func testReplace/*<
  A: ArrayType
  where A.GeneratorType.Element == X, A.Buffer.Element == X, A.IndexType == Int
>*/(make: ()->${A}<X>) {

  typealias A = ${A}<X>

  // First make an independent copy of the array that we can use for
  // comparison later.
  var source = ContiguousArray<A.GeneratorType.Element>()
  for x in make() {
    source += x
  }
  
  for i in indices(source) {
    for j in i..source.count {

      let oldCount = j - i
      for newCount in 0..(2 * oldCount) {
        let newValues = X(100)..X(100 + newCount)

        func reportFailure(inout a: A, message: String) {
          print("\(message) when replacing indices \(i)...\(j) in ")
          printSequence(source)
          print("  with ")
          printSequence(newValues)
          print(" yielding ")
          printSequence(a)
          println("====================================")
        }

        var a = make()
     
        replace(&a, i..j, newValues)
        let growth = newCount - oldCount
        
        let expectedCount = source.count + growth
        if a.count != expectedCount {
          reportFailure(
            &a, "\(a.count) != expected count \(expectedCount)")
        }
        
        for k in 0..a.count {
          let expectedValue = k < i ? source[k].value
          : k < j + growth ? 100 + k - i
          : source[k - growth].value

          if a[k].value != expectedValue {
            reportFailure(
              &a, "a[\(k)] = \(a[k].value) != expected value \(expectedValue)")
          }
        }
      }
    }
  }
}

func testReplace${A}(
  makeOne: ()->${A}<X> = {
    var x = ${A}<X>()
    // make sure some - but not all - replacements will have to grow the buffer
    x.reserveCapacity(testWidth * 3 / 2)
    x += X(0)..X(testWidth)
    return x
  }
) {
  testReplace(makeOne)

  // Create one that will not be uniquely-referenced so we can test
  // the out-of-place code paths.
  let r = makeOne()
  testReplace({ r })
  
  // This test should ensure r's retain isn't dropped before we start testing.
  if (r.count != testWidth) {
    println("something bad happened!")
  }
}

println("testing subrange replacement in ${A}")
testReplace${A}()
%end

// Also test with a sub-slice of some larger buffer.  The "trailing"
// case is interesting because when the buffer is uniquely referenced
// we can expect to expand the slice in-place
for (maxValue, label) in [(testWidth, "trailing"), (testWidth*2, "interior")] {
  println("testing subrange replacement in \(label) Sub-Slice")
  testReplaceSlice {
    var a = ContiguousArray(X(-testWidth)..X(maxValue))
    a.reserveCapacity(a.count * 3 / 2)
    return a[testWidth..(2 * testWidth)]
  }
}

// CHECK-NEXT: testing subrange replacement in ContiguousArray
// CHECK-NEXT: testing subrange replacement in Array
// CHECK-NEXT: testing subrange replacement in Slice
// CHECK-NEXT: testing subrange replacement in trailing Sub-Slice
// CHECK-NEXT: testing subrange replacement in interior Sub-Slice

//===--- single-element modifiers -----------------------------------------===//

%for A in ['ContiguousArray', 'Array', 'Slice']:

func testSingleElementModifiers${A}() {
  println("testing ${A} single-argument modifiers")
  // CHECK-NEXT: testing ${A} single-argument modifiers
  
  var a = ${A}(X(0)..10)
  println(a.popLast().value)     // CHECK-NEXT: 9
  printSequence(a)               // CHECK-NEXT: [0, 1, 2, 3, 4, 5, 6, 7, 8]
  
  a.insert(4, newElement: 42)
  printSequence(a)               // CHECK-NEXT: [0, 1, 2, 3, 42, 4, 5, 6, 7, 8]
  
  println(a.removeAt(2).value)   // CHECK-NEXT: 2
  printSequence(a)               // CHECK-NEXT: [0, 1, 3, 42, 4, 5, 6, 7, 8]
}
testSingleElementModifiers${A}()
%end

//===--- Regression Tests -------------------------------------------------===//
import SpriteKit

class Rdar16914909 : NSObject {
  var basicColorSet = SKColor[]()
  
  func doColorStuff() {
    basicColorSet.append(SKColor.lightGrayColor())
    println("appended")
  }
}

Rdar16914909().doColorStuff()
// CHECK-NEXT: appended

println("leaks = \(xCount)")
// CHECK-NEXT: leaks = 0

// CHECK-NEXT: all done.
println("all done.")

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
