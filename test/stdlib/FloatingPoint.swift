// RUN: %target-run-stdlib-swift
// XFAIL: interpret

import Swift
import StdlibUnittest

#if arch(i386) || arch(x86_64)

struct Float80Bits : Equatable, Printable {
  var signAndExponent: UInt16
  var significand: UInt64

  init(_ signAndExponent: UInt16, _ significand: UInt64) {
    self.signAndExponent = signAndExponent
    self.significand = significand
  }

  var description: String {
    return "(\(String(signAndExponent, radix: 16)) \(String(significand, radix: 16))))"
  }
}

func == (lhs: Float80Bits, rhs: Float80Bits) -> Bool {
  return
    lhs.signAndExponent == rhs.signAndExponent &&
    lhs.significand == rhs.significand
}

extension Float80 {
  func _toBitPattern() -> Float80Bits {
    let bits = Builtin.bitcast_FPIEEE80_Int80(self.value)
    let sixtyFour = Builtin.zextOrBitCast_Int64_Int80((64 as Int64).value)
    return Float80Bits(
      UInt16(Builtin.truncOrBitCast_Int80_Int16(
        Builtin.lshr_Int80(bits, sixtyFour))),
      UInt64(Builtin.truncOrBitCast_Int80_Int64(bits)))
  }

  static func _fromBitPattern(bits: Float80Bits) -> Float80 {
    var result = Builtin.shl_Int80(
      Builtin.zextOrBitCast_Int16_Int80(bits.signAndExponent.value),
      Builtin.zextOrBitCast_Int64_Int80((64 as Int64).value))
    result = Builtin.or_Int80(
      result, Builtin.zextOrBitCast_Int64_Int80(bits.significand.value))
    return Float80(Builtin.bitcast_Int80_FPIEEE80(result))
  }
}

#endif

var FloatingPoint = TestSuite("FloatingPoint")

FloatingPoint.test("Float32/Literals") {
  if true {
    let f: Float32 = 0.0
    expectEqual(0x0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -0.0
    expectEqual(0x8000_0000, f._toBitPattern())
  }

  if true {
    let f: Float32 = 1.0
    expectEqual(0x3f80_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -1.0
    expectEqual(0xbf80_0000, f._toBitPattern())
  }

  if true {
    let f: Float32 = 0.999999
    expectEqual(0x3f7fffef, f._toBitPattern())
  }
  if true {
    let f: Float32 = 0.9999999
    expectEqual(0x3f7ffffe, f._toBitPattern())
  }
  if true {
    let f: Float32 = 0.99999999
    expectEqual(0x3f80_0000, f._toBitPattern())
  }

  // Infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float32 = 1.0e999
    expectEqual(0x7f80_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -1.0e999
    expectEqual(0xff80_0000, f._toBitPattern())
  }

  // Smallest subnormal.
  if true {
    let f: Float32 = 1.4e-45
    expectEqual(0x0000_0001, f._toBitPattern())
  }
  if true {
    let f: Float32 = -1.4e-45
    expectEqual(0x8000_0001, f._toBitPattern())
  }

  // Rounded to zero.
  if true {
    let f: Float32 = 0.7e-45
    expectEqual(0x0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -0.7e-45
    expectEqual(0x8000_0000, f._toBitPattern())
  }

  // Second largest normal.
  if true {
    let f: Float32 = 3.4028232e+38
    expectEqual(0x7f7f_fffe, f._toBitPattern())
  }
  if true {
    let f: Float32 = -3.4028232e+38
    expectEqual(0xff7f_fffe, f._toBitPattern())
  }

  // Largest normal.
  if true {
    let f: Float32 = 3.4028234e+38
    expectEqual(0x7f7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = 340282340000000000000000000000000000000.0
    expectEqual(0x7f7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = 340282340000000000000000000000000000000
    expectEqual(0x7f7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = -3.4028234e+38
    expectEqual(0xff7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = -340282340000000000000000000000000000000.0
    expectEqual(0xff7f_ffff, f._toBitPattern())
  }
  if true {
    let f: Float32 = -340282340000000000000000000000000000000
    expectEqual(0xff7f_ffff, f._toBitPattern())
  }

  // Smallest decimal that is rounded to infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float32 = 3.4028236e+38
    expectEqual(0x7f80_0000, f._toBitPattern())
  }
  if true {
    let f: Float32 = -3.4028236e+38
    expectEqual(0xff80_0000, f._toBitPattern())
  }
}

FloatingPoint.test("Float64/Literals") {
  if true {
    let f: Float64 = 0.0
    expectEqual(0x0000_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -0.0
    expectEqual(0x8000_0000_0000_0000, f._toBitPattern())
  }

  if true {
    let f: Float64 = 1.0
    expectEqual(0x3ff0_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.0
    expectEqual(0xbff0_0000_0000_0000, f._toBitPattern())
  }

  if true {
    let f: Float64 = 0.999999999999999
    expectEqual(0x3fef_ffff_ffff_fff7, f._toBitPattern())
  }
  if true {
    let f: Float64 = 0.9999999999999999
    expectEqual(0x3fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = 0.99999999999999999
    expectEqual(0x3ff0_0000_0000_0000, f._toBitPattern())
  }

  // Infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float64 = 1.0e999
    expectEqual(0x7ff0_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.0e999
    expectEqual(0xfff0_0000_0000_0000, f._toBitPattern())
  }

  // Smallest subnormal.
  if true {
    let f: Float64 = 4.0e-324
    expectEqual(0x0000_0000_0000_0001, f._toBitPattern())
  }
  if true {
    let f: Float64 = -4.0e-324
    expectEqual(0x8000_0000_0000_0001, f._toBitPattern())
  }

  // Rounded to zero.
  if true {
    let f: Float64 = 2.4e-324
    expectEqual(0x0000_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -2.4e-324
    expectEqual(0x8000_0000_0000_0000, f._toBitPattern())
  }

  // Second largest normal.
  if true {
    let f: Float64 = 1.79769313486231551e+308
    expectEqual(0x7fef_ffff_ffff_fffe, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.79769313486231551e+308
    expectEqual(0xffef_ffff_ffff_fffe, f._toBitPattern())
  }

  // Largest normal.
  if true {
    let f: Float64 = 1.7976931348623157e+308
    expectEqual(0x7fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(0x7fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    expectEqual(0x7fef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.7976931348623157e+308
    expectEqual(0xffef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(0xffef_ffff_ffff_ffff, f._toBitPattern())
  }
  if true {
    let f: Float64 = -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    expectEqual(0xffef_ffff_ffff_ffff, f._toBitPattern())
  }

  // Smallest decimal that is rounded to infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float64 = 1.7976931348623159e+308
    expectEqual(0x7ff0_0000_0000_0000, f._toBitPattern())
  }
  if true {
    let f: Float64 = -1.7976931348623159e+308
    expectEqual(0xfff0_0000_0000_0000, f._toBitPattern())
  }
}

#if arch(i386) || arch(x86_64)

FloatingPoint.test("Float80/Literals") {
  if true {
    let f: Float80 = 0.0
    expectEqual(Float80Bits(0x0000, 0x0000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -0.0
    expectEqual(Float80Bits(0x8000, 0x0000_0000_0000_0000), f._toBitPattern())
  }

  if true {
    let f: Float80 = 1.0
    expectEqual(Float80Bits(0x3fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.0
    expectEqual(Float80Bits(0xbfff, 0x8000_0000_0000_0000), f._toBitPattern())
  }

  if true {
    let f: Float80 = 0.999999999999999999
    expectEqual(Float80Bits(0x3ffe, 0xffff_ffff_ffff_ffee), f._toBitPattern())
  }
  if true {
    let f: Float80 = 0.9999999999999999999
    expectEqual(Float80Bits(0x3ffe, 0xffff_ffff_ffff_fffe), f._toBitPattern())
  }
  if true {
    let f: Float80 = 0.99999999999999999995
    expectEqual(Float80Bits(0x3ffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = 0.99999999999999999999
    expectEqual(Float80Bits(0x3fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }

  // Infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float80 = 1.0e19999
    expectEqual(Float80Bits(0x7fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.0e19999
    expectEqual(Float80Bits(0xffff, 0x8000_0000_0000_0000), f._toBitPattern())
  }

  // Smallest subnormal.
  if true {
    // 3.645199531882474602528e-4951
    let f: Float80 = 3.6e-4951
    expectEqual(Float80Bits(0x0000, 0x0000_0000_0000_0001), f._toBitPattern())
  }
  if true {
    let f: Float80 = -3.6e-4951
    expectEqual(Float80Bits(0x8000, 0x0000_0000_0000_0001), f._toBitPattern())
  }

  // Rounded to zero.
  if true {
    let f: Float80 = 1.8e-4951
    expectEqual(Float80Bits(0x0000, 0x0000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.8e-4951
    expectEqual(Float80Bits(0x8000, 0x0000_0000_0000_0000), f._toBitPattern())
  }

  // Largest normal.
  if true {
    let f: Float80 = 1.189731495357231765e+4932
    expectEqual(Float80Bits(0x7ffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = 1189731495357231765000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(Float80Bits(0x7ffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.189731495357231765e+4932
    expectEqual(Float80Bits(0xfffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1189731495357231765000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    expectEqual(Float80Bits(0xfffe, 0xffff_ffff_ffff_ffff), f._toBitPattern())
  }

  // Smallest decimal that is rounded to infinity.
  // FIXME: this should be a compile-time error, not silent overflow.
  if true {
    let f: Float80 = 1.18973149535723176515e+4932
    expectEqual(Float80Bits(0x7fff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
  if true {
    let f: Float80 = -1.18973149535723176515e+4932
    expectEqual(Float80Bits(0xffff, 0x8000_0000_0000_0000), f._toBitPattern())
  }
}

#endif

runAllTests()

