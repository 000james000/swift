// RUN: %target-sil-opt %s -sil-combine -simplify-cfg -verify | FileCheck %s

sil_stage canonical

import Builtin
import Swift

// CHECK-LABEL: sil  @convert_inject_enum_addr_select_enum_addr_into_cond_br : $@thin (@in Int, @inout _Stdout) -> ()
// CHECK: unconditional_checked_cast_addr
// CHECK: inject_enum_addr
// CHECK-NOT: select_enum_addr
// CHECK-NOT: bb1
// CHECK: unchecked_take_enum_data_addr
// CHECK: return
sil  @convert_inject_enum_addr_select_enum_addr_into_cond_br : $@thin (@in Int, @inout _Stdout) -> () {
bb0(%0 : $*Int, %1 : $*_Stdout):
  %2 = alloc_stack $Printable
  %3 = alloc_stack $Optional<Printable>
  %4 = init_enum_data_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  %5 = alloc_stack $Int
  %6 = load %0 : $*Int
  store %6 to %5#1 : $*Int
  unconditional_checked_cast_addr take_always Int in %5#1 : $*Int to Printable in %4 : $*Printable
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  dealloc_stack %5#0 : $*@local_storage Int
  %11 = integer_literal $Builtin.Int1, -1
  %12 = integer_literal $Builtin.Int1, 0
  %13 = select_enum_addr %3#1 : $*Optional<Printable>, case #Optional.Some!enumelt.1: %11, case #Optional.None!enumelt: %12 : $Builtin.Int1
  cond_br %13, bb2, bb1

bb1:
  %15 = tuple ()
  dealloc_stack %3#0 : $*@local_storage Optional<Printable>
  dealloc_stack %2#0 : $*@local_storage Printable
  return %15 : $()

bb2:
  %19 = unchecked_take_enum_data_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  copy_addr [take] %19 to [initialization] %2#1 : $*Printable
  br bb1
}

// Check that a checked_cast_addr_br converting a known type into a protocol type
// is performed at the compile-time if protocol conformances are statically known.
//
// CHECK-LABEL: sil @convert_checked_cast_addr_br_into_unconditional_checked_cast_addr_cond_br : $@thin (@in Int, @inout _Stdout) -> ()
// CHECK: store
// CHECK-NOT: checked_cast_addr_br
// CHECK-NOT: bb1
// CHECK: inject_enum_addr %{{.*}} : $*Optional<Printable>, #Optional.Some!enumelt.1
// CHECK: dealloc_stack
// CHECK: return
sil @convert_checked_cast_addr_br_into_unconditional_checked_cast_addr_cond_br : $@thin (@in Int, @inout _Stdout) -> () {
bb0(%0 : $*Int, %1 : $*_Stdout):
  %2 = alloc_stack $Printable
  %3 = alloc_stack $Optional<Printable>
  %4 = init_enum_data_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  %5 = alloc_stack $Int
  %6 = load %0 : $*Int
  store %6 to %5#1 : $*Int
  checked_cast_addr_br take_always Int in %5#1 : $*Int to Printable in %4 : $*Printable, bb1, bb22

bb1:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  br bb2

bb2:
  dealloc_stack %5#0 : $*@local_storage Int
  dealloc_stack %3#0 : $*@local_storage Optional<Printable>
  %12 = integer_literal $Builtin.Int1, -1
  %13 = integer_literal $Builtin.Int1, 0
  %26 = tuple ()
  dealloc_stack %2#0 : $*@local_storage Printable
  return %26 : $()

bb22:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.None!enumelt
  br bb2
}


class A {

}

private class B {
}

public class C {
}

// D cannot be extended elsewhere, but C can!
private class D : C {
}

// Check that a checked_cast_addr_br converting a known type into a protocol type
// is performed at the compile-time if protocol conformances are statically known.
// In a negative case, take care that check for internal types are not folded (unless 
// a whole module optimization is used), because an extension implementing a conformance
// could be defined elsewhere.
//
// CHECK-LABEL: sil @convert_checked_cast_addr_br_with_internal_type : $@thin (@in A, @inout _Stdout) -> ()
// CHECK: checked_cast_addr_br
// CHECK: inject_enum_addr %{{.*}} : $*Optional<Printable>, #Optional.Some!enumelt.1
// CHECK: dealloc_stack
// CHECK: return
// CHECK: inject_enum_addr %{{.*}} : $*Optional<Printable>, #Optional.None!enumelt
// CHECK: }
sil @convert_checked_cast_addr_br_with_internal_type : $@thin (@in A, @inout _Stdout) -> () {
bb0(%0 : $*A, %1 : $*_Stdout):
  %2 = alloc_stack $Printable
  %3 = alloc_stack $Optional<Printable>
  %4 = init_enum_data_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  %5 = alloc_stack $A
  %6 = load %0 : $*A
  store %6 to %5#1 : $*A
  checked_cast_addr_br take_always A in %5#1 : $*A to Printable in %4 : $*Printable, bb1, bb22

bb1:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  br bb2

bb2:
  dealloc_stack %5#0 : $*@local_storage A
  dealloc_stack %3#0 : $*@local_storage Optional<Printable>
  %12 = integer_literal $Builtin.Int1, -1
  %13 = integer_literal $Builtin.Int1, 0
  %26 = tuple ()
  dealloc_stack %2#0 : $*@local_storage Printable
  return %26 : $()

bb22:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.None!enumelt
  br bb2
}

// Check that a checked_cast_addr_br converting a known type into a protocol type
// is performed at the compile-time if protocol conformances are statically known.
// In a negative case, if the source type is private, it is safe to fold the check,
// because a conformance for this type cannot be defined elsewhere.
//
// CHECK-LABEL: sil @convert_checked_cast_addr_br_with_private_type : $@thin (@in B, @inout _Stdout) -> ()
// CHECK: store
// CHECK-NOT: checked_cast_addr_br
// CHECK-NOT: bb1
// CHECK: inject_enum_addr %{{.*}} : $*Optional<Printable>, #Optional.None!enumelt
// CHECK: dealloc_stack
// CHECK: return
sil @convert_checked_cast_addr_br_with_private_type : $@thin (@in B, @inout _Stdout) -> () {
bb0(%0 : $*B, %1 : $*_Stdout):
  %2 = alloc_stack $Printable
  %3 = alloc_stack $Optional<Printable>
  %4 = init_enum_data_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  %5 = alloc_stack $B
  %6 = load %0 : $*B
  store %6 to %5#1 : $*B
  checked_cast_addr_br take_always B in %5#1 : $*B to Printable in %4 : $*Printable, bb1, bb22

bb1:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  br bb2

bb2:
  dealloc_stack %5#0 : $*@local_storage B
  dealloc_stack %3#0 : $*@local_storage Optional<Printable>
  %12 = integer_literal $Builtin.Int1, -1
  %13 = integer_literal $Builtin.Int1, 0
  %26 = tuple ()
  dealloc_stack %2#0 : $*@local_storage Printable
  return %26 : $()

bb22:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.None!enumelt
  br bb2
}

// Check that a checked_cast_addr_br converting a known type into a protocol type
// is performed at the compile-time if protocol conformances are statically known.
// In a negative case, take care that cast for private types are not folded if one
// of its superclasses could have a conformance extension defined elsewere.
//
// CHECK-LABEL: sil @convert_checked_cast_addr_br_with_non_private_superclass : $@thin (@in D, @inout _Stdout) -> ()
// CHECK: checked_cast_addr_br
// CHECK: inject_enum_addr %{{.*}} : $*Optional<Printable>, #Optional.Some!enumelt.1
// CHECK: dealloc_stack
// CHECK: return
// CHECK: inject_enum_addr %{{.*}} : $*Optional<Printable>, #Optional.None!enumelt
// CHECK: }
sil @convert_checked_cast_addr_br_with_non_private_superclass : $@thin (@in D, @inout _Stdout) -> () {
bb0(%0 : $*D, %1 : $*_Stdout):
  %2 = alloc_stack $Printable
  %3 = alloc_stack $Optional<Printable>
  %4 = init_enum_data_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  %5 = alloc_stack $D
  %6 = load %0 : $*D
  store %6 to %5#1 : $*D
  checked_cast_addr_br take_always D in %5#1 : $*D to Printable in %4 : $*Printable, bb1, bb22

bb1:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.Some!enumelt.1
  br bb2

bb2:
  dealloc_stack %5#0 : $*@local_storage D
  dealloc_stack %3#0 : $*@local_storage Optional<Printable>
  %12 = integer_literal $Builtin.Int1, -1
  %13 = integer_literal $Builtin.Int1, 0
  %26 = tuple ()
  dealloc_stack %2#0 : $*@local_storage Printable
  return %26 : $()

bb22:
  inject_enum_addr %3#1 : $*Optional<Printable>, #Optional.None!enumelt
  br bb2
}
