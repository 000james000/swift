// RUN: %target-sil-opt -enable-sil-verify-all %s -module-name Swift -global-redundant-load-elim -sil-disable-loadstore-dse 

import Builtin

struct A {
  var i : Builtin.Int32
}


// dead store elimination is disabled here.
//
// CHECK-LABEL: sil @post_dominating_dead_store : $@convention(thin) (@inout Builtin.Int32) -> () {
// CHECK: store
// CHECK: store
// CHECK: return
sil @post_dominating_dead_store : $@convention(thin) (@inout Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %1 = integer_literal $Builtin.Int32, 0
  store %1 to %0 : $*Builtin.Int32
  cond_br undef, bb1, bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  store %1 to %0 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// store is forwarded to the load, but the dead store is not got rid of.
//
// CHECK-LABEL: sil @store_forwarding_not_elimination : $@convention(thin) (@inout A, A) -> A {
// CHECK: bb0
// CHECK-NEXT: store
// CHECK-NEXT: store
// CHECK-NEXT: return
sil @store_forwarding_not_elimination : $@convention(thin) (@inout A, A) -> A {
bb0(%0 : $*A, %1 : $A):
  store %1 to %0 : $*A
  // This means that the first store is not dead.
  %4 = load %0 : $*A
  store %1 to %0 : $*A
  return %4 : $A
}

