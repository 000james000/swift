// RUN: %sil-opt %s -sil-combine -verify | FileCheck %s
sil_stage canonical

import Builtin
import Swift

class SomeClass {
  func hash() -> Int
}

//CHECK-LABEL: eliminate_sw_enum_addr
//CHECK-NOT: switch_enum_addr
//CHECK: switch_enum
//CHECK: return
sil @eliminate_sw_enum_addr : $@thin () -> Int {
bb0:
  %0 = alloc_stack $Optional<SomeClass>  // var x // users: %2, %4, %5, %17, %19
  %1 = alloc_ref $SomeClass                       // user: %3
  %2 = init_enum_data_addr %0#1 : $*Optional<SomeClass>, #Optional.Some!enumelt.1 // user: %3
  store %1 to %2 : $*SomeClass                    // id: %3
  inject_enum_addr %0#1 : $*Optional<SomeClass>, #Optional.Some!enumelt.1 // id: %4
  %5 = load %0#1 : $*Optional<SomeClass>          // users: %6, %8, %9, %14
  %6 = retain_value %5 : $Optional<SomeClass>
  %7 = alloc_stack $Optional<SomeClass>           // users: %9, %10, %11, %13
  %8 = retain_value %5 : $Optional<SomeClass>
  store %5 to %7#1 : $*Optional<SomeClass>        // id: %9
  switch_enum_addr %7#1 : $*Optional<SomeClass>, case #Optional.Some!enumelt.1: bb1, case #Optional.None!enumelt: bb2 // id: %10

bb1:                                              // Preds: bb0
  %11 = unchecked_take_enum_data_addr %7#1 : $*Optional<SomeClass>, #Optional.Some!enumelt.1 // user: %12
  %12 = load %11 : $*SomeClass                    // users: %15, %16
  dealloc_stack %7#0 : $*@local_storage Optional<SomeClass> // id: %13
  release_value %5 : $Optional<SomeClass>         // id: %14
  %15 = class_method %12 : $SomeClass, #SomeClass.hash!1 : SomeClass -> () -> Int , $@cc(method) @thin (@owned SomeClass) -> Int // user: %16
  %16 = apply %15(%12) : $@cc(method) @thin (@owned SomeClass) -> Int // user: %20
  %17 = load %0#1 : $*Optional<SomeClass>         // user: %18
  release_value %17 : $Optional<SomeClass>        // id: %18
  dealloc_stack %0#0 : $*@local_storage Optional<SomeClass> // id: %19
  return %16 : $Int                               // id: %20

bb2:                                              // Preds: bb0
  unreachable                                     // id: %23
}

// CHECK-LABEL: sil @eliminate_select_enum_addr
// CHECK-NOT: select_enum_addr
// CHECK: select_enum
// CHECK: return

sil @eliminate_select_enum_addr : $@thin () -> Int {
bb0:
  %0 = alloc_stack $Optional<SomeClass>
  %1 = alloc_ref $SomeClass
  %2 = init_enum_data_addr %0#1 : $*Optional<SomeClass>, #Optional.Some!enumelt.1
  store %1 to %2 : $*SomeClass
  inject_enum_addr %0#1 : $*Optional<SomeClass>, #Optional.Some!enumelt.1
  %5 = load %0#1 : $*Optional<SomeClass>
  %6 = retain_value %5 : $Optional<SomeClass>
  %7 = alloc_stack $Optional<SomeClass>
  %8 = retain_value %5 : $Optional<SomeClass>
  store %5 to %7#1 : $*Optional<SomeClass>
  %t = integer_literal $Builtin.Int1, -1
  %f = integer_literal $Builtin.Int1, 0
  %b = select_enum_addr %7#1 : $*Optional<SomeClass>, case #Optional.Some!enumelt.1: %t, case #Optional.None!enumelt: %f : $Builtin.Int1
  cond_br %b, bb1, bb2

bb1:
  %11 = unchecked_take_enum_data_addr %7#1 : $*Optional<SomeClass>, #Optional.Some!enumelt.1
  %12 = load %11 : $*SomeClass                    // users: %15, %16
  dealloc_stack %7#0 : $*@local_storage Optional<SomeClass>
  release_value %5 : $Optional<SomeClass>
  %15 = class_method %12 : $SomeClass, #SomeClass.hash!1 : SomeClass -> () -> Int , $@cc(method) @thin (@owned SomeClass) -> Int
  %16 = apply %15(%12) : $@cc(method) @thin (@owned SomeClass) -> Int
  %17 = load %0#1 : $*Optional<SomeClass>
  release_value %17 : $Optional<SomeClass>
  dealloc_stack %0#0 : $*@local_storage Optional<SomeClass>
  return %16 : $Int

bb2:
  unreachable
}

enum E {
  case E0
  case E1
  case E2
}

// CHECK-LABEL: sil @canonicalize_select_enum
// CHECK: select_enum {{.*}} case #E.E2!enumelt:
// CHECK: return

sil @canonicalize_select_enum : $@thin (E) -> Int {
bb0(%0 : $E):
  %1 = integer_literal $Builtin.Word, 0
  %2 = integer_literal $Builtin.Word, 1
  %3 = integer_literal $Builtin.Word, 2
  %4 = select_enum %0 : $E, case #E.E0!enumelt: %1, case #E.E1!enumelt: %2, default %3 : $Builtin.Word
  %5 = struct $Int (%4 : $Builtin.Word)
  return %5 : $Int
}

enum G<T> {
  case E0
  case E1(T)
  case E2
}

// CHECK-LABEL: sil @canonicalize_select_enum_addr
// CHECK: select_enum_addr {{.*}} case #G.E2!enumelt:
// CHECK: return

sil @canonicalize_select_enum_addr : $@thin <T> (@in G<T>) -> Int {
bb0(%0 : $*G<T>):
  %2 = integer_literal $Builtin.Word, 0
  %3 = integer_literal $Builtin.Word, 1
  %4 = integer_literal $Builtin.Word, 2
  %5 = select_enum_addr %0 : $*G<T>, case #G.E0!enumelt: %2, case #G.E1!enumelt: %3, default %4 : $Builtin.Word
  %6 = struct $Int (%5 : $Builtin.Word)
  return %6 : $Int
}

// CHECK-LABEL: sil @canonicalize_init_enum_data_addr
// CHECK-NOT: init_enum_data_addr
// CHECK-NOT: inject_enum_addr
// CHECK: enum $Optional<Int>, #Optional.Some!enumelt.1
// CHECK-NOT: inject_enum_addr
// CHECK: return
sil @canonicalize_init_enum_data_addr : $@thin (@inout Int, Builtin.Word) -> Int {
bb0(%0 : $*Int, %1 : $Builtin.Word):
  %s1 = alloc_stack $Optional<Int>
  %e1 = init_enum_data_addr %s1#1 : $*Optional<Int>, #Optional.Some!enumelt.1
  %v = load %0 : $*Int
  store %v to %e1 : $*Int
  %i1 = integer_literal $Builtin.Word, 1
  %i0 = integer_literal $Builtin.Int1, 0
  %a = builtin "sadd_with_overflow_Word"(%1 : $Builtin.Word, %i1 : $Builtin.Word, %i0 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %w = tuple_extract %a : $(Builtin.Word, Builtin.Int1), 0
  %i = struct $Int (%w : $Builtin.Word)
  store %i to %0 : $*Int
  inject_enum_addr %s1#1 : $*Optional<Int>, #Optional.Some!enumelt.1
  dealloc_stack %s1#0 : $*@local_storage Optional<Int>
  return %i : $Int
}
