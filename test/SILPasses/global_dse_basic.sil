// RUN: %target-sil-opt %s -global-dead-store-elim -sil-enable-global-dse -enable-sil-verify-all | FileCheck %s

sil_stage canonical

import Builtin

///////////////////////
// Type Declarations //
///////////////////////

struct Int {
  var value : Builtin.Int64
}

struct Bool {
  var value : Builtin.Int1
}

struct A {
  var i : Builtin.Int32
}

struct AA {
  var a : A
  var i : Builtin.Int32
}

struct S1 {
  var a: Int
  init(a: Int, b: Int)
  init()
}

struct S2 {
  var x: S1
  var a: Int
  var b: Int
  init(x: S1, a: Int, b: Int)
  init()
}

class foo {
  var a: Int
   deinit
  init()
}

sil @foo_user : $@convention(thin) (@guaranteed foo) -> ()
sil @S1_init : $@convention(thin) (@thin S1.Type) -> S1
sil @S2_init : $@convention(thin) (@thin S2.Type) -> S2
sil @escaped_a : $@convention(thin) () -> Builtin.RawPointer


//////////////////////////////////////////////////////////////
// Tests for LoadStoreOpts.cpp from globalloadstoreopts.sil //
//////////////////////////////////////////////////////////////

// CHECK-LABEL: sil @post_dominating_dead_store : $@convention(thin) (@inout Builtin.Int32) -> () {
// CHECK: store
// CHECK-NOT: store
// CHECK: return
sil @post_dominating_dead_store : $@convention(thin) (@inout Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %1 = integer_literal $Builtin.Int32, 0
  store %1 to %0 : $*Builtin.Int32
  cond_br undef, bb1, bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  store %1 to %0 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @post_dominating_dead_store_partial : $@convention(thin) (@inout Builtin.Int32) -> () {
// CHECK: bb0(
// CHECK-NOT: store
// CHECK: bb1:
// CHECK_NOT: store
// CHECK: bb2:
// CHECK: bb3:
// CHECK: store
// CHECK: return
sil @post_dominating_dead_store_partial : $@convention(thin) (@inout Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %1 = integer_literal $Builtin.Int32, 0
  %2 = integer_literal $Builtin.Int32, 1
  %3 = integer_literal $Builtin.Int32, 2
  store %1 to %0 : $*Builtin.Int32
  cond_br undef, bb1, bb2

bb1:
  store %2 to %0 : $*Builtin.Int32
  br bb3

bb2:
  br bb3

bb3:
  store %3 to %0 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// We can't eliminate any stores here.
// CHECK-LABEL: sil @post_dominating_dead_store_fail : $@convention(thin) (@inout Builtin.Int32) -> () {
// CHECK: store
// CHECK: store
// CHECK-NOT: store
// CHECK: return
sil @post_dominating_dead_store_fail : $@convention(thin) (@inout Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %1 = integer_literal $Builtin.Int32, 0
  %2 = integer_literal $Builtin.Int32, 1
  store %1 to %0 : $*Builtin.Int32
  cond_br undef, bb1, bb2

bb1:
  store %2 to %0 : $*Builtin.Int32
  br bb2

bb2:
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test_read_dependence_allows_forwarding : $@convention(thin) (@inout A, A) -> A {
// CHECK: bb0
// CHECK-NEXT: store
// CHECK-NEXT: unchecked_addr_cast
// CHECK-NEXT: unchecked_addr_cast
// CHECK-NEXT: load
// CHECK-NEXT: store
// CHECK-NEXT: return
sil @test_read_dependence_allows_forwarding : $@convention(thin) (@inout A, A) -> A {
bb0(%0 : $*A, %1 : $A):
  store %1 to %0 : $*A
  %2 = unchecked_addr_cast %0 : $*A to $*A
  %3 = unchecked_addr_cast %2 : $*A to $*A
  // This means that the first store is not dead.
  %4 = load %3 : $*A
  store %1 to %0 : $*A
  return %4 : $A
}

// Make sure that we do not eliminate a partially dead store as if it
// was a full dead store.
//
// CHECK-LABEL: sil @partially_dead_store1 : $@convention(thin) (@inout AA, AA, A) -> () {
// CHECK: store
// CHECK: store
sil @partially_dead_store1 : $@convention(thin) (@inout AA, AA, A) -> () {
bb0(%0 : $*AA, %1 : $AA, %2 : $A):
  store %1 to %0 : $*AA
  %3 = unchecked_addr_cast %0 : $*AA to $*A
  store %2 to %3 : $*A
  %9999 = tuple()
  return %9999 : $()
}

// Make sure that we do not eliminate a partially dead store as if it
// was a full dead store.
//
// CHECK-LABEL: sil @partially_dead_store2 : $@convention(thin) (@inout AA, AA, A) -> () {
// CHECK: store
// CHECK: store
sil @partially_dead_store2 : $@convention(thin) (@inout AA, AA, A) -> () {
bb0(%0 : $*AA, %1 : $AA, %2 : $A):
  store %1 to %0 : $*AA
  %3 = struct_element_addr %0 : $*AA, #AA.a
  store %2 to %3 : $*A
  %9999 = tuple()
  return %9999 : $()
}

// Make sure that we properly eliminate the stores in bb1, bb2 from StoreMap.
//
// CHECK-LABEL: sil @store_map_failed_dead_object_elim_invalidation : $@convention(thin) () -> () {
// CHECK: bb1:
// CHECK: store
// CHECK: bb2:
// CHECK: store
// CHECK: bb3:
// CHECK: store
sil @store_map_failed_dead_object_elim_invalidation : $@convention(thin) () -> () {
bb0:
  %0 = integer_literal $Builtin.Int32, 32
  %1 = integer_literal $Builtin.Int32, 64
  %2 = function_ref @escaped_a : $@convention(thin) () -> Builtin.RawPointer
  %3 = apply %2() : $@convention(thin) () -> Builtin.RawPointer
  %4 = pointer_to_address %3 : $Builtin.RawPointer to $*Builtin.Int32
  %5 = apply %2() : $@convention(thin) () -> Builtin.RawPointer
  %6 = pointer_to_address %5 : $Builtin.RawPointer to $*Builtin.Int32
  cond_br undef, bb1, bb2

bb1:
  store %0 to %4 : $*Builtin.Int32
  br bb3

bb2:
  store %1 to %4 : $*Builtin.Int32
  br bb3

bb3:
  store %0 to %6 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}


//////////////////////////////////////////////
// Tests for GlobalDeadStoreElimination.cpp //
//////////////////////////////////////////////

// Remove dead store in same basic block.
//
// CHECK-LABEL: DeadStoreSameBlockSimpleStruct
// CHECK: bb1:
// CHECK-NEXT: store
// CHECK: br
sil hidden @DeadStoreSameBlockSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  %11 = integer_literal $Builtin.Int64, 0         // user: %12
  %12 = struct $Int (%11 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  br bb1

bb1:                                              // Preds: bb0
  store %12 to %13 : $*Int                        // id: %14
  store %12 to %13 : $*Int                        // id: %14
  br bb2                                          // id: %15

bb2:                                              // Preds: bb1 bb2
  %25 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %25 : $()                                // id: %27
}

// Remove a dead store in the split block as there are stores in the if-else
// blocks.
//
// CHECK-LABEL: DeadStoreInSplitBlocksSimpleStruct
// CHECK: bb1:
// CHECK-NOT: store
// CHECK: cond_br
sil hidden @DeadStoreInSplitBlocksSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  br bb1

bb1:
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  %26 = integer_literal $Builtin.Int64, 0
  %12 = struct $Int (%26 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %12 to %13 : $*Int                        // id: %14
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  %22 = integer_literal $Builtin.Int64, 0         // user: %12
  %23 = struct $Int (%22 : $Builtin.Int64)        // user: %14
  store %23 to %13 : $*Int                        // id: %14
  br bb4                                          // id: %15

bb3:                                              // Preds: bb0
  %16 = integer_literal $Builtin.Int64, 1         // user: %17
  %17 = struct $Int (%16 : $Builtin.Int64)        // user: %19
  store %17 to %13 : $*Int                        // id: %19
  br bb4                                         // id: %20

bb4:                                              // Preds: bb1 bb2
  %25 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %25 : $()                                // id: %27
}

// Remove dead stores in split and else block as there is a store
// to the same location in the joint block.
//
// CHECK-LABEL: DeadStoreInSplitElseBlockSimpleStruct
// CHECK: bb1:
// CHECK-NOT: store
// CHECK: cond_br
sil hidden @DeadStoreInSplitElseBlockSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  br bb1

bb1:
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  %11 = integer_literal $Builtin.Int64, 0
  %12 = struct $Int (%11 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %12 to %13 : $*Int                        // id: %14
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  br bb4                                          // id: %15

bb3:                                              // Preds: bb0
  %16 = integer_literal $Builtin.Int64, 1         // user: %17
  %17 = struct $Int (%16 : $Builtin.Int64)        // user: %19
  store %17 to %13 : $*Int                        // id: %19
  br bb4                                          // id: %20

bb4:                                              // Preds: bb1 bb2
  %21 = integer_literal $Builtin.Int64, 0         // user: %12
  %22 = struct $Int (%21 : $Builtin.Int64)        // user: %14
  store %22 to %13 : $*Int                        // id: %14
  %25 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %25 : $()                                // id: %27
}

// Remove dead stores in split and else block.
//
// CHECK-LABEL: DeadStoreInElseSplitSimpleStruct
// CHECK: bb1:
// CHECK-NOT: store
// CHECK: cond_br
sil hidden @DeadStoreInElseSplitSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  br bb1

bb1:
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  %11 = integer_literal $Builtin.Int64, 0
  %12 = struct $Int (%11 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %12 to %13 : $*Int                        // id: %14
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  br bb4                                          // id: %15

bb3:                                              // Preds: bb0
  %17 = integer_literal $Builtin.Int64, 1         // user: %17
  %18 = struct $Int (%17 : $Builtin.Int64)        // user: %19
  %19 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %19
  store %18 to %13 : $*Int                        // id: %19
  br bb4                                          // id: %20

bb4:                                              // Preds: bb1 bb2
  %22 = integer_literal $Builtin.Int64, 0         // user: %12
  %23 = struct $Int (%22 : $Builtin.Int64)        // user: %14
  %24 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %23 to %13 : $*Int                        // id: %14
  %26 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %26 : $()                                // id: %27
}

// Remove dead stores else block, but not split block as its only partially dead.
//
// CHECK-LABEL: DeadStoreInElseNotSplitSimpleStruct
// CHECK: bb1:
// CHECK-NEXT: [[RET0:%.+]] = integer_literal $Builtin.Int64
// CHECK-NEXT: [[RET1:%.+]] = struct $Int
// CHECK-NEXT: [[RET2:%.+]] = struct_element_addr
// CHECK-NEXT: store [[RET1:%.+]] to [[RET0:%.+]]
sil hidden @DeadStoreInElseNotSplitSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  br bb1

bb1:
  %11 = integer_literal $Builtin.Int64, 0
  %12 = struct $Int (%11 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %12 to %13 : $*Int                        // id: %14
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  %33 = load %13 : $*Int
  br bb4                                          // id: %15

bb3:                                              // Preds: bb0
  %17 = integer_literal $Builtin.Int64, 1         // user: %17
  %18 = struct $Int (%17 : $Builtin.Int64)        // user: %19
  %19 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %19
  store %18 to %13 : $*Int                        // id: %19
  br bb4                                          // id: %20

bb4:                                              // Preds: bb1 bb2
  %22 = integer_literal $Builtin.Int64, 0         // user: %12
  %23 = struct $Int (%22 : $Builtin.Int64)        // user: %14
  %24 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %23 to %13 : $*Int                        // id: %14
  %26 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %26 : $()                                // id: %27
}


// Store in bb2 is still alive as post-order does not iterate over blocks
// unreachable from the entry.
//
// Remove the store in bb1 though.
//
// CHECK-LABEL: DeadStoreInUnreachablePredecessorSimpleStruct
// CHECK: bb1
// CHECK-NOT: store
// CHECK: br
sil hidden @DeadStoreInUnreachablePredecessorSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  br bb1

bb1:
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  %26 = integer_literal $Builtin.Int64, 0
  %12 = struct $Int (%26 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %12 to %13 : $*Int                        // id: %14
  br bb3

bb2:                                              // Preds: bb0
  %22 = integer_literal $Builtin.Int64, 0         // user: %12
  %23 = struct $Int (%22 : $Builtin.Int64)        // user: %14
  %24 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  store %23 to %24 : $*Int                        // id: %14
  br bb3                                          // id: %15

bb3:                                              // Preds: bb0
  %16 = integer_literal $Builtin.Int64, 1         // user: %17
  %17 = struct $Int (%16 : $Builtin.Int64)        // user: %19
  store %17 to %13 : $*Int                        // id: %19
  br bb4                                         // id: %20

bb4:                                              // Preds: bb1 bb2
  %25 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %25 : $()                                // id: %27
}


// CHECK-LABEL: DeadStoreInIfElseBlockComplexStruct
// CHECK: bb1:
// CHECK-NOT: store
// CHECK: br
// CHECK: bb2:
// CHECK-NOT: store
// CHECK: br
sil hidden @DeadStoreInIfElseBlockComplexStruct : $@convention(thin) (Bool) -> () {
bb0(%0 : $Bool):
  %1 = alloc_stack $S2  // var x                  // users: %6, %11, %17, %23, %27
  %3 = function_ref @S2_init : $@convention(thin) (@thin S2.Type) -> S2 // user: %5
  %4 = metatype $@thin S2.Type                    // user: %5
  %5 = apply %3(%4) : $@convention(thin) (@thin S2.Type) -> S2 // user: %6
  store %5 to %1#1 : $*S2                         // id: %6
  %7 = struct_extract %0 : $Bool, #Bool.value     // user: %8
  %11 = struct_element_addr %1#1 : $*S2, #S2.x    // user: %12
  %12 = struct_element_addr %11 : $*S1, #S1.a     // user: %13
  cond_br %7, bb1, bb2                            // id: %8

bb1:                                              // Preds: bb0
  %9 = integer_literal $Builtin.Int64, 0          // user: %10
  %10 = struct $Int (%9 : $Builtin.Int64)         // user: %13
  store %10 to %12 : $*Int                        // id: %13
  br bb3                                          // id: %14

bb2:                                              // Preds: bb0
  %15 = integer_literal $Builtin.Int64, 1         // user: %16
  %16 = struct $Int (%15 : $Builtin.Int64)        // user: %19
  store %16 to %12 : $*Int                        // id: %19
  br bb3                                          // id: %20

bb3:                                              // Preds: bb1 bb2
  %21 = integer_literal $Builtin.Int64, 2         // user: %22
  %22 = struct $Int (%21 : $Builtin.Int64)        // user: %25
  store %22 to %12 : $*Int                        // id: %25
  %26 = tuple ()                                  // user: %28
  dealloc_stack %1#0 : $*@local_storage S2        // id: %27
  return %26 : $()                                // id: %28
}

// Remove dead stores in split and else block on a complex struct.
// Test dead store get propagated correctly over empty block, i.e. bb2.
//
// CHECK-LABEL: DeadStoreInSplitElseBlockComplexStruct
// CHECK: bb1:
// CHECK-NOT: store
// CHECK: br
// CHECK: bb3:
// CHECK-NOT: store
// CHECK: br
sil hidden @DeadStoreInSplitElseBlockComplexStruct : $@convention(thin) (Bool) -> () {
bb0(%0 : $Bool):
  %1 = alloc_stack $S2  // var x                  // users: %6, %11, %17, %23, %27
  // function_ref test.S2.init (test.S2.Type)() -> test.S2
  %3 = function_ref @S2_init : $@convention(thin) (@thin S2.Type) -> S2 // user: %5
  %4 = metatype $@thin S2.Type                    // user: %5
  %5 = apply %3(%4) : $@convention(thin) (@thin S2.Type) -> S2 // user: %6
  store %5 to %1#1 : $*S2                         // id: %6
  br bb1

bb1:
  %9 = integer_literal $Builtin.Int64, 0          // user: %10
  %10 = struct $Int (%9 : $Builtin.Int64)         // user: %13
  %11 = struct_element_addr %1#1 : $*S2, #S2.x    // user: %12
  %12 = struct_element_addr %11 : $*S1, #S1.a     // user: %13
  store %10 to %12 : $*Int                        // id: %13
  %7 = struct_extract %0 : $Bool, #Bool.value     // user: %8
  cond_br %7, bb2, bb3                            // id: %8

bb2:                                              // Preds: bb0
  br bb4                                          // id: %14

bb3:                                              // Preds: bb0
  %15 = integer_literal $Builtin.Int64, 1         // user: %16
  %16 = struct $Int (%15 : $Builtin.Int64)        // user: %19
  store %16 to %12 : $*Int                        // id: %19
  br bb4                                          // id: %20

bb4:                                              // Preds: bb1 bb2
  %21 = integer_literal $Builtin.Int64, 2         // user: %22
  %22 = struct $Int (%21 : $Builtin.Int64)        // user: %25
  store %22 to %12 : $*Int                        // id: %25
  %26 = tuple ()                                  // user: %28
  dealloc_stack %1#0 : $*@local_storage S2        // id: %27
  return %26 : $()                                // id: %28
}

// Remove dead store in 1 loop block, as the store in exit block kills it.
//
// CHECK-LABEL: DeadStoreSingleLoopBlockSimpleStruct
// CHECK: bb2:
// CHECK: store
// CHECK: br
sil hidden @DeadStoreSingleLoopBlockSimpleStruct : $@convention(thin) (Bool, Int) -> () {
bb0(%0 : $Bool, %1 : $Int):
  %2 = alloc_stack $S1  // var x                  // users: %8, %13, %18, %23, %26
  %5 = function_ref @S1_init : $@convention(thin) (@thin S1.Type) -> S1 // user: %7
  %6 = metatype $@thin S1.Type                    // user: %7
  %7 = apply %5(%6) : $@convention(thin) (@thin S1.Type) -> S1 // user: %8
  store %7 to %2#1 : $*S1                         // id: %8
  br bb1

bb1:                                              // Preds: bb0
  %11 = integer_literal $Builtin.Int64, 0         // user: %12
  %12 = struct $Int (%11 : $Builtin.Int64)        // user: %14
  %13 = struct_element_addr %2#1 : $*S1, #S1.a    // user: %14
  %14 = load %13 : $*Int
  br bb2                                          // id: %15

bb2:                                              // Preds: bb0
  %16 = integer_literal $Builtin.Int64, 1         // user: %17
  %17 = struct $Int (%16 : $Builtin.Int64)        // user: %19
  store %17 to %13 : $*Int                        // id: %19
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  cond_br %9, bb1, bb3                            // id: %10

bb3:                                              // Preds: bb1 bb2
  %21 = integer_literal $Builtin.Int64, 2         // user: %22
  %22 = struct $Int (%21 : $Builtin.Int64)        // user: %24
  store %22 to %13 : $*Int                        // id: %24
  %25 = tuple ()                                  // user: %27
  dealloc_stack %2#0 : $*@local_storage S1        // id: %26
  return %25 : $()                                // id: %27
}

// Remove dead store in the tuple data structure.
//
// CHECK-LABEL: DeadStoreInSimpleTuple
// CHECK: bb0:
// CHECK-NEXT: alloc_stack
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct
// CHECK-NEXT: store
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct
// CHECK-NEXT: store
sil hidden @DeadStoreInSimpleTuple : $@convention(thin) () -> Int {
bb0:
  %0 = alloc_stack $(a: Int, b: Int)  // var x    // users: %1, %2, %11, %15, %20
  %1 = tuple_element_addr %0#1 : $*(a: Int, b: Int), 0 // user: %5
  %2 = tuple_element_addr %0#1 : $*(a: Int, b: Int), 1 // user: %8
  %3 = integer_literal $Builtin.Int64, 2          // user: %4
  %4 = struct $Int (%3 : $Builtin.Int64)          // user: %5
  store %4 to %1 : $*Int                          // id: %5
  %6 = integer_literal $Builtin.Int64, 2          // user: %7
  %7 = struct $Int (%6 : $Builtin.Int64)          // user: %8
  store %7 to %2 : $*Int                          // id: %8
  %9 = integer_literal $Builtin.Int64, 10         // user: %10
  %10 = struct $Int (%9 : $Builtin.Int64)         // user: %12
  store %10 to %1 : $*Int                        // id: %12
  %13 = integer_literal $Builtin.Int64, 12        // user: %14
  %14 = struct $Int (%13 : $Builtin.Int64)        // user: %16
  store %14 to %2 : $*Int                        // id: %16
  %17 = integer_literal $Builtin.Int64, 22        // user: %19
  %18 = tuple ()
  %19 = struct $Int (%17 : $Builtin.Int64)        // user: %21
  dealloc_stack %0#0 : $*@local_storage (a: Int, b: Int) // id: %20
  return %19 : $Int                               // id: %21
}

// Remove dead store in split block for simple class.
//
// CHECK-LABEL: DeadStoreInSplitSimpleClass
// CHECK: bb1:
// CHECK-NOT: store
// CHECK: cond_br
sil hidden @DeadStoreInSplitSimpleClass : $@convention(thin) (Bool) -> () {
bb0(%0 : $Bool):
  %1 = alloc_stack $foo                           // users: %8, %36
  %3 = alloc_ref $foo                             // users: %6, %8, %11, %14, %17, %19, %22, %25, %27, %30, %33, %34
  store %3 to %1#1 : $*foo                        // id: %8
  br bb1

bb1:
  %4 = integer_literal $Builtin.Int64, 10         // user: %5
  %5 = struct $Int (%4 : $Builtin.Int64)          // user: %7
  %6 = ref_element_addr %3 : $foo, #foo.a         // user: %7
  store %5 to %6 : $*Int                          // id: %7
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  %12 = integer_literal $Builtin.Int64, 11        // user: %13
  %13 = struct $Int (%12 : $Builtin.Int64)        // user: %15
  store %13 to %6 : $*Int                        // id: %15
  %16 = tuple ()
  br bb4                                          // id: %18

bb3:                                              // Preds: bb0
  %20 = integer_literal $Builtin.Int64, 12        // user: %21
  %21 = struct $Int (%20 : $Builtin.Int64)        // user: %23
  store %21 to %6 : $*Int                        // id: %23
  %24 = tuple ()
  br bb4                                          // id: %26

bb4:                                              // Preds: bb1 bb2
  strong_release %3 : $foo                        // id: %34
  %35 = tuple ()                                  // user: %37
  dealloc_stack %1#0 : $*@local_storage foo       // id: %36
  return %35 : $()                                // id: %37
}

// Can not remove partially dead store in split block for simple class.
//
// CHECK-LABEL: PartialDeadStoreInSplitSimpleClass
// CHECK: bb1:
// CHECK-NEXT: [[RET0:%.+]] = integer_literal $Builtin.Int64, 10
// CHECK-NEXT: [[RET1:%.+]] = struct $Int ([[RET0:%.+]] : $Builtin.Int64)
// CHECK-NEXT: [[RET2:%.+]] = ref_element_addr
// CHECK-NEXT: store [[RET1:%.+]] to [[RET2:%.+]]
sil hidden @PartialDeadStoreInSplitSimpleClass : $@convention(thin) (Bool) -> () {
bb0(%0 : $Bool):
  %1 = alloc_stack $foo                           // users: %8, %36
  %3 = alloc_ref $foo                             // users: %6, %8, %11, %14, %17, %19, %22, %25, %27, %30, %33, %34
  store %3 to %1#1 : $*foo                        // id: %8
  br bb1

bb1:
  %4 = integer_literal $Builtin.Int64, 10         // user: %5
  %5 = struct $Int (%4 : $Builtin.Int64)          // user: %7
  %6 = ref_element_addr %3 : $foo, #foo.a         // user: %7
  store %5 to %6 : $*Int                          // id: %7
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  br bb4                                          // id: %18

bb3:                                              // Preds: bb0
  %20 = integer_literal $Builtin.Int64, 12        // user: %21
  %21 = struct $Int (%20 : $Builtin.Int64)        // user: %23
  store %21 to %6 : $*Int                        // id: %23
  %24 = tuple ()
  br bb4                                          // id: %26

bb4:                                              // Preds: bb1 bb2
  strong_release %3 : $foo                        // id: %34
  %35 = tuple ()                                  // user: %37
  dealloc_stack %1#0 : $*@local_storage foo       // id: %36
  return %35 : $()                                // id: %37
}

// Can not remove partially dead store in split block for simple class.
//
// CHECK-LABEL: PartialDeadStoreInSplitWithFunctionCallSimpleClass
// CHECK: bb1:
// CHECK-NEXT: [[RET0:%.+]] = integer_literal $Builtin.Int64, 10
// CHECK-NEXT: [[RET1:%.+]] = struct $Int ([[RET0:%.+]] : $Builtin.Int64)
// CHECK-NEXT: [[RET2:%.+]] = ref_element_addr
// CHECK-NEXT: store [[RET1:%.+]] to [[RET2:%.+]]
sil hidden @PartialDeadStoreInSplitWithFunctionCallSimpleClass : $@convention(thin) (Bool) -> () {
bb0(%0 : $Bool):
  %1 = alloc_stack $foo                           // users: %8, %36
  %3 = alloc_ref $foo                             // users: %6, %8, %11, %14, %17, %19, %22, %25, %27, %30, %33, %34
  store %3 to %1#1 : $*foo                        // id: %8
  br bb1

bb1:
  %4 = integer_literal $Builtin.Int64, 10         // user: %5
  %5 = struct $Int (%4 : $Builtin.Int64)          // user: %7
  %6 = ref_element_addr %3 : $foo, #foo.a         // user: %7
  store %5 to %6 : $*Int                          // id: %7
  %9 = struct_extract %0 : $Bool, #Bool.value     // user: %10
  cond_br %9, bb2, bb3                            // id: %10

bb2:                                              // Preds: bb0
  %32 = function_ref @foo_user : $@convention(thin) (@guaranteed foo) -> ()// user: %4
  %33 = apply %32(%3) : $@convention(thin) (@guaranteed foo) -> () // users: %6, %15
  %120 = integer_literal $Builtin.Int64, 12        // user: %21
  %121 = struct $Int (%120 : $Builtin.Int64)        // user: %23
  store %121 to %6 : $*Int                        // id: %23
  %124 = tuple ()
  br bb4                                          // id: %18

bb3:                                              // Preds: bb0
  %20 = integer_literal $Builtin.Int64, 12        // user: %21
  %21 = struct $Int (%20 : $Builtin.Int64)        // user: %23
  store %21 to %6 : $*Int                        // id: %23
  %24 = tuple ()
  br bb4                                          // id: %26

bb4:                                              // Preds: bb1 bb2
  strong_release %3 : $foo                        // id: %34
  %35 = tuple ()                                  // user: %37
  dealloc_stack %1#0 : $*@local_storage foo       // id: %36
  return %35 : $()                                // id: %37
}
