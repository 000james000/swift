// RUN: %sil-opt %s -inline -sil-inline-threshold=50 -verify | FileCheck %s

sil_stage canonical

import Builtin
import Swift

/////////////////////
// CallGraph Tests //
/////////////////////

// *NOTE* These tests currently validate whether or not the callgraph
// visits nodes in the correct order since we do not explore inlined
// code for more apply inst to inline. After that point, we will
// probably need to do one of the following:
//
// 1. Introduce a flag to turn off the exploration behavior.
// 2. Introduce some sort of debug output that displays the callgraph
//    traversal order.

// Node -> Node

sil @test1_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

// CHECK-LABEL: sil @test1
// CHECK: bb0([[INPUT:%[0-9]+]] : $Builtin.Int64)
// CHECK: [[MUL_BUILTIN:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: integer_literal $Builtin.Int1, 0 {{.*}}
// CHECK: [[MUL_TUPLE_RESULT:%[0-9]+]] = apply [[MUL_BUILTIN]]([[INPUT]], [[INPUT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[MUL_RESULT:%[0-9]+]] = tuple_extract [[MUL_TUPLE_RESULT]]
// CHECK: return [[MUL_RESULT]]
sil @test1 : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test1_multiply_leaf : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %2 = apply %1 (%0) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  return %2 : $Builtin.Int64
}

//      Node
//     /    \
//    v      v
//  Node -> Node

// CHECK-LABEL: sil @test2_add_leaf

sil @test2_add_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test2_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test2_add_then_multiply : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test2_add_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %2 = apply %1(%0) : $@thin (Builtin.Int64) -> Builtin.Int64
  %3 = function_ref @test2_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %4 = apply %3(%2) : $@thin (Builtin.Int64) -> Builtin.Int64
  return %4 : $Builtin.Int64
}

// CHECK-LABEL: sil @test2 : $@thin (Builtin.Int64) -> Builtin.Int64 {
// bb0([[INPUT:%[0-9]+]] : $Builtin.Int64):
// CHECK: [[UADD_FUN:%[0-9]+]] = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT_TUPLE:%[0-9]+]] = apply [[UADD_FUN]]([[INPUT]], [[INPUT]], {{.*}} : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT:%[0-9]+]] = tuple_extract [[UADD_RESULT_TUPLE]] : $(Builtin.Int64, Builtin.Int1), 0
// CHECK: [[UADD_FUN2:%[0-9]+]] = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT_TUPLE2:%[0-9]+]] = apply [[UADD_FUN2]]([[UADD_RESULT]], [[UADD_RESULT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT2:%[0-9]+]] = tuple_extract [[UADD_RESULT_TUPLE2]]
// CHECK: [[UMUL_FUN:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT_TUPLE:%[0-9]+]] = apply [[UMUL_FUN]]([[UADD_RESULT2]], [[UADD_RESULT2]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT:%[0-9]+]] = tuple_extract [[UMUL_RESULT_TUPLE]]
// CHECK: return [[UMUL_RESULT]] : $Builtin.Int64
sil @test2 : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test2_add_leaf: $@thin (Builtin.Int64) -> (Builtin.Int64)
  %2 = apply %1 (%0) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %3 = function_ref @test2_add_then_multiply : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %4 = apply %3 (%2) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  return %4 : $Builtin.Int64
}

//      Node
//     /    \
//    v      v
//  Node    Node
//    \      /
//     v    v
//      Node

// CHECK-LABEL: sil @test3_add_leaf

sil @test3_add_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test3_sub_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "usub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test3_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test3_add_then_multiply : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test3_add_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %2 = apply %1(%0) : $@thin (Builtin.Int64) -> Builtin.Int64
  %3 = function_ref @test3_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %4 = apply %3(%2) : $@thin (Builtin.Int64) -> Builtin.Int64
  return %4 : $Builtin.Int64
}

sil @test3_sub_then_multiply : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test3_sub_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %2 = apply %1(%0) : $@thin (Builtin.Int64) -> Builtin.Int64
  %3 = function_ref @test3_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %4 = apply %3(%2) : $@thin (Builtin.Int64) -> Builtin.Int64
  return %4 : $Builtin.Int64
}

// CHECK-LABEL: sil @test3 : $@thin (Builtin.Int64) -> Builtin.Int64
// CHECK: bb0([[INPUT:%[0-9]+]] : $Builtin.Int64):
// CHECK: [[USUB_FUN:%[0-9]+]] = builtin_function_ref "usub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[USUB_RESULT_TUPLE:%[0-9]+]] = apply [[USUB_FUN]]([[INPUT]], [[INPUT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[USUB_RESULT:%[0-9]+]] = tuple_extract [[USUB_RESULT_TUPLE]]
// CHECK: [[UMUL_FUN:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT_TUPLE:%[0-9]+]] = apply [[UMUL_FUN]]([[USUB_RESULT]], [[USUB_RESULT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT:%[0-9]+]] = tuple_extract [[UMUL_RESULT_TUPLE]]
// CHECK: [[UADD_FUN:%[0-9]+]] = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT_TUPLE:%[0-9]+]] = apply [[UADD_FUN]]([[UMUL_RESULT]], [[UMUL_RESULT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT:%[0-9]+]] = tuple_extract [[UADD_RESULT_TUPLE]]
// CHECK: [[UMUL_FUN2:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT_TUPLE2:%[0-9]+]] = apply [[UMUL_FUN2]]([[UADD_RESULT]], [[UADD_RESULT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT:%[0-9]+]] = tuple_extract [[UMUL_RESULT_TUPLE2]]
// CHECK: return [[UMUL_RESULT]]
sil @test3 : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test3_sub_then_multiply : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %2 = apply %1 (%0) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %3 = function_ref @test3_add_then_multiply : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %4 = apply %3 (%2) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  return %4 : $Builtin.Int64
}

//      Node
//     /    \
//    v      v
//  Node -> Node
//    \      /
//     v    v
//       Node

// CHECK-LABEL: sil @test4_add_leaf

sil @test4_add_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test4_sub_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "usub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test4_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, 0
  %3 = apply %1(%0, %0, %2) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  return %4: $Builtin.Int64
}

sil @test4_add_then_multiply : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test4_add_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %2 = apply %1(%0) : $@thin (Builtin.Int64) -> Builtin.Int64
  %3 = function_ref @test4_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %4 = apply %3(%2) : $@thin (Builtin.Int64) -> Builtin.Int64
  return %4 : $Builtin.Int64
}

sil @test4_add_then_multiply_then_multiply : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test4_add_then_multiply : $@thin (Builtin.Int64) -> Builtin.Int64
  %2 = apply %1(%0) : $@thin (Builtin.Int64) -> Builtin.Int64
  %3 = function_ref @test4_multiply_leaf : $@thin (Builtin.Int64) -> Builtin.Int64
  %4 = apply %3(%2) : $@thin (Builtin.Int64) -> Builtin.Int64
  return %4 : $Builtin.Int64
}

// CHECK-LABEL: sil @test4 : $@thin (Builtin.Int64) -> Builtin.Int64
// CHECK: bb0([[INPUT:%[0-9]+]] : $Builtin.Int64):
// CHECK: [[UADD_FUN:%[0-9]+]] = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT_TUPLE:%[0-9]+]] = apply [[UADD_FUN]]([[INPUT]], [[INPUT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT:%[0-9]+]] = tuple_extract [[UADD_RESULT_TUPLE]]
// CHECK: [[UMUL_FUN:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT_TUPLE:%[0-9]+]] = apply [[UMUL_FUN]]([[UADD_RESULT]], [[UADD_RESULT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT:%[0-9]+]] = tuple_extract [[UMUL_RESULT_TUPLE]]

// CHECK: [[UADD_FUN2:%[0-9]+]] = builtin_function_ref "uadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT_TUPLE2:%[0-9]+]] = apply [[UADD_FUN2]]([[UMUL_RESULT]], [[UMUL_RESULT]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UADD_RESULT2:%[0-9]+]] = tuple_extract [[UADD_RESULT_TUPLE2]]
// CHECK: [[UMUL_FUN2:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT_TUPLE2:%[0-9]+]] = apply [[UMUL_FUN2]]([[UADD_RESULT2]], [[UADD_RESULT2]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT2:%[0-9]+]] = tuple_extract [[UMUL_RESULT_TUPLE2]]

// CHECK: [[UMUL_FUN3:%[0-9]+]] = builtin_function_ref "umul_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT_TUPLE3:%[0-9]+]] = apply [[UMUL_FUN3]]([[UMUL_RESULT2]], [[UMUL_RESULT2]], {{.*}}) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK: [[UMUL_RESULT3:%[0-9]+]] = tuple_extract [[UMUL_RESULT_TUPLE3]]
// CHECK: return [[UMUL_RESULT3]] : $Builtin.Int64
sil @test4 : $@thin (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test4_add_then_multiply : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %2 = apply %1 (%0) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %3 = function_ref @test4_add_then_multiply_then_multiply : $@thin (Builtin.Int64) -> (Builtin.Int64)
  %4 = apply %3 (%2) : $@thin (Builtin.Int64) -> (Builtin.Int64)
  return %4 : $Builtin.Int64
}

// Circular Inline.

// CHECK-LABEL: sil @test5
// CHECK: bb0([[INPUT:%[0-9]+]] : $Builtin.Int64):
// CHECK: [[FUN:%[0-9]+]] = function_ref @test5 : $@thin (Builtin.Int64) -> Builtin.Int64
// CHECK: [[FUN_RESULT:%[0-9]+]] = apply [[FUN]]([[INPUT]]) : $@thin (Builtin.Int64) -> Builtin.Int64
// CHECK: return [[FUN_RESULT]] : $Builtin.Int64
sil @test5 : $@thin(Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %1 = function_ref @test5 : $@thin (Builtin.Int64) -> Builtin.Int64
  %2 = apply %1(%0) : $@thin(Builtin.Int64) -> Builtin.Int64
  return %2 : $Builtin.Int64
}

//////////////////////
// Apply Type Tests //
//////////////////////

// CHECK-LABEL: sil @generic_function
sil @generic_function : $@thin <T> (@in T, @in T) -> Builtin.Int8 {
bb0(%0 : $*T, %1 : $*T):
  %2 = integer_literal $Builtin.Int8, 2
  return %2 : $Builtin.Int8
}

// IGNORE-THIS-CHECK-LABEL: sil @ignore_applies_with_substitutions

// We can't deserialize apply_inst with subst lists. When radar://14443304
// is fixed then we should uncomment this test.

// sil @ignore_applies_with_substitutions : $@thin (Builtin.Int64) -> Builtin.Int8 {
// bb0(%0 : $Builtin.Int64):
//   %1 = function_ref @generic_function : $@thin <T> (@in T, @in T) -> Builtin.Int8
//   %2 = apply %1<T = Builtin.Int64>(%0, %0) : $@thin <T> (@in T, @in T) -> Builtin.Int8
//   return %2 : $Builtin.Int8
// }

// CHECK-LABEL: sil @trivial_fun

sil @trivial_fun : $@thin () -> (Builtin.Int64) {
  %0 = integer_literal $Builtin.Int64, 32
  return %0 : $Builtin.Int64
}

// We can inline function_refs with witness_method calling convention.
sil @trivial_witness_method : $@cc(witness_method) @thin (@inout Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $*Builtin.Int64):
  %1 = load %0 : $*Builtin.Int64
  return %1 : $Builtin.Int64
}

// CHECK-LABEL: sil @trivial_witness_method_caller : $@thin () -> ()
// CHECK-NOT: apply
// CHECK: return
sil @trivial_witness_method_caller : $@thin () -> () {
  %0 = alloc_stack $Builtin.Int64
  %1 = integer_literal $Builtin.Int64, 0
  store %1 to %0#1 : $*Builtin.Int64
  %2 = function_ref @trivial_witness_method : $@cc(witness_method) @thin (@inout Builtin.Int64) -> Builtin.Int64
  apply %2 (%0#1) : $@cc(witness_method) @thin (@inout Builtin.Int64) -> Builtin.Int64
  dealloc_stack %0#0 : $*@local_storage Builtin.Int64
  %3 = tuple()
  return %3 : $()
}

// We can inline function_refs with c calling convention.
sil @trivial_c : $@cc(cdecl) @thin (@inout Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $*Builtin.Int64):
  %1 = load %0 : $*Builtin.Int64
  return %1 : $Builtin.Int64
}

// CHECK-LABEL: sil @trivial_c_caller : $@thin () -> ()
// CHECK-NOT: apply
// CHECK: return
sil @trivial_c_caller : $@thin () -> () {
  %0 = alloc_stack $Builtin.Int64
  %1 = integer_literal $Builtin.Int64, 0
  store %1 to %0#1 : $*Builtin.Int64
  %2 = function_ref @trivial_c : $@cc(cdecl) @thin (@inout Builtin.Int64) -> Builtin.Int64
  apply %2 (%0#1) : $@cc(cdecl) @thin (@inout Builtin.Int64) -> Builtin.Int64
  dealloc_stack %0#0 : $*@local_storage Builtin.Int64
  %3 = tuple()
  return %3 : $()
}

// We can inline function_refs with objc_method calling convention.
//
// ObjC calls are unable to be devirtualized since at runtime the call
// could change. But there is no reason in principal why we could not
// (if there existed something like sealed classes in objc perhaps?),
// inline a function_ref to such a call.
sil @trivial_objc : $@cc(objc_method) @thin (@inout Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $*Builtin.Int64):
  %1 = load %0 : $*Builtin.Int64
  return %1 : $Builtin.Int64
}

// CHECK-LABEL: sil @trivial_objc_caller : $@thin () -> ()
// CHECK-NOT: apply
// CHECK: return
sil @trivial_objc_caller : $@thin () -> () {
  %0 = alloc_stack $Builtin.Int64
  %1 = integer_literal $Builtin.Int64, 0
  store %1 to %0#1 : $*Builtin.Int64
  %2 = function_ref @trivial_objc : $@cc(objc_method) @thin (@inout Builtin.Int64) -> Builtin.Int64
  apply %2 (%0#1) : $@cc(objc_method) @thin (@inout Builtin.Int64) -> Builtin.Int64
  dealloc_stack %0#0 : $*@local_storage Builtin.Int64
  %3 = tuple()
  return %3 : $()
}

//////////////////////
// Cost Model Check //
//////////////////////

// Make sure we do not inline if we go over our cost limit.

// This function consists of 132 strong_retains. Note that 132 + 132 =
// 264 which is greater than our inline cost limit.
sil @large_function : $@thin (Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.NativeObject):
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  strong_release %0 : $Builtin.NativeObject
  %1 = tuple()
  return %1 : $()
}

// CHECK-LABEL: sil @small_function_that_calls_large_function_twice
// CHECK: bb0([[INPUT:%[0-9]+]] : $Builtin.NativeObject):
// CHECK: [[FUN:%[0-9]+]] = function_ref @large_function : $@thin (Builtin.NativeObject) -> ()
// CHECK: apply [[FUN]]([[INPUT]])
// CHECK: return
sil @small_function_that_calls_large_function_twice : $@thin (Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.NativeObject):
  %1 = function_ref @large_function : $@thin (Builtin.NativeObject) -> ()
  apply %1(%0) : $@thin (Builtin.NativeObject) -> ()
  apply %1(%0) : $@thin (Builtin.NativeObject) -> ()
  %2 = tuple()
  return %2 : $()
}

//////////
// Misc //
//////////

// Make sure SILCloner does not get into an infinite loop here.
sil @_TFSsoi1xFT3lhsVSs5UWord3rhsS__S_ : $@thin (UWord, UWord) -> UWord {
bb0(%0 : $UWord, %1 : $UWord):
  %2 = builtin_function_ref "xor_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %5
  %3 = struct_extract %0 : $UWord, #UWord.value   // user: %5
  %4 = struct_extract %1 : $UWord, #UWord.value   // user: %5
  %5 = apply %2(%3, %4) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %6
  %6 = struct $UWord (%5 : $Builtin.Word)         // user: %7
  return %6 : $UWord                              // id: %7
}

sil @_TFSsop1tFT1aVSs5UWord_S_ : $@thin (UWord) -> UWord {
bb0(%0 : $UWord):
  // function_ref Swift.^ [infix] (lhs : Swift.UWord, rhs : Swift.UWord) -> Swift.UWord
  %1 = function_ref @_TFSsoi1xFT3lhsVSs5UWord3rhsS__S_ : $@thin (UWord, UWord) -> UWord // user: %6
  // function_ref Swift.~ [prefix] (a : Swift.UWord) -> Swift.UWord
  %2 = function_ref @_TFSsop1tFT1aVSs5UWord_S_ : $@thin (UWord) -> UWord // user: %5
  %3 = integer_literal $Builtin.Word, 0           // user: %4
  %4 = struct $UWord (%3 : $Builtin.Word)         // user: %5
  %5 = apply %2(%4) : $@thin (UWord) -> UWord     // user: %6
  %6 = apply %1(%0, %5) : $@thin (UWord, UWord) -> UWord // user: %7
  return %6 : $UWord                              // id: %7
}

// Make sure that private symbol references do not get inlined into
// transparent functions.
sil private @private_ret_undef : $@thin () -> () {
entry:
  return undef : $()
}

sil @uses_private : $@thin () -> () {
entry:
  %f = function_ref @private_ret_undef : $@thin () -> ()
  %z = apply %f() : $@thin () -> ()
  return %z : $()
}

// CHECK-LABEL: sil [transparent] @transparent_uses_uses_private : $@thin () -> () {
// CHECK: [[USES_PRIVATE:%.*]] = function_ref @uses_private
// CHECK: apply [[USES_PRIVATE]]()
sil [transparent] @transparent_uses_uses_private : $@thin () -> () {
entry:
  %f = function_ref @uses_private : $@thin () -> ()
  %z = apply %f() : $@thin () -> ()
  return %z : $()
}

// CHECK-LABEL: sil @calls_self
// CHECK-NEXT: bb0:
// CHECK: function_ref @calls_self
// CHECK-NEXT: apply
// CHECK-NEXT: return
sil @calls_self : $@thin () -> () {
entry:
  %f = function_ref @calls_self : $@thin () -> ()
  %z = apply %f() : $@thin () -> ()
  return %z : $()
}

// Visiblity Tests

sil_global private @private_global : $Builtin.Word
sil private @private_function : $@thin () -> () {
  %0 = integer_literal $Builtin.Int32, 0
  %1 = tuple()
  return %1 : $()
}
sil @references_private_global : $@thin () -> () {
  %0 = sil_global_addr @private_global : $*Builtin.Word
  %1 = tuple()
  return %1 : $()
}
sil @references_private_function : $@thin () -> () {
  %0 = function_ref @private_function : $@thin () -> ()
  %1 = tuple()
  return %1 : $()
}

sil_global shared @shared_global : $Builtin.Word
sil shared @shared_function : $@thin () -> () {
  %0 = integer_literal $Builtin.Int32, 1
  %1 = tuple()
  return %1 : $()
}
sil @references_shared_global : $@thin () -> () {
  %0 = sil_global_addr @shared_global : $*Builtin.Word
  %1 = tuple()
  return %1 : $()
}
sil @references_shared_function : $@thin () -> () {
  %0 = function_ref @shared_function : $@thin () -> ()
  %1 = tuple()
  return %1 : $()
}

sil_global hidden @hidden_global : $Builtin.Word
sil hidden @hidden_function : $@thin () -> () {
  %0 = integer_literal $Builtin.Int32, 2
  %1 = tuple()
  return %1 : $()
}
sil @references_hidden_global : $@thin () -> () {
  %0 = sil_global_addr @hidden_global : $*Builtin.Word
  %1 = tuple()
  return %1 : $()
}
sil @references_hidden_function : $@thin () -> () {
  %0 = function_ref @hidden_function : $@thin () -> ()
  %1 = tuple()
  return %1 : $()
}

sil_global @public_global : $Builtin.Word
sil @public_function : $@thin () -> () {
  %0 = integer_literal $Builtin.Int32, 4
  %1 = tuple()
  return %1 : $()
}

sil @references_public_global : $@thin () -> () {
  %0 = sil_global_addr @public_global : $*Builtin.Word
  %1 = tuple()
  return %1 : $()
}
sil @references_public_function : $@thin () -> () {
  %0 = function_ref @public_function : $@thin () -> ()
  %1 = tuple()
  return %1 : $()
}

// CHECK-LABEL: sil private @private_function_test : $@thin () -> () {
// CHECK: function_ref @public_function
// CHECK: function_ref @shared_function
// CHECK: function_ref @hidden_function
// CHECK: function_ref @private_function
// CHECK: sil_global_addr @public_global
// CHECK: sil_global_addr @shared_global
// CHECK: sil_global_addr @hidden_global
// CHECK: sil_global_addr @private_global
sil private @private_function_test : $@thin () -> () {
  %0 = function_ref @references_public_function : $@thin () -> ()
  %1 = function_ref @references_shared_function : $@thin () -> ()
  %2 = function_ref @references_hidden_function : $@thin () -> ()
  %3 = function_ref @references_private_function : $@thin () -> ()
  %4 = function_ref @references_public_global : $@thin () -> ()
  %5 = function_ref @references_shared_global : $@thin () -> ()
  %6 = function_ref @references_hidden_global : $@thin () -> ()
  %7 = function_ref @references_private_global : $@thin () -> ()
  apply %0() : $@thin () -> ()
  apply %1() : $@thin () -> ()
  apply %2() : $@thin () -> ()
  apply %3() : $@thin () -> ()
  apply %4() : $@thin () -> ()
  apply %5() : $@thin () -> ()
  apply %6() : $@thin () -> ()
  apply %7() : $@thin () -> ()
  %8 = tuple()
  return %8 : $()
}

// CHECK-LABEL: sil shared @shared_function_test : $@thin () -> () {
// CHECK: function_ref @public_function
// CHECK: function_ref @shared_function
// CHECK-NOT: function_ref @hidden_function
// CHECK-NOT: function_ref @private_function
// CHECK: sil_global_addr @public_global
// CHECK: sil_global_addr @shared_global
// CHECK-NOT: sil_global_addr @hidden_global
// CHECK-NOT: sil_global_addr @private_global
sil shared @shared_function_test : $@thin () -> () {
  %0 = function_ref @references_public_function : $@thin () -> ()
  %1 = function_ref @references_shared_function : $@thin () -> ()
  %2 = function_ref @references_hidden_function : $@thin () -> ()
  %3 = function_ref @references_private_function : $@thin () -> ()
  %4 = function_ref @references_public_global : $@thin () -> ()
  %5 = function_ref @references_shared_global : $@thin () -> ()
  %6 = function_ref @references_hidden_global : $@thin () -> ()
  %7 = function_ref @references_private_global : $@thin () -> ()
  apply %0() : $@thin () -> ()
  apply %1() : $@thin () -> ()
  apply %2() : $@thin () -> ()
  apply %3() : $@thin () -> ()
  apply %4() : $@thin () -> ()
  apply %5() : $@thin () -> ()
  apply %6() : $@thin () -> ()
  apply %7() : $@thin () -> ()
  %8 = tuple()
  return %8 : $()
}

// CHECK-LABEL: sil hidden @hidden_function_test : $@thin () -> () {
// CHECK: function_ref @public_function
// CHECK: function_ref @shared_function
// CHECK: function_ref @hidden_function
// CHECK-NOT: function_ref @private_function
// CHECK: sil_global_addr @public_global
// CHECK: sil_global_addr @shared_global
// CHECK: sil_global_addr @hidden_global
// CHECK-NOT: sil_global_addr @private_global
sil hidden @hidden_function_test : $@thin () -> () {
  %0 = function_ref @references_public_function : $@thin () -> ()
  %1 = function_ref @references_shared_function : $@thin () -> ()
  %2 = function_ref @references_hidden_function : $@thin () -> ()
  %3 = function_ref @references_private_function : $@thin () -> ()
  %4 = function_ref @references_public_global : $@thin () -> ()
  %5 = function_ref @references_shared_global : $@thin () -> ()
  %6 = function_ref @references_hidden_global : $@thin () -> ()
  %7 = function_ref @references_private_global : $@thin () -> ()
  apply %0() : $@thin () -> ()
  apply %1() : $@thin () -> ()
  apply %2() : $@thin () -> ()
  apply %3() : $@thin () -> ()
  apply %4() : $@thin () -> ()
  apply %5() : $@thin () -> ()
  apply %6() : $@thin () -> ()
  apply %7() : $@thin () -> ()
  %8 = tuple()
  return %8 : $()
}

// CHECK-LABEL: sil @public_function_test : $@thin () -> () {
// CHECK: function_ref @public_function
// CHECK: function_ref @shared_function
// CHECK-NOT: function_ref @hidden_function
// CHECK-NOT: function_ref @private_function
// CHECK: sil_global_addr @public_global
// CHECK: sil_global_addr @shared_global
// CHECK-NOT: sil_global_addr @hidden_global
// CHECK-NOT: sil_global_addr @private_global
sil @public_function_test : $@thin () -> () {
  %0 = function_ref @references_public_function : $@thin () -> ()
  %1 = function_ref @references_shared_function : $@thin () -> ()
  %2 = function_ref @references_hidden_function : $@thin () -> ()
  %3 = function_ref @references_private_function : $@thin () -> ()
  %4 = function_ref @references_public_global : $@thin () -> ()
  %5 = function_ref @references_shared_global : $@thin () -> ()
  %6 = function_ref @references_hidden_global : $@thin () -> ()
  %7 = function_ref @references_private_global : $@thin () -> ()
  apply %0() : $@thin () -> ()
  apply %1() : $@thin () -> ()
  apply %2() : $@thin () -> ()
  apply %3() : $@thin () -> ()
  apply %4() : $@thin () -> ()
  apply %5() : $@thin () -> ()
  apply %6() : $@thin () -> ()
  apply %7() : $@thin () -> ()
  %8 = tuple()
  return %8 : $()
}

// CHECK-LABEL: sil hidden_external @hidden_external_function_test : $@thin () -> () {
// CHECK: function_ref @public_function
// CHECK: function_ref @shared_function
// CHECK: function_ref @hidden_function
// CHECK-NOT: function_ref @private_function
// CHECK: sil_global_addr @public_global
// CHECK: sil_global_addr @shared_global
// CHECK: sil_global_addr @hidden_global
// CHECK-NOT: sil_global_addr @private_global
sil hidden_external @hidden_external_function_test : $@thin () -> () {
  %0 = function_ref @references_public_function : $@thin () -> ()
  %1 = function_ref @references_shared_function : $@thin () -> ()
  %2 = function_ref @references_hidden_function : $@thin () -> ()
  %3 = function_ref @references_private_function : $@thin () -> ()
  %4 = function_ref @references_public_global : $@thin () -> ()
  %5 = function_ref @references_shared_global : $@thin () -> ()
  %6 = function_ref @references_hidden_global : $@thin () -> ()
  %7 = function_ref @references_private_global : $@thin () -> ()
  apply %0() : $@thin () -> ()
  apply %1() : $@thin () -> ()
  apply %2() : $@thin () -> ()
  apply %3() : $@thin () -> ()
  apply %4() : $@thin () -> ()
  apply %5() : $@thin () -> ()
  apply %6() : $@thin () -> ()
  apply %7() : $@thin () -> ()
  %8 = tuple()
  return %8 : $()
}

// CHECK-LABEL: sil public_external @public_external_function_test : $@thin () -> () {
// CHECK: function_ref @public_function
// CHECK: function_ref @shared_function
// CHECK-NOT: function_ref @hidden_function
// CHECK-NOT: function_ref @private_function
// CHECK: sil_global_addr @public_global
// CHECK: sil_global_addr @shared_global
// CHECK-NOT: sil_global_addr @hidden_global
// CHECK-NOT: sil_global_addr @private_global
sil public_external @public_external_function_test : $@thin () -> () {
  %0 = function_ref @references_public_function : $@thin () -> ()
  %1 = function_ref @references_shared_function : $@thin () -> ()
  %2 = function_ref @references_hidden_function : $@thin () -> ()
  %3 = function_ref @references_private_function : $@thin () -> ()
  %4 = function_ref @references_public_global : $@thin () -> ()
  %5 = function_ref @references_shared_global : $@thin () -> ()
  %6 = function_ref @references_hidden_global : $@thin () -> ()
  %7 = function_ref @references_private_global : $@thin () -> ()
  apply %0() : $@thin () -> ()
  apply %1() : $@thin () -> ()
  apply %2() : $@thin () -> ()
  apply %3() : $@thin () -> ()
  apply %4() : $@thin () -> ()
  apply %5() : $@thin () -> ()
  apply %6() : $@thin () -> ()
  apply %7() : $@thin () -> ()
  %8 = tuple()
  return %8 : $()
}

// CHECK-LABEL: @caller_of_noinline
sil @caller_of_noinline : $@thin () -> () {
bb0:
  // CHECK: function_ref @noinlin_callee
  // CHECK: apply
  %0 = function_ref @noinlin_callee : $@thin () -> Int
  %1 = apply %0() : $@thin () -> Int
  %2 = tuple ()
  return %2 : $()
}
// CHECK-LABEL: [noinline] @noinlin_callee
sil [noinline] @noinlin_callee : $@thin () -> Int {
bb0:
  %0 = function_ref @_TFSi33_convertFromBuiltinIntegerLiteralfMSiFBi2048_Si : $@thin (Builtin.Int2048, @thin Int.Type) -> Int
  %1 = metatype $@thin Int.Type
  %2 = integer_literal $Builtin.Int2048, 0
  %3 = apply [transparent] %0(%2, %1) : $@thin (Builtin.Int2048, @thin Int.Type) -> Int
  return %3 : $Int
}
sil [transparent] @_TFSi33_convertFromBuiltinIntegerLiteralfMSiFBi2048_Si : $@thin (Builtin.Int2048, @thin Int.Type) -> Int

sil @coldcall : $@thin () -> () {
bb0:
  %0 = tuple ()                                   // user: %1
  return %0 : $()                                 // id: %1
}

// Generic call to "branchHint" for use in specialized @slowPath
sil public_external [transparent] [semantics "branchhint"] @_TFSs11_branchHintUSs11BooleanType__FTQ_Sb_Sb : $@thin <C where C : BooleanType> (@in C, Bool) -> Bool {
bb0(%0 : $*C, %1 : $Bool):
  %2 = witness_method $C, #BooleanType.getLogicValue!1 : $@cc(witness_method) @thin <τ_0_0 where τ_0_0 : BooleanType> (@inout τ_0_0) -> Bool // user: %4
  %3 = apply %2<C>(%0) : $@cc(witness_method) @thin <τ_0_0 where τ_0_0 : BooleanType> (@inout τ_0_0) -> Bool
  return %3 : $Bool
}

// Specialized call to "slowPath" for use in @coldcall_caller
sil shared [transparent] [semantics "slowpath"] @_TTSSbSbSs11BooleanType___TFSs9_slowPathUSs11BooleanType__FQ_Sb : $@thin (@in Bool) -> Bool {
bb0(%0 : $*Bool):
  %3 = integer_literal $Builtin.Int1, 0
  %4 = struct $Bool (%3 : $Builtin.Int1)
  %5 = function_ref @_TFSs11_branchHintUSs11BooleanType__FTQ_Sb_Sb : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0, Bool) -> Bool
  %6 = apply [transparent] %5<Bool>(%0, %4) : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0, Bool) -> Bool
  return %6 : $Bool
}

// CHECK-LABEL:  @coldcall_caller
// CHECK: slowPath
// CHECK-LABEL: bb1:
// CHECK: function_ref @coldcall
// CHECK: apply
// CHECK-LABEL: bb2:
sil @coldcall_caller : $@thin (Int) -> () {
bb0(%0 : $Int):
  %1 = alloc_stack $Bool                          // users: %7, %9, %11
  %2 = integer_literal $Builtin.Word, 0           // user: %5
  %3 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %5
  %4 = struct_extract %0 : $Int, #Int.value       // user: %5
  %5 = apply %3(%4, %2) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %6
  %6 = struct $Bool (%5 : $Builtin.Int1)          // user: %7
  store %6 to %1#1 : $*Bool                       // id: %7
  %8 = function_ref @_TTSSbSbSs11BooleanType___TFSs9_slowPathUSs11BooleanType__FQ_Sb : $@thin (@in Bool) -> Bool // user: %9
  %9 = apply [transparent] %8(%1#1) : $@thin (@in Bool) -> Bool // user: %10
  %10 = struct_extract %9 : $Bool, #Bool.value    // user: %12
  dealloc_stack %1#0 : $*@local_storage Bool      // id: %11
  cond_br %10, bb1, bb2                           // id: %12

bb1:                                              // Preds: bb0
  %13 = function_ref @coldcall : $@thin () -> () // user: %14
  %14 = apply %13() : $@thin () -> ()
  br bb2                                          // id: %15

bb2:                                              // Preds: bb0 bb1
  %16 = tuple ()                                  // user: %17
  return %16 : $()                                // id: %17
}

sil @slowHelper : $@thin () -> () {
bb0:
  %t = tuple ()
  return %t : $()
}

sil [transparent] [semantics "fastpath"] @fastPathHelper : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0) -> Bool

// fastpath.closedTest0 () -> ()
// From <rdar://problem/17611447> _fastPath kills optimizer
// First test that the inliner is not inlining the slow call.
// Then teset that same calls is not inlined when transparent.
// CHECK-LABEL:  @testNoInlineSlow
// CHECK-LABEL: bb0:
// CHECK: function_ref @fastPathHelper
// CHECK-LABEL: bb1:
// CHECK: function_ref @slowHelper
// CHECK-NEXT: apply
// CHECK-LABEL: bb2:
sil @testNoInlineSlow : $@thin () -> () {
bb0:
  %f1 = function_ref @fastPathHelper : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0) -> Bool
  %v9 = alloc_stack $Bool
  %v12 = integer_literal $Builtin.Int1, 0
  %v16 = struct $Bool (%v12 : $Builtin.Int1)
  store %v16 to %v9#1 : $*Bool                      // id: %17
  %v18 = apply [transparent] %f1<Bool>(%v9#1) : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0) -> Bool
  %v19 = struct_extract %v18 : $Bool, #Bool.value
  dealloc_stack %v9#0 : $*@local_storage Bool      // id: %20
  cond_br %v19, bb2, bb1                           // id: %21

bb1:
  %f2 = function_ref @slowHelper : $@thin () -> ()
  %r2 = apply %f2() : $@thin () -> ()
  br bb2

bb2:
  %t3 = tuple ()
  return %t3 : $()
}

// CHECK-LABEL:  @testInlineSlowTransparent
// CHECK-LABEL: bb0:
// CHECK: function_ref @fastPathHelper
// CHECK-LABEL: bb1:
// CHECK: function_ref @slowHelper
// CHECK-NOT: apply
// CHECK-LABEL: bb2:
sil @testInlineSlowTransparent : $@thin () -> () {
bb0:
  %f1 = function_ref @fastPathHelper : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0) -> Bool
  %v9 = alloc_stack $Bool
  %v12 = integer_literal $Builtin.Int1, 0
  %v16 = struct $Bool (%v12 : $Builtin.Int1)
  store %v16 to %v9#1 : $*Bool                      // id: %17
  %v18 = apply [transparent] %f1<Bool>(%v9#1) : $@thin <τ_0_0 where τ_0_0 : BooleanType> (@in τ_0_0) -> Bool
  %v19 = struct_extract %v18 : $Bool, #Bool.value
  dealloc_stack %v9#0 : $*@local_storage Bool      // id: %20
  cond_br %v19, bb2, bb1                           // id: %21

bb1:
  %f2 = function_ref @slowHelper : $@thin () -> ()
  %r2 = apply [transparent] %f2() : $@thin () -> ()
  br bb2

bb2:
  %t3 = tuple ()
  return %t3 : $()
}
