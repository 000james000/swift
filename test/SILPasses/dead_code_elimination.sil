// RUN: %sil-opt %s -dead-code-elimination | FileCheck %s

import Builtin
import swift

sil internal @test1 : $() -> () {
bb0:
  %5 = integer_literal $Builtin.Int1, 1
  %7 = condbranch %5, bb1, bb2
bb1:                                              // Preds: bb0
  %8 = br bb2
bb2:                                              // Preds: bb1 bb0
  %9 = tuple ()                              
  %10 = return %9 : $()
}
// CHECK-LABEL:@test1
// CHECK: bb0:
// CHECK-NEXT:  br bb1
// CHECK: bb1:
// CHECK-NEXT:  br bb2
// CHECK: bb2:
// CHECK-NEXT:  tuple ()
// CHECK-NEXT:  return
// CHECK-NEXT: }

sil @test2 : $[thin] () -> () {
bb0:
  %11 = integer_literal $Builtin.Int1, 0
  %13 = condbranch %11, bb1, bb2
bb1:                                              // Preds: bb0
  %22 = br bb2
bb2:                                              // Preds: bb1 bb0
  %32 = tuple ()                                
  %33 = return %32 : $()
}
// CHECK-LABEL:sil @test2
// CHECK: bb0:
// CHECK-NEXT:  br bb1
// CHECK:bb1:                                              // Preds: bb0
// CHECK-NEXT:  tuple ()
// CHECK-NEXT:  return
// CHECK-NEXT: }

// func loopWithFalse() -> () {
//  while false {
//    if (false)
//      return
//  }
//}
sil @loopWithFalse : $[thin] () -> () {
bb0:
  %6 = br bb1

bb1:                                              // Preds: bb4 bb0
  %12 = integer_literal $Builtin.Int1, 0
  %14 = condbranch %12, bb2, bb5

bb2:                                              // Preds: bb1
  %20 = integer_literal $Builtin.Int1, 0
  %22 = condbranch %20, bb3, bb4

bb3:                                              // Preds: bb2
  br bb6
bb4:                                              // Preds: bb2
  %26 = br bb1

bb5:                                              // Preds: bb1
  br bb6

bb6:
  %28 = tuple () 
  %29 = return %28 : $()
}
// CHECK-LABEL: sil @loopWithFalse
// CHECK: bb0:
// CHECK-NEXT:  br bb1
// CHECK:bb1:                                              // Preds: bb0
// CHECK-NEXT:  br bb2
// CHECK:bb2:                                              // Preds: bb1
// CHECK:br bb3
// CHECK:bb3:                         
// CHECK-NEXT:  tuple ()                          
// CHECK-NEXT:  return
// CHECK-NEXT:}


// func InfLoop() -> () {
//  while true {
//    if (false)
//      return
//  }
//}
sil @InfLoop : $[thin] () -> () {
bb0:
  %6 = br bb1

bb1:                                              // Preds: bb4 bb0
  %12 = integer_literal $Builtin.Int1, 1
  %14 = condbranch %12, bb2, bb5

bb2:                                              // Preds: bb1
  %20 = integer_literal $Builtin.Int1, 0
  %22 = condbranch %20, bb3, bb4

bb3:                                              // Preds: bb2
  br bb6

bb4:                                              // Preds: bb2
  %26 = br bb1

bb5:                                              // Preds: bb1
  br bb6

bb6:
  %28 = tuple () 
  %29 = return %28 : $()
}
// CHECK-LABEL:sil @InfLoop
// CHECK: bb0:
// CHECK-NEXT:  br bb1
// CHECK:bb1:                                              // Preds: bb3 bb0
// CHECK-NEXT:  br bb2
// CHECK:bb2:                                              // Preds: bb1
// CHECK-NEXT:  br bb3
// CHECK:bb3:                                              // Preds: bb2
// CHECK-NEXT:  br bb1
// CHECK-NEXT: }

class B { }
class E : B { }

sil @exit : $[thin, noreturn] () -> () {
bb0:
  %1 = tuple ()
  return %1 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadInstructions
sil @removeTriviallyDeadInstructions : $[thin] (b : B) -> () {
bb0(%0 : $B):
  %1 = alloc_box $B                           
  %2 = store %0 to %1#1 : $*B                 // CHECK: store
  %3 = load %1#1 : $*B                        
  %4 = retain %3 : $B                         // CHECK: retain
  %5 = downcast conditional %3 : $B to $E     // CHECK-NOT: downcast
  %7 = release %3 : $B                        // CHECK: release
  %8 = release %1#0 : $Builtin.ObjectPointer  // CHECK-NEXT: release
  %9 = function_ref @exit : $[thin, noreturn] () -> () // ret.exit : () -> ()
  %10 = apply %9() : $[thin, noreturn] () -> ()
  %6 = is_nonnull %5 : $E                     // CHECK-NOT: is_nonnull
  %11 = tuple()
  %12 = return %11 : $()                      
}                                             

// CHECK-LABEL: sil @removeTriviallyDeadButUsedByUnreachableBlock
sil @removeTriviallyDeadButUsedByUnreachableBlock : $[thin] (b : B) -> () {
bb0(%0 : $B):
  %5 = downcast conditional %0 : $B to $E         // CHECK-NOT: downcast
  %11 = integer_literal $Builtin.Int1, 0          // CHECK-NOT: integer_literal
  %13 = condbranch %11, bb1, bb2                  // CHECK: br
bb1:                                              
  %21 = is_nonnull %5 : $E                        // CHECK-NOT: is_nonnull
  %22 = br bb2
bb2:                                              
  %32 = tuple ()                                
  %33 = return %32 : $()                          // CHECK: return
}                                                 // CHECK: }

// CHECK-LABEL: sil @removeTriviallyDeadCrossBasicBlocks
sil @removeTriviallyDeadCrossBasicBlocks : $[thin] (b : B, m : Builtin.Int1) -> () {
bb0(%0:  $B, %1: $Builtin.Int1):
  %5 = downcast conditional %0 : $B to $E         // CHECK-NOT: downcast
  %13 = condbranch %1, bb1, bb2                   // CHECK: condbranch
bb1:                                              
  %22 = br bb2
bb2:                                              
  %9 = function_ref @exit : $[thin, noreturn] () -> () // ret.exit : () -> ()
  %10 = apply %9() : $[thin, noreturn] () -> ()
  %21 = is_nonnull %5 : $E                        // CHECK-NOT: is_nonnull  
  %32 = tuple ()                                
  %33 = return %32 : $()
}                                                 // CHECK: }

sil @testCondBranchBBArgs : $[thin] (i1 : Int64, i2 : Int64) -> Int64 {
bb0(%0 : $Int64, %1 : $Int64):
  %2 = integer_literal $Builtin.Int1, 0
  condbranch %2, bb1(%0 : $Int64), bb2(%1 : $Int64)
bb1(%3 : $Int64):
  br bb3(%3 : $Int64)
bb2(%4 : $Int64):
  br bb3(%4 : $Int64)
bb3(%5 : $Int64):
  return %5 : $Int64
}
// CHECK-LABEL: sil @testCondBranchBBArgs
// CHECK: bb0
// CHECK-NEXT:  br bb1(%{{[0-9]+}} : $Int64)
// CHECK: bb1(%{{[0-9]+}} : $Int64):                                 
// CHECK-NEXT: br bb2
// CHECK: bb2
// CHECK-NEXT:  return
// CHECK: }

sil @removePredecessorWithBBArgs : $[thin] (i1: Int64, i2 :Int64) -> Int64 {
bb0(%0 : $Int64, %1 : $Int64):
 %2 = integer_literal $Builtin.Int1, 0
 %3 = condbranch %2, bb2(%0 : $Int64), bb3(%1 : $Int64)
bb2(%4 : $Int64): 
 br bb4(%4 : $Int64)
bb3(%5 : $Int64):
  br bb4(%5 : $Int64)
bb4(%6 : $Int64):
  return %6 : $Int64
}
// CHECK-LABEL:sil @removePredecessorWithBBArgs
// CHECK: bb0(%{{[0-9]+}} : $Int64, %{{[0-9]+}} : $Int64):
// CHECK-NEXT:  br bb1(%{{[0-9]+}} : $Int64)
// CHECK:      bb1(%{{[0-9]+}} : $Int64):
// CHECK-NEXT:  br bb2(%{{[0-9]+}} : $Int64)
// CHECK:      bb2(%{{[0-9]+}} : $Int64):
// CHECK-NEXT:  return
// CHECK: }

sil @code_removed_after_a_call_to_noreturn : $[thin] (i : Int64, b : Builtin.Int1) -> () {
bb0(%0 : $Int64, %1 : $Builtin.Int1):
  %6 = function_ref @exit : $[thin, noreturn] () -> () // ret.exit : () -> ()
  %7 = apply %6() : $[thin, noreturn] () -> ()
  condbranch %1, bb1, bb2
bb1:                                              // Preds: bb0
  br bb2
bb2:                                              // Preds: bb1 bb0
  %20 = tuple ()                                  // user: %21
  return %20 : $()
}
// CHECK-LABEL: sil @code_removed_after_a_call_to_noreturn
// CHECK: bb0
// CHECK-NEXT:  exit
// CHECK-NEXT:  function_ref
// CHECK-NEXT:  apply
// CHECK-NEXT:  unreachable
// CHECK: }

sil @dead_use_of_alloc_stack : $[thin] () -> () {
bb0:
  %1 = alloc_stack $((), (), ())
  %2 = tuple_element_addr %1#1 : $*((), (), ()), 0
  dealloc_stack %1#0 : $*[local_storage] ((), (), ())
  %3 = tuple ()
  return %3 : $()
}
// CHECK-LABEL: sil @dead_use_of_alloc_stack
// CHECK: bb
// CHECK: alloc_stack
// CHECK: dealloc_stack
// CHECK: }
