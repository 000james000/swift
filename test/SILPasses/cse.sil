// RUN: %sil-opt %s -cse -verify | FileCheck %s

import Builtin
import swift

//////////////////////
// Simple DCE Tests //
//////////////////////

// CHECK-LABEL: sil @dead_inst_elimination_one_bb
// CHECK-NOT: integer_literal $Builtin.Int64, 24
sil @dead_inst_elimination_one_bb : $@thin () -> () {
  %0 = integer_literal $Builtin.Int64, 24
  %1 = tuple()
  return %1 : $()
}

// CHECK-LABEL: sil @dead_inst_elimination_diamond
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK-NOT: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_diamond : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  %1 = integer_literal $Builtin.Int64, 24
  cond_br %0, bb1, bb2

bb1:
  %2 = integer_literal $Builtin.Int64, 48
  br bb3

bb2:
  %3 = integer_literal $Builtin.Int64, 96
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

sil @random_counter : $@thin () -> Builtin.Int1

// CHECK-LABEL: sil @dead_inst_elimination_loop
// CHECK: bb0
// CHECK-NOT: integer_literal
// CHECK: bb1
// CHECK: function_ref
// CHECK: apply
// CHECK-NOT: integer_literal
// CHECK: bb2
// CHECK-NOT: integer_literal
// CHECK: tuple
// CHECK: return
sil @dead_inst_elimination_loop : $@thin () -> () {
bb0:
  %1 = integer_literal $Builtin.Int64, 24
  br bb1

bb1:
  %2 = function_ref @random_counter : $@thin () -> Builtin.Int1
  %3 = apply %2() : $@thin () -> Builtin.Int1
  %4 = integer_literal $Builtin.Int64, 48
  cond_br %3, bb1, bb2

bb2:
  %5 = integer_literal $Builtin.Int64, 59
  %6 = tuple()
  return %6 : $()
}

// For now until the proper unreachable pruning code is committed for
// SILCombine, we should not dce dead instructions in unreachable code.

// CHECK-LABEL: sil @dead_inst_elimination_ignore_unreachable
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_ignore_unreachable : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Int64, 24
  br bb2

bb1:
  %1 = integer_literal $Builtin.Int64, 48
  br bb2

bb2:
  %2 = tuple()
  return %2 : $()
}

//////////////////////////////////////////////////////////
// Other DCE Tests taken from dead_code_elimination.sil //
//////////////////////////////////////////////////////////

class B { }
class E : B { }

sil @exit : $@thin @noreturn () -> () {
bb0:
  %1 = tuple ()
  return %1 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadInstructions
// CHECK: store
// CHECK: strong_retain
// CHECK: strong_release
// CHECK-NEXT: strong_release
// CHECK-NOT: object_pointer_to_ref
sil @removeTriviallyDeadInstructions : $@thin (@owned B) -> () {
bb0(%0 : $B):
  %1 = alloc_box $B
  %2 = store %0 to %1#1 : $*B
  %3 = load %1#1 : $*B
  %4 = strong_retain %3 : $B
  %5 = ref_to_object_pointer %3 : $B to $Builtin.ObjectPointer
  %7 = strong_release %3 : $B
  %8 = strong_release %1#0 : $Builtin.ObjectPointer
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %6 = object_pointer_to_ref %5 : $Builtin.ObjectPointer to $B
  %11 = tuple()
  %12 = return %11 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadCrossBasicBlocks
// CHECK: cond_br
// CHECK-NOT: object_pointer_to_ref
// CHECK: }
sil @removeTriviallyDeadCrossBasicBlocks : $@thin (@owned B, Builtin.Int1) -> () {
bb0(%0: $B, %1: $Builtin.Int1):
  %5 = ref_to_object_pointer %0 : $B to $Builtin.ObjectPointer
  %13 = cond_br %1, bb1, bb2
bb1:
  %22 = br bb2
bb2:
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %21 = object_pointer_to_ref %5 : $Builtin.ObjectPointer to $B
  %32 = tuple ()
  %33 = return %32 : $()
}

// CHECK-LABEL: sil @dead_use_of_alloc_stack
// CHECK: bb
// CHECK: alloc_stack
// CHECK: dealloc_stack
// CHECK: }
sil @dead_use_of_alloc_stack : $@thin () -> () {
bb0:
  %1 = alloc_stack $((), (), ())
  %2 = tuple_element_addr %1#1 : $*((), (), ()), 0
  dealloc_stack %1#0 : $*@local_storage ((), (), ())
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil @tuple_extract
// CHECK: bb
// CHECK-NEXT: return %0
sil @tuple_extract : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = tuple (%0 : $Int64, %0 : $Int64)
  return %0 : $Int64
}

// CHECK-LABEL: sil @fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NOT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: integer_literal
// CHECK-NEXT: br
sil @fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, -1
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, 0
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

// CHECK-LABEL: sil @do_not_fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
sil @do_not_fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, 0
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, -1
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

enum BoolLike { case true, false }

// CHECK-LABEL: sil @fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
sil @fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @do_not_fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
sil @do_not_fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

///////////////
// CSE Tests //
///////////////

// Test simple instruction value numbering and usage of an available value in a single bb.
//
// Specifically we make sure that we only replace Int8 literals with
// Int8 literals with the same value. Anything else is outside of scope for cse.
//
// CHECK-LABEL: sil @test0
// CHECK: [[TARGET:%[0-9]+]] = integer_literal $Builtin.Int8, 8
// CHECK-NEXT: [[DECOY1:%[0-9]+]] = integer_literal $Builtin.Int16, 8
// CHECK-NEXT: [[DECOY2:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT: tuple ([[TARGET]] : $Builtin.Int8, [[TARGET]] : $Builtin.Int8, [[DECOY1]] : $Builtin.Int16, [[DECOY2]] : $Builtin.Int8)
// CHECK-NEXT: return
sil @test0 : $@thin () -> (Builtin.Int8, Builtin.Int8, Builtin.Int16,
                           Builtin.Int8) {
    %0 = integer_literal $Builtin.Int8, 8
    %1 = integer_literal $Builtin.Int8, 8
    %2 = integer_literal $Builtin.Int16, 8
    %3 = integer_literal $Builtin.Int8, 1
    %4 = tuple(%0 : $Builtin.Int8, %1 : $Builtin.Int8, %2 : $Builtin.Int16, %3 : $Builtin.Int8)
    return %4 : $(Builtin.Int8, Builtin.Int8, Builtin.Int16, Builtin.Int8)
}

// Make sure that we can replace cse values in different basic blocks
// assuming nothing has changed.

// CHECK-LABEL: sil @test1
// CHECK: bb0
// CHECK-NEXT: [[TARGET:%[0-9]+]] = integer_literal $Builtin.Int8, 8
// CHECK-NEXT: cond_br undef, bb1, bb2
// CHECK: bb1
// CHECK-NEXT: br bb3([[TARGET]] : $Builtin.Int8)
// CHECK: bb2
// CHECK-NEXT: [[DECOY:%[0-9]+]] = integer_literal $Builtin.Int8, 16
// CHECK-NEXT: br bb3([[DECOY]] : $Builtin.Int8)
// CHECK: bb3([[PHI:%[0-9]+]] : $Builtin.Int8):
// CHECK-NEXT: tuple ([[TARGET]] : $Builtin.Int8, [[PHI]] : $Builtin.Int8, [[TARGET]] : $Builtin.Int8)
// CHECK-NEXT: return
sil @test1 : $@thin () -> (Builtin.Int8, Builtin.Int8, Builtin.Int8) {
bb0:
    %0 = integer_literal $Builtin.Int8, 8
    %1 = integer_literal $Builtin.Int8, 8
    cond_br undef, bb1, bb2

bb1:
    %2 = integer_literal $Builtin.Int8, 8
    br bb3(%2 : $Builtin.Int8)

bb2:
    %3 = integer_literal $Builtin.Int8, 16
    br bb3(%3 : $Builtin.Int8)

bb3(%4 : $Builtin.Int8):
    %5 = tuple(%0 : $Builtin.Int8, %4 : $Builtin.Int8, %1 : $Builtin.Int8)
    return %5 : $(Builtin.Int8, Builtin.Int8, Builtin.Int8)
}

sil @evil : $@thin (@inout Builtin.Int8) -> ()

// CHECK-LABEL: functionrefinst
// CHECK: bb0
// CHECK: function_ref @evil : $@thin (@inout Builtin.Int8) -> ()
// CHECK-NOT: function_ref @evil : $@thin (@inout Builtin.Int8) -> ()
sil @functionrefinst : $@thin (@inout Builtin.Int8) -> () {
bb0(%0 : $*Builtin.Int8):
  %1 = function_ref @evil : $@thin (@inout Builtin.Int8) -> ()
  apply %1(%0) : $@thin (@inout Builtin.Int8) -> ()
  %2 = function_ref @evil : $@thin (@inout Builtin.Int8) -> ()
  apply %2(%0) : $@thin (@inout Builtin.Int8) -> ()
  %3 = tuple()
  return %3 : $()
}

// CHECK-LABEL: builtinfunctionrefinst
// CHECK: bb0
// CHECK: builtin_function_ref "ssub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
// CHECK-NOT: builtin_function_ref "ssub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
sil @builtinfunctionrefinst : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int64) {
bb0(%0 : $Builtin.Int64, %1 : $Builtin.Int64, %2 : $Builtin.Int64):
  %3 = integer_literal $Builtin.Int1, 0
  %4 = builtin_function_ref "ssub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %5 = builtin_function_ref "ssub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %6 = apply %4(%0, %1, %3) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %7 = apply %5(%1, %2, %3) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %8 = tuple_extract %6 : $(Builtin.Int64, Builtin.Int1), 0
  %9 = tuple_extract %7 : $(Builtin.Int64, Builtin.Int1), 0
  %10 = tuple(%8 : $Builtin.Int64, %9 : $Builtin.Int64)
  return %10 : $(Builtin.Int64, Builtin.Int64)
}

var global_target : Builtin.Int64

// CHECK-LABEL: globaladdr_inst
// CHECK: global_addr #global_target
// CHECK-NOT: global_addr

sil @globaladdr_inst : $@thin () -> (Builtin.Int64) {
  %0 = global_addr #global_target : $*Builtin.Int64
  %1 = global_addr #global_target : $*Builtin.Int64
  %2 = load %0 : $*Builtin.Int64
  %3 = load %1 : $*Builtin.Int64
  %4 = builtin_function_ref "sadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %5 = integer_literal $Builtin.Int1, 0
  %6 = apply %4(%2, %3, %5) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  %7 = tuple_extract %6 : $(Builtin.Int64, Builtin.Int1), 0
  return %7 : $(Builtin.Int64)
}

// CHECK-LABEL: floatliteral
// CHECK: float_literal $Builtin.FPIEEE32, 0x3F800000
// CHECK-NOT: float_literal $Builtin.FPIEEE32, 0x3F800000
sil @floatliteral : $@thin () -> (Builtin.FPIEEE32) {
  %0 = float_literal $Builtin.FPIEEE32, 0x3F800000
  %1 = float_literal $Builtin.FPIEEE32, 0x3F800000
  %2 = builtin_function_ref "fadd_FPIEEE32" : $@thin (Builtin.FPIEEE32, Builtin.FPIEEE32) -> Builtin.FPIEEE32 // user: %5
  %4 = apply %2(%0, %1) : $@thin (Builtin.FPIEEE32, Builtin.FPIEEE32) -> Builtin.FPIEEE32 // user: %6
  return %4 : $(Builtin.FPIEEE32)
}

sil @string_use : $@thin (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.metatype, Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.metatype) -> ()


// CHECK-LABEL: stringliteral
// CHECK: [[TARGET:%[0-9]+]] = string_literal utf8 "First"
// CHECK-NOT: string_literal "First"
// CHECK: apply {{%[0-9]+}}([[TARGET]]#0, [[TARGET]]#1, [[TARGET]]#2, {{%[0-9]+}}, [[TARGET]]#0, [[TARGET]]#1, [[TARGET]]#2, {{%[0-9]+}})
sil @stringliteral : $@thin () -> () {
  %0 = string_literal utf8 "First"
  %1 = string_literal utf8 "First"
  %2 = metatype $@thin String.metatype
  %3 = function_ref @string_use : $@thin (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.metatype, Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.metatype) -> ()
  apply %3 (%0#0, %0#1, %0#2, %2, %1#0, %1#1, %1#2, %2): $@thin (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.metatype, Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.metatype) -> ()
  %4 = tuple()
  return %4 : $()
}

struct Interval {
  var start: Builtin.Int32
  var end: Builtin.Int32
}
struct FakeInterval {
  var start: Builtin.Int32
  var end: Builtin.Int32
}

sil @print_interval : $@thin (Interval) -> ()
sil @print_fake_interval : $@thin (FakeInterval) -> ()

// CHECK-LABEL: structliteral
// CHECK: [[TARGET:%[0-9]+]] = struct $Interval ([[IN1:%[0-9]+]] : $Builtin.Int32, [[IN2:%[0-9]+]] : $Builtin.Int32)
// CHECK-NOT: struct $Interval ([[IN1]] : $Builtin.Int32, [[IN2]] : $Builtin.Int32)
// CHECK: [[DECOY:%[0-9]+]] = struct $FakeInterval ([[IN1]] : $Builtin.Int32, [[IN2]] : $Builtin.Int32)
// CHECK: [[PRINT_INTERVAL_FUN:%[0-9]+]] = function_ref @print_interval
// CHECK: apply [[PRINT_INTERVAL_FUN]]([[TARGET]])
// CHECK: apply [[PRINT_INTERVAL_FUN]]([[TARGET]])
// CHECK: [[PRINT_FAKEINTERVAL_FUN:%[0-9]+]] = function_ref @print_fake_interval
// CHECK: apply [[PRINT_FAKEINTERVAL_FUN]]([[DECOY]])
sil @structliteral : $@thin (Builtin.Int32, Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32, %1 : $Builtin.Int32):
  %2 = struct $Interval (%0 : $Builtin.Int32, %1 : $Builtin.Int32)
  %3 = struct $Interval (%0 : $Builtin.Int32, %1 : $Builtin.Int32)
  %4 = struct $FakeInterval (%0 : $Builtin.Int32, %1 : $Builtin.Int32)
  %5 = function_ref @print_interval : $@thin (Interval) -> ()
  apply %5 (%2) : $@thin (Interval) -> ()
  apply %5 (%3) : $@thin (Interval) -> ()
  %6 = function_ref @print_fake_interval : $@thin (FakeInterval) -> ()
  apply %6 (%4) : $@thin (FakeInterval) -> ()
  %9 = tuple()
  return %9 : $()
}

sil @sadd_with_address : $@thin (@inout Builtin.Int32, @inout Builtin.Int32) -> (Builtin.Int32)

// CHECK-LABEL: structelementaddr_test
// CHECK: struct_element_addr {{%[0-9]+}} : $*Interval, #start
// CHECK-NOT: struct_element_addr {{%[0-9]+}} : $*Interval, #start
sil @structelementaddr_test : $@thin (@inout Interval) -> (Builtin.Int32) {
bb0(%0 : $*Interval):
  %1 = struct_element_addr %0 : $*Interval, #start
  %2 = struct_element_addr %0 : $*Interval, #start
  %3 = function_ref @sadd_with_address : $@thin (@inout Builtin.Int32, @inout Builtin.Int32) -> (Builtin.Int32)
  %4 = apply %3(%1, %2) : $@thin (@inout Builtin.Int32, @inout Builtin.Int32) -> (Builtin.Int32)
  return %4 : $(Builtin.Int32)
}

sil @tuple_function : $@thin ((Builtin.Int32, Builtin.Int32), (Builtin.Int32, Builtin.Int32)) -> (Builtin.Int32)

// CHECK-LABEL: tuple_test
// CHECK: tuple ({{%[0-9]+}} : $Builtin.Int32, {{%[0-9]+}} : $Builtin.Int32)
// CHECK-NOT: tuple ({{%[0-9]+}} : $Builtin.Int32, {{%[0-9]+}} : $Builtin.Int32)
sil @tuple_test : $@thin (Builtin.Int32, Builtin.Int32) -> (Builtin.Int32) {
bb0(%0 : $Builtin.Int32, %1 : $Builtin.Int32):
  %2 = tuple(%0 : $Builtin.Int32, %1 : $Builtin.Int32)
  %3 = tuple(%0 : $Builtin.Int32, %1 : $Builtin.Int32)  
  %4 = function_ref @tuple_function : $@thin ((Builtin.Int32, Builtin.Int32), (Builtin.Int32, Builtin.Int32)) -> (Builtin.Int32)
  %5 = apply %4(%2, %3) : $@thin ((Builtin.Int32, Builtin.Int32), (Builtin.Int32, Builtin.Int32)) -> (Builtin.Int32)
  return %5 : $(Builtin.Int32)
}

sil @generate_tuple : $@thin () -> ((Builtin.Int32, Builtin.Int32))
// CHECK-LABEL: tupleextract_test
// CHECK: tuple_extract {{%[0-9]}} : $(Builtin.Int32, Builtin.Int32), 0
// CHECK-NOT: tuple_extract {{%[0-9]}} : $(Builtin.Int32, Builtin.Int32), 0
sil @tupleextract_test : $@thin () -> (Builtin.Int32) {
  %0 = function_ref @generate_tuple : $@thin () -> ((Builtin.Int32, Builtin.Int32))
  %1 = apply %0() : $@thin () -> ((Builtin.Int32, Builtin.Int32))
  %2 = tuple_extract %1 : $(Builtin.Int32, Builtin.Int32), 0
  %3 = tuple_extract %1 : $(Builtin.Int32, Builtin.Int32), 0
  %4 = builtin_function_ref "sadd_with_overflow_Int32" : $@thin (Builtin.Int32, Builtin.Int32, Builtin.Int1) -> (Builtin.Int32, Builtin.Int1)
  %5 = integer_literal $Builtin.Int1, 0
  %6 = apply %4 (%2, %3, %5) : $@thin (Builtin.Int32, Builtin.Int32, Builtin.Int1) -> (Builtin.Int32, Builtin.Int1)
  %7 = tuple_extract %6 : $(Builtin.Int32, Builtin.Int1), 0
  return %7 : $(Builtin.Int32)
}

sil @init_tuple_addr : $@thin (@out (Builtin.Int32, Builtin.Int32)) -> ()

// CHECK-LABEL: tupleelementaddr_test
// CHECK: tuple_element_addr {{%[0-9]#1}} : $*(Builtin.Int32, Builtin.Int32), 0
// CHECK-NOT: tuple_element_addr {{%[0-9]#1}} : $*(Builtin.Int32, Builtin.Int32), 0
sil @tupleelementaddr_test : $@thin () -> (Builtin.Int32) {
  %0 = alloc_stack $(Builtin.Int32, Builtin.Int32)
  %1 = function_ref @init_tuple_addr : $@thin (@out (Builtin.Int32, Builtin.Int32)) -> ()
  apply %1(%0#1) : $@thin (@out (Builtin.Int32, Builtin.Int32)) -> ()  
  %2 = tuple_element_addr %0#1 : $*(Builtin.Int32, Builtin.Int32), 0
  %3 = tuple_element_addr %0#1 : $*(Builtin.Int32, Builtin.Int32), 0
  %4 = builtin_function_ref "sadd_with_overflow_Int32" : $@thin (Builtin.Int32, Builtin.Int32, Builtin.Int1) -> (Builtin.Int32, Builtin.Int1)
  %5 = integer_literal $Builtin.Int1, 0
  %6 = load %2 : $*Builtin.Int32
  %7 = load %3 : $*Builtin.Int32
  %8 = apply %4 (%6, %7, %5) : $@thin (Builtin.Int32, Builtin.Int32, Builtin.Int1) -> (Builtin.Int32, Builtin.Int1)
  %9 = tuple_extract %8 : $(Builtin.Int32, Builtin.Int1), 0
  dealloc_stack %0#0 : $* @local_storage (Builtin.Int32, Builtin.Int32)
  return %9 : $(Builtin.Int32)
}

sil @metatype_user : $@thin (@thin String.metatype) -> ()

// CHECK-LABEL: metatype_test
// CHECK: [[TARGET:%[0-9]+]] = metatype $@thin String.metatype
// CHECK-NOT: {{%[0-9]+}} = metatype $@thin String.metatype
// CHECK: apply {{%[0-9]+}}([[TARGET]])
// CHECK: apply {{%[0-9]+}}([[TARGET]])
sil @metatype_test : $@thin () -> () {
  %0 = metatype $@thin String.metatype    
  %1 = metatype $@thin String.metatype
  %2 = function_ref @metatype_user : $@thin (@thin String.metatype) -> ()
  apply %2(%0) : $@thin (@thin String.metatype) -> ()
  apply %2(%1) : $@thin (@thin String.metatype) -> ()
  %3 = tuple()
  return %3 : $()
}

struct StringData {
  var size: Builtin.Word
}

// CHECK-LABEL: sil @sil_extract_of_string
//
// Make sure we only forward the first field of the string_literal
// instead of the whole string literal. Otherwise we run into arity
// issues.
sil @sil_extract_of_string : $@thin () -> Builtin.Word {
  %0 = string_literal utf8 ""
  %1 = struct $StringData (%0#1 : $Builtin.Word)
  %2 = struct_extract %1 : $StringData, #size  
  return %2 : $Builtin.Word
}

sil @helper : $@thin (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word

sil @sil_string_different_encodings : $@thin () -> Builtin.Word {
  %0 = string_literal utf8 "help"
  %1 = string_literal utf16 "help"
  %2 = function_ref @helper : $@thin (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
  %3 = apply %2(%0#0, %1#0) : $@thin (Builtin.RawPointer, Builtin.RawPointer) -> Builtin.Word
  return %3 : $Builtin.Word
}
// CHECK:      [[T0:%.*]] = function_ref @helper
// CHECK-NEXT: apply [[T0]](%0#0, %1#0)

