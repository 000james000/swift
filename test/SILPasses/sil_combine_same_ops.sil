// RUN: %target-sil-opt %s -sil-combine -verify | FileCheck %s

// Test optimization of various builtins which receive the same value in their first and second operand.

sil_stage canonical

import Builtin
import Swift

// CHECK-LABEL: sil @tst_ssub 
// CHECK: %1 = integer_literal $Builtin.Word, 0
// CHECK: %2 = struct $Int (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_ssub : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = integer_literal $Builtin.Int1, -1
  %3 = builtin "ssub_with_overflow_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word, %2 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Word, Builtin.Int1), 0
  %5 = tuple_extract %3 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %5 : $Builtin.Int1
  %7 = struct $Int (%4 : $Builtin.Word)
  return %7 : $Int
}

// CHECK-LABEL: sil @tst_usub 
// CHECK: %1 = integer_literal $Builtin.Word, 0
// CHECK: %2 = struct $UInt (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_usub : $@thin (UInt) -> UInt {
bb0(%0 : $UInt):
  %1 = struct_extract %0 : $UInt, #UInt.value
  %2 = integer_literal $Builtin.Int1, -1
  %3 = builtin "usub_with_overflow_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word, %2 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Word, Builtin.Int1), 0
  %5 = tuple_extract %3 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %5 : $Builtin.Int1
  %7 = struct $UInt (%4 : $Builtin.Word)
  return %7 : $UInt
}

// CHECK-LABEL: sil @tst_sdiv 
// CHECK: %1 = integer_literal $Builtin.Word, 1
// CHECK: %2 = struct $Int (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_sdiv : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0
  %2 = struct_extract %0 : $Int, #Int.value
  %3 = builtin "sdiv_Word"(%2 : $Builtin.Word, %2 : $Builtin.Word) : $Builtin.Word
  %4 = struct $Int (%3 : $Builtin.Word)
  return %4 : $Int
}

// CHECK-LABEL: sil @tst_udiv 
// CHECK: %1 = integer_literal $Builtin.Word, 1
// CHECK: %2 = struct $UInt (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_udiv : $@thin (UInt) -> UInt {
bb0(%0 : $UInt):
  %1 = integer_literal $Builtin.Word, 0
  %2 = struct_extract %0 : $UInt, #UInt.value
  %3 = builtin "udiv_Word"(%2 : $Builtin.Word, %2 : $Builtin.Word) : $Builtin.Word
  %4 = struct $UInt (%3 : $Builtin.Word)
  return %4 : $UInt
}

// CHECK-LABEL: sil @tst_srem 
// CHECK: %1 = integer_literal $Builtin.Word, 0
// CHECK: %2 = struct $Int (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_srem : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0
  %2 = struct_extract %0 : $Int, #Int.value
  %3 = builtin "srem_Word"(%2 : $Builtin.Word, %2 : $Builtin.Word) : $Builtin.Word
  %4 = struct $Int (%3 : $Builtin.Word)
  return %4 : $Int
}

// CHECK-LABEL: sil @tst_urem 
// CHECK: %1 = integer_literal $Builtin.Word, 0
// CHECK: %2 = struct $UInt (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_urem : $@thin (UInt) -> UInt {
bb0(%0 : $UInt):
  %1 = integer_literal $Builtin.Word, 0
  %2 = struct_extract %0 : $UInt, #UInt.value
  %3 = builtin "urem_Word"(%2 : $Builtin.Word, %2 : $Builtin.Word) : $Builtin.Word
  %4 = struct $UInt (%3 : $Builtin.Word)
  return %4 : $UInt
}

// CHECK-LABEL: sil @tst_and 
// CHECK: return %0
sil @tst_and : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "and_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Word
  %3 = struct $Int (%2 : $Builtin.Word)
  return %3 : $Int
}

// CHECK-LABEL: sil @tst_or 
// CHECK: return %0
sil @tst_or : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "or_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Word
  %3 = struct $Int (%2 : $Builtin.Word)
  return %3 : $Int
}

// CHECK-LABEL: sil @tst_xor 
// CHECK: %1 = integer_literal $Builtin.Word, 0
// CHECK: %2 = struct $Int (%1 : $Builtin.Word)
// CHECK: return %2
sil @tst_xor : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "xor_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Word
  %3 = struct $Int (%2 : $Builtin.Word)
  return %3 : $Int
}

// CHECK-LABEL: sil @tst_icmp_eq 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_eq : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "cmp_eq_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_ne 
// CHECK: %1 = integer_literal $Builtin.Int1, 0
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_ne : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "cmp_ne_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_sle 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_sle : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "cmp_sle_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_sge 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_sge : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "cmp_sge_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_slt 
// CHECK: %1 = integer_literal $Builtin.Int1, 0
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_slt : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "cmp_slt_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_sgt 
// CHECK: %1 = integer_literal $Builtin.Int1, 0
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_sgt : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = builtin "cmp_sgt_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_ule 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_ule : $@thin (UInt) -> Bool {
bb0(%0 : $UInt):
  %1 = struct_extract %0 : $UInt, #UInt.value
  %2 = builtin "cmp_ule_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_uge 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_uge : $@thin (UInt) -> Bool {
bb0(%0 : $UInt):
  %1 = struct_extract %0 : $UInt, #UInt.value
  %2 = builtin "cmp_uge_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_ult 
// CHECK: %1 = integer_literal $Builtin.Int1, 0
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_ult : $@thin (UInt) -> Bool {
bb0(%0 : $UInt):
  %1 = struct_extract %0 : $UInt, #UInt.value
  %2 = builtin "cmp_ult_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_icmp_ugt 
// CHECK: %1 = integer_literal $Builtin.Int1, 0
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_icmp_ugt : $@thin (UInt) -> Bool {
bb0(%0 : $UInt):
  %1 = struct_extract %0 : $UInt, #UInt.value
  %2 = builtin "cmp_ugt_Word"(%1 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_fcmp_ueq 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_fcmp_ueq : $@thin (Float) -> Bool {
bb0(%0 : $Float):
  %1 = struct_extract %0 : $Float, #Float.value
  %2 = builtin "fcmp_ueq_FPIEEE32"(%1 : $Builtin.FPIEEE32, %1 : $Builtin.FPIEEE32) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_fcmp_one 
// CHECK: %1 = integer_literal $Builtin.Int1, 0
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_fcmp_one : $@thin (Float) -> Bool {
bb0(%0 : $Float):
  %1 = struct_extract %0 : $Float, #Float.value
  %2 = builtin "fcmp_one_FPIEEE32"(%1 : $Builtin.FPIEEE32, %1 : $Builtin.FPIEEE32) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_fcmp_ule 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_fcmp_ule : $@thin (Float) -> Bool {
bb0(%0 : $Float):
  %1 = struct_extract %0 : $Float, #Float.value
  %2 = builtin "fcmp_ule_FPIEEE32"(%1 : $Builtin.FPIEEE32, %1 : $Builtin.FPIEEE32) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

// CHECK-LABEL: sil @tst_fcmp_uge 
// CHECK: %1 = integer_literal $Builtin.Int1, -1
// CHECK: %2 = struct $Bool (%1 : $Builtin.Int1)
// CHECK: return %2
sil @tst_fcmp_uge : $@thin (Float) -> Bool {
bb0(%0 : $Float):
  %1 = struct_extract %0 : $Float, #Float.value
  %2 = builtin "fcmp_uge_FPIEEE32"(%1 : $Builtin.FPIEEE32, %1 : $Builtin.FPIEEE32) : $Builtin.Int1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  return %3 : $Bool
}

