// RUN: %sil-opt %s -codemotion -verify | FileCheck %s

import Builtin
import Swift

class B { }
class E : B { }

enum FakeOptional {
  case None
  case Some(Builtin.Int32)
}

sil @user : $@thin (Builtin.NativeObject) -> ()
sil @optional_user : $@thin (FakeOptional) -> ()
sil @blocker : $@thin () -> ()

// CHECK-LABEL: sil @sink_from_preds
// CHECK: bb1:
// CHECK-NEXT: br bb3
// CHECK: bb2:
// CHECK-NEXT: br bb3
// CHECK: bb3:
// CHECK: strong_retain
// CHECK: return
sil @sink_from_preds : $@thin (Builtin.Int1, B) -> () {
bb0(%0 : $Builtin.Int1, %1 : $B):
  cond_br %0, bb1, bb2

bb1:
  %2 = strong_retain %1 : $B
  br bb3

bb2:
  %3 = strong_retain %1 : $B
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @do_not_sink_local_uses
// CHECK: integer_literal
// CHECK: integer_literal
// CHECK: return
sil @do_not_sink_local_uses : $@thin (Builtin.Int1) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int32, 7
  br bb2(%1 : $Builtin.Int32)

bb3:
  %2 = integer_literal $Builtin.Int32, 8
  br bb2(%2 : $Builtin.Int32)

bb2(%3 : $Builtin.Int32):
  return %3 : $Builtin.Int32
}

// CHECK-LABEL: sil @deep_sink1
// CHECK: integer_literal
// CHECK: br bb3
// CHECK: integer_literal
// CHECK: br bb3
// CHECK: bb3
// CHECK: strong_retain
// CHECK-NEXT: return
sil @deep_sink1 : $@thin (Builtin.Int1, B) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int1, %1 : $B):
  cond_br %0, bb1, bb2

bb1:
  %2 = strong_retain %1 : $B
  %3 = integer_literal $Builtin.Int32, 9
  br bb3(%3 : $Builtin.Int32)

bb2:
  %4 = strong_retain %1 : $B
  %5 = integer_literal $Builtin.Int32, 7
  br bb3(%5 : $Builtin.Int32)

bb3(%6 : $Builtin.Int32):
  return %6 : $Builtin.Int32
}

// CHECK-LABEL: sil @deep_sink2
// CHECK-NOT: integer_literal
// CHECK: br bb3
// CHECK-NOT: integer_literal
// CHECK: br bb3
// CHECK: bb3
// CHECK: integer_literal
// CHECK: strong_retain
// CHECK-NEXT: return
sil @deep_sink2 : $@thin (Builtin.Int1, B) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int1, %1 : $B):
  cond_br %0, bb1, bb2

bb1:
  %2 = strong_retain %1 : $B
  %3 = integer_literal $Builtin.Int32, 7
  br bb3(%3 : $Builtin.Int32)

bb2:
  %4 = strong_retain %1 : $B
  %5 = integer_literal $Builtin.Int32, 7
  br bb3(%5 : $Builtin.Int32)

bb3(%6 : $Builtin.Int32):
  return %6 : $Builtin.Int32
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_1 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: retain_value
// CHECK-NEXT: apply
// CHECK-NEXT: alloc_stack
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: switch_enum
// CHECK: bb1({{.*}}):
// CHECK-NEXT: unchecked_enum_data
// CHECK-NEXT: retain_value
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_1 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  retain_value %0 : $FakeOptional
  apply %1() : $@thin () -> ()
  %3 = alloc_stack $Builtin.Int32
  retain_value %0 : $FakeOptional
  dealloc_stack %3#0 : $*@local_storage Builtin.Int32
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1(%2 : $Builtin.Int32):
  br bb3

bb2:
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_2 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: retain_value
// CHECK-NEXT: switch_enum
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_2 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  cond_br undef, bb1, bb2

bb1:
  retain_value %0 : $FakeOptional
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb2, case #FakeOptional.None!enumelt: bb3

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_3 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: retain_value
// CHECK-NEXT: switch_enum
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_3 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  cond_br undef, bb1, bb3

bb1:
  retain_value %0 : $FakeOptional
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb2, case #FakeOptional.None!enumelt: bb3

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_4 : $@thin (FakeOptional) -> FakeOptional {
// CHECK: bb0({{.*}}):
// CHECK-NOT: retain_value
// CHECK: switch_enum
// CHECK: bb1:
// CHECK: unchecked_enum_data
// CHECK: retain_value
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_4 : $@thin (FakeOptional) -> FakeOptional {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  %2 = alloc_stack $FakeOptional
  %3 = function_ref @optional_user : $@thin (FakeOptional) -> ()
  %4 = integer_literal $Builtin.Int32, 0
  %5 = enum $FakeOptional, #FakeOptional.Some!enumelt.1, %4 : $Builtin.Int32
  retain_value %5 : $FakeOptional
  apply %1() : $@thin () -> ()
  apply %3(%0) : $@thin (FakeOptional) -> ()
  switch_enum %5 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  dealloc_stack %2#0 : $*@local_storage FakeOptional
  return %5 : $FakeOptional
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_enum_is_tag_1 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: retain_value
// CHECK-NEXT: apply
// CHECK-NEXT: alloc_stack
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: enum_is_tag
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: unchecked_enum_data
// CHECK-NEXT: retain_value
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_enum_is_tag_1 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  retain_value %0 : $FakeOptional
  apply %1() : $@thin () -> ()
  %3 = alloc_stack $Builtin.Int32
  retain_value %0 : $FakeOptional
  dealloc_stack %3#0 : $*@local_storage Builtin.Int32
  %100 = enum_is_tag $Builtin.Int1, %0 : $FakeOptional, #FakeOptional.Some!enumelt
  cond_br %100, bb1, bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_enum_is_tag_2 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: enum_is_tag
// CHECK-NEXT: retain_value
// CHECK-NEXT: cond_br
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_enum_is_tag_2 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  cond_br undef, bb1, bb2

bb1:
  retain_value %0 : $FakeOptional
  %100 = enum_is_tag $Builtin.Int1, %0 : $FakeOptional, #FakeOptional.Some!enumelt
  cond_br %100, bb2, bb3

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_enum_is_tag_3 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: enum_is_tag
// CHECK-NEXT: retain_value
// CHECK-NEXT: cond_br
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_enum_is_tag_3 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  cond_br undef, bb1, bb3

bb1:
  retain_value %0 : $FakeOptional
  %100 = enum_is_tag $Builtin.Int1, %0 : $FakeOptional, #FakeOptional.Some!enumelt
  cond_br %100, bb2, bb3

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_enum_is_tag_4 : $@thin (FakeOptional) -> FakeOptional {
// CHECK: bb0({{.*}}):
// CHECK-NOT: retain_value
// CHECK: enum_is_tag
// CHECK: cond_br
// CHECK: bb1:
// CHECK: unchecked_enum_data
// CHECK: retain_value
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_enum_is_tag_4 : $@thin (FakeOptional) -> FakeOptional {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  %2 = alloc_stack $FakeOptional
  %3 = function_ref @optional_user : $@thin (FakeOptional) -> ()
  %4 = integer_literal $Builtin.Int32, 0
  %5 = enum $FakeOptional, #FakeOptional.Some!enumelt.1, %4 : $Builtin.Int32
  retain_value %5 : $FakeOptional
  apply %1() : $@thin () -> ()
  apply %3(%0) : $@thin (FakeOptional) -> ()
  %100 = enum_is_tag $Builtin.Int1, %5 : $FakeOptional, #FakeOptional.Some!enumelt
  cond_br %100, bb1, bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  dealloc_stack %2#0 : $*@local_storage FakeOptional
  return %5 : $FakeOptional
}

/// This version does not work since we have a release before the terminator
/// even though we have the enum_is_tag before it.
// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_enum_is_tag_5 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK: bb1:
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: alloc_stack
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: enum_is_tag
// CHECK-NEXT: retain_value
// CHECK-NEXT: release_value
// CHECK-NEXT: cond_br
// CHECK: bb2:
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_enum_is_tag_5 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  br bb10

bb10:
  %1 = function_ref @blocker : $@thin () -> ()
  retain_value %0 : $FakeOptional
  %3 = alloc_stack $Builtin.Int32
  dealloc_stack %3#0 : $*@local_storage Builtin.Int32
  %100 = enum_is_tag $Builtin.Int1, %0 : $FakeOptional, #FakeOptional.Some!enumelt
  release_value %0 : $FakeOptional
  cond_br %100, bb1, bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

// Sink the struct instruction
// CHECK-LABEL: sil @sink_struct : $@thin (FakeOptional) -> Bool {
// CHECK: bb0({{.*}}):
// CHECK: switch_enum
// CHECK: bb1:
// CHECK: integer_literal $Builtin.Int1, -1
// CHECK: br bb3({{.*}} : $Builtin.Int1)
// CHECK: bb2:
// CHECK: integer_literal $Builtin.Int1, 0
// CHECK: br bb3({{.*}} : $Builtin.Int1)
// CHECK: bb3({{.*}} : $Builtin.Int1):
// CHECK: struct $Bool
// CHECK: return
sil @sink_struct : $@thin (FakeOptional) -> Bool {
bb0(%0 : $FakeOptional):
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  %6 = integer_literal $Builtin.Int1, -1
  %7 = struct $Bool (%6 : $Builtin.Int1)
  br bb3(%7 : $Bool)

bb2:
  %9 = integer_literal $Builtin.Int1, 0
  %10 = struct $Bool (%9 : $Builtin.Int1)
  br bb3(%10 : $Bool)

bb3(%12 : $Bool):
  return %12 : $Bool
}

// Sink retain down the successors so we can pair up retain with release on the
// fast path.
class Test {
  func testing() -> UInt64
}
let test: Test
var x: UInt64

// CHECK-LABEL: @sink_refcount_to_succs
sil @sink_refcount_to_succs : $@thin () -> () {
bb0:
  %0 = global_addr #test : $*Test
  %1 = alloc_ref $Test
  store %1 to %0 : $*Test
  %7 = global_addr #x : $*UInt64
  %8 = integer_literal $Builtin.Int64, 0
  %9 = struct $UInt64 (%8 : $Builtin.Int64)
  store %9 to %7 : $*UInt64
  br bb1
bb1:
// CHECK: bb1:
// CHECK-NOT: strong_retain
  %17 = load %0 : $*Test
  strong_retain %17 : $Test
  %19 = class_method %17 : $Test, #Test.testing!1 : Test -> () -> UInt64 , $@cc(method) @thin (@owned Test) -> UInt64
  %20 = load %7 : $*UInt64
  checked_cast_br [exact] %17 : $Test to $Test, bb3, bb4
bb2:
// CHECK: bb2:
// CHECK-NOT: strong_retain
  %36 = tuple ()
  return %36 : $()
bb3(%38 : $Test):
// CHECK: bb3(
// CHECK: strong_retain
// CHECK: strong_release
  strong_release %17 : $Test
  br bb2
bb4:
// CHECK: bb4:
// CHECK: strong_retain
// CHECK: apply
  %65 = apply %19(%17) : $@cc(method) @thin (@owned Test) -> UInt64
  br bb2
}

sil @virtual_callee : $@cc(method) @thin (@owned Test) -> UInt64
sil_vtable Test {
  #Test.testing!1: virtual_callee
}

// Don't sink a retain over switch_enum with a default case.
//
// CHECK-LABEL: sil @dont_sink_retain_over_default_case_switch_enum : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: retain_value
// CHECK-NEXT: switch_enum
// CHECK: return
sil @dont_sink_retain_over_default_case_switch_enum : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  retain_value %0 : $FakeOptional
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, default bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $() 
}

sil @arc_user : $@thin () -> ()
sil @_swift_isUniquelyReferenced : $@thin (Int) -> Bool

// The retains here aren't able to be moved to a successor BB.  But we still want to move them as far
// as possible down the current BB.  The first retain should be moved to above the release_value.
// The second retain shouldn't move at all
// The third retain should move below the sadd builtin_function_ref
// The fourth retain should move below the arc_user builtin_function_ref, but above the apply
// The fifth retain should *NOT* move below the apply to
// _swift_isUniquelyReferenced, unless we can prove that the pointers do not
// alias.
// And the last retain should remain where it is at the end of the BB.
//
// CHECK-LABEL: sil @move_retain_down_bb : $@thin (FakeOptional, FakeOptional, FakeOptional, FakeOptional, FakeOptional) -> (Builtin.Int64, Builtin.Int1) {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: builtin_function_ref
// CHECK-NEXT: retain_value %1
// CHECK-NEXT: retain_value %0
// CHECK-NEXT: release_value %4
// CHECK-NEXT: builtin_function_ref
// CHECK-NEXT: function_ref arc_user
// CHECK-NEXT: function_ref @arc_user
// CHECK-NEXT: retain_value %3
// CHECK-NEXT: retain_value %2
// CHECK-NEXT: apply
// CHECK-NEXT: function_ref _swift_isUniquelyReferenced
// CHECK-NEXT: function_ref @_swift_isUniquelyReferenced
// CHECK-NEXT: integer_literal $Builtin.Word, 1
// CHECK-NEXT: struct $Int
// CHECK-NEXT: retain_value %3
// CHECK-NEXT: apply
// CHECK-NEXT: retain_value %3
// CHECK-NEXT: switch_enum

// CHECK: return
sil @move_retain_down_bb : $@thin (FakeOptional, FakeOptional, FakeOptional, FakeOptional, FakeOptional) -> (Builtin.Int64, Builtin.Int1) {
bb0(%0 : $FakeOptional, %1 : $FakeOptional, %2 : $FakeOptional, %3 : $FakeOptional, %4 : $FakeOptional):
  retain_value %0 : $FakeOptional
  %13 = builtin_function_ref "ssub_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  retain_value %1 : $FakeOptional
  release_value %4 : $FakeOptional
  retain_value %2 : $FakeOptional
  %14 = builtin_function_ref "sadd_with_overflow_Int64" : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  retain_value %3 : $FakeOptional
  %1000 = function_ref @arc_user : $@thin () -> ()
  apply %1000 () : $@thin () -> ()
  retain_value %3 : $FakeOptional
  // function_ref _swift_isUniquelyReferenced
  %500 = function_ref @_swift_isUniquelyReferenced : $@thin (Int) -> Bool
  %501 = integer_literal $Builtin.Word, 1
  %502 = struct $Int (%501 : $Builtin.Word)
  %503 = apply %500(%502) : $@thin (Int) -> Bool
  retain_value %3 : $FakeOptional
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, default bb2

bb1:
  %100 = integer_literal $Builtin.Int64, 1
  %101 = integer_literal $Builtin.Int64, 2
  %102 = integer_literal $Builtin.Int1, 1
  %10 = apply %13(%100, %101, %102) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  br bb3(%10 : $(Builtin.Int64, Builtin.Int1))

bb2:
  %200 = integer_literal $Builtin.Int64, 3
  %201 = integer_literal $Builtin.Int64, 4
  %202 = integer_literal $Builtin.Int1, 1
  %11 = apply %14(%200, %201, %202) : $@thin (Builtin.Int64, Builtin.Int64, Builtin.Int1) -> (Builtin.Int64, Builtin.Int1)
  br bb3(%11 : $(Builtin.Int64, Builtin.Int1))

bb3(%12 : $(Builtin.Int64, Builtin.Int1)):
  return %12 : $(Builtin.Int64, Builtin.Int1)
}

// CHECK-LABEL: sil @sink_retains_from_preds : $@thin (Builtin.NativeObject) -> () {
// CHECK: bb1:
// CHECK-NOT: retain_value
// CHECK: bb2:
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK: retain_value
sil @sink_retains_from_preds : $@thin (Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.NativeObject):
  cond_br undef, bb1, bb2

bb1:
  retain_value %0 : $Builtin.NativeObject
  br bb3

bb2:
  retain_value %0 : $Builtin.NativeObject
  br bb3

bb3:
  %1 = tuple()
  return %1 : $()
}