// RUN: %sil-opt %s -codemotion -verify | FileCheck %s

import Builtin
import Swift

class B { }
class E : B { }

enum FakeOptional {
  case None
  case Some(Builtin.Int32)
}

sil @user : $@thin (Builtin.NativeObject) -> ()
sil @optional_user : $@thin (FakeOptional) -> ()
sil @blocker : $@thin () -> ()

// CHECK-LABEL: sil @sink_from_preds
// CHECK: bb1:
// CHECK-NEXT: br bb3
// CHECK: bb2:
// CHECK-NEXT: br bb3
// CHECK: bb3:
// CHECK: strong_retain
// CHECK: return
sil @sink_from_preds : $@thin (Builtin.Int1, B) -> () {
bb0(%0 : $Builtin.Int1, %1 : $B):
  cond_br %0, bb1, bb2

bb1:
  %2 = strong_retain %1 : $B
  br bb3

bb2:
  %3 = strong_retain %1 : $B
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @do_not_sink_local_uses
// CHECK: integer_literal
// CHECK: integer_literal
// CHECK: return
sil @do_not_sink_local_uses : $@thin (Builtin.Int1) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int32, 7
  br bb2(%1 : $Builtin.Int32)

bb3:
  %2 = integer_literal $Builtin.Int32, 8
  br bb2(%2 : $Builtin.Int32)

bb2(%3 : $Builtin.Int32):
  return %3 : $Builtin.Int32
}

// CHECK-LABEL: sil @deep_sink1
// CHECK: integer_literal
// CHECK: br bb3
// CHECK: integer_literal
// CHECK: br bb3
// CHECK: bb3
// CHECK: strong_retain
// CHECK-NEXT: return
sil @deep_sink1 : $@thin (Builtin.Int1, B) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int1, %1 : $B):
  cond_br %0, bb1, bb2

bb1:
  %2 = strong_retain %1 : $B
  %3 = integer_literal $Builtin.Int32, 9
  br bb3(%3 : $Builtin.Int32)

bb2:
  %4 = strong_retain %1 : $B
  %5 = integer_literal $Builtin.Int32, 7
  br bb3(%5 : $Builtin.Int32)

bb3(%6 : $Builtin.Int32):
  return %6 : $Builtin.Int32
}

// CHECK-LABEL: sil @deep_sink2
// CHECK-NOT: integer_literal
// CHECK: br bb3
// CHECK-NOT: integer_literal
// CHECK: br bb3
// CHECK: bb3
// CHECK: integer_literal
// CHECK: strong_retain
// CHECK-NEXT: return
sil @deep_sink2 : $@thin (Builtin.Int1, B) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int1, %1 : $B):
  cond_br %0, bb1, bb2

bb1:
  %2 = strong_retain %1 : $B
  %3 = integer_literal $Builtin.Int32, 7
  br bb3(%3 : $Builtin.Int32)

bb2:
  %4 = strong_retain %1 : $B
  %5 = integer_literal $Builtin.Int32, 7
  br bb3(%5 : $Builtin.Int32)

bb3(%6 : $Builtin.Int32):
  return %6 : $Builtin.Int32
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_1 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: retain_value
// CHECK-NEXT: apply
// CHECK-NEXT: alloc_stack
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: switch_enum
// CHECK: bb1({{.*}}):
// CHECK-NEXT: unchecked_enum_data
// CHECK-NEXT: retain_value
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_1 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  retain_value %0 : $FakeOptional
  apply %1() : $@thin () -> ()
  %3 = alloc_stack $Builtin.Int32
  retain_value %0 : $FakeOptional
  dealloc_stack %3#0 : $*@local_storage Builtin.Int32
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1(%2 : $Builtin.Int32):
  br bb3

bb2:
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_2 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: retain_value
// CHECK-NEXT: switch_enum
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_2 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  cond_br undef, bb1, bb2

bb1:
  retain_value %0 : $FakeOptional
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb2, case #FakeOptional.None!enumelt: bb3

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_3 : $@thin (FakeOptional) -> () {
// CHECK: bb0({{.*}}):
// CHECK-NEXT: function_ref blocker
// CHECK-NEXT: function_ref @blocker
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: retain_value
// CHECK-NEXT: switch_enum
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb4:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_3 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  cond_br undef, bb1, bb3

bb1:
  retain_value %0 : $FakeOptional
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb2, case #FakeOptional.None!enumelt: bb3

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sink_ref_count_ops_enum_over_switch_enum_4 : $@thin (FakeOptional) -> FakeOptional {
// CHECK: bb0({{.*}}):
// CHECK-NOT: retain_value
// CHECK: switch_enum
// CHECK: bb1:
// CHECK: unchecked_enum_data
// CHECK: retain_value
// CHECK: bb2:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
// CHECK: bb3:
// CHECK-NOT: unchecked_enum_data
// CHECK-NOT: retain_value
sil @sink_ref_count_ops_enum_over_switch_enum_4 : $@thin (FakeOptional) -> FakeOptional {
bb0(%0 : $FakeOptional):
  %1 = function_ref @blocker : $@thin () -> ()
  %2 = alloc_stack $FakeOptional
  %3 = function_ref @optional_user : $@thin (FakeOptional) -> ()
  %4 = integer_literal $Builtin.Int32, 0
  %5 = enum $FakeOptional, #FakeOptional.Some!enumelt.1, %4 : $Builtin.Int32
  retain_value %5 : $FakeOptional
  apply %1() : $@thin () -> ()
  apply %3(%0) : $@thin (FakeOptional) -> ()
  switch_enum %5 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  dealloc_stack %2#0 : $*@local_storage FakeOptional
  return %5 : $FakeOptional
}

// Sink retain down the successors so we can pair up retain with release on the
// fast path.
class Test {
  func testing() -> UInt64
}
let test: Test
var x: UInt64

// CHECK-LABEL: @sink_refcount_to_succs
sil @sink_refcount_to_succs : $@thin () -> () {
bb0:
  %0 = global_addr #test : $*Test
  %1 = alloc_ref $Test
  store %1 to %0 : $*Test
  %7 = global_addr #x : $*UInt64
  %8 = integer_literal $Builtin.Int64, 0
  %9 = struct $UInt64 (%8 : $Builtin.Int64)
  store %9 to %7 : $*UInt64
  br bb1
bb1:
// CHECK: bb1:
// CHECK-NOT: strong_retain
  %17 = load %0 : $*Test
  strong_retain %17 : $Test
  %19 = class_method %17 : $Test, #Test.testing!1 : Test -> () -> UInt64 , $@cc(method) @thin (@owned Test) -> UInt64
  %20 = load %7 : $*UInt64
  checked_cast_br [exact] %17 : $Test to $Test, bb3, bb4
bb2:
// CHECK: bb2:
// CHECK-NOT: strong_retain
  %36 = tuple ()
  return %36 : $()
bb3(%38 : $Test):
// CHECK: bb3(
// CHECK: strong_retain
// CHECK: strong_release
  strong_release %17 : $Test
  br bb2
bb4:
// CHECK: bb4:
// CHECK: strong_retain
// CHECK: apply
  %65 = apply %19(%17) : $@cc(method) @thin (@owned Test) -> UInt64
  br bb2
}

sil @virtual_callee : $@cc(method) @thin (@owned Test) -> UInt64
sil_vtable Test {
  #Test.testing!1: virtual_callee
}
