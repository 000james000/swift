// RUN: %sil-opt %s -simplify-cfg | FileCheck %s

import Builtin
import Swift

sil_stage canonical

// CHECK-LABEL: @test_dead_block
// CHECK-NEXT: bb0:
// CHECK-NEXT:   unreachable
// CHECK-NEXT: }
sil @test_dead_block : $() -> () {
bb0:
  unreachable

bb1:
  %4 = integer_literal $Builtin.Int64, 1
  br bb2

bb2:
  %5 = struct $Int64 (%4 : $Builtin.Int64)
  unreachable
}

// CHECK-LABEL: @test_single_pred_block
// CHECK: struct $Int64
// CHECK-NEXT: return
sil @test_single_pred_block : $@thin (Builtin.Int1) -> Int64 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %4 = integer_literal $Builtin.Int64, 1
  br bb2(%4 : $Builtin.Int64)

bb3:
  %9 = integer_literal $Builtin.Int64, 2
  br bb2(%9 : $Builtin.Int64)

bb2(%6 : $Builtin.Int64):
  %7 = struct $Int64 (%6 : $Builtin.Int64)
  br bb4(%7 : $Int64)

bb4(%8 : $Int64):
  return %8 : $Int64
}

enum BoolLike { case true, false }

// func testThread(a : BoolLike) -> Int {
//   if a { return 42 } else { return 17 } }
//
/// CHECK-LABEL: sil @testThread
sil @testThread : $@thin (BoolLike) -> Int64 {
bb0(%0 : $BoolLike):
  // CHECK: switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb3 // id: %3

bb1:                                              // Preds: bb0
  %4 = integer_literal $Builtin.Int1, -1          // user: %5
  br bb2(%4 : $Builtin.Int1)                      // id: %5

bb2(%6 : $Builtin.Int1):                          // Preds: bb3 bb1
  br bb4                                          // id: %7

bb3:                                              // Preds: bb0
  %8 = integer_literal $Builtin.Int1, 0           // user: %9
  br bb2(%8 : $Builtin.Int1)                      // id: %9

bb4:                                              // Preds: bb2
  cond_br %6, bb5, bb6                            // id: %10

bb5:                                              // Preds: bb4
  %11 = metatype $@thin Int64.Type
  %12 = integer_literal $Builtin.Int64, 42        // user: %13
  %13 = struct $Int64 (%12 : $Builtin.Int64)      // user: %14
  br bb7(%13 : $Int64)                            // id: %14

bb6:                                              // Preds: bb4
  %15 = metatype $@thin Int64.Type
  %16 = integer_literal $Builtin.Int64, 17        // user: %17
  %17 = struct $Int64 (%16 : $Builtin.Int64)      // user: %18
  br bb7(%17 : $Int64)                            // id: %18

bb7(%19 : $Int64):                                // Preds: bb6 bb5
  return %19 : $Int64                             // id: %21
}

/// CHECK-LABEL: sil @testCondBrFold
/// CHECK-NEXT: bb0(
/// CHECK-NEXT: return %1 : $Int64
sil @testCondBrFold : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %1 : $Int64):
  %8 = integer_literal $Builtin.Int1, 0
  cond_br %8, bb1, bb2
bb1:
  unreachable
bb2:
  return %1 : $Int64
}

/// CHECK-LABEL: sil @testSwitchEnumFold
/// CHECK-NEXT: bb0(
/// CHECK-NEXT: return %0 : $Int64
sil @testSwitchEnumFold : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = enum $BoolLike, #BoolLike.true!enumelt
  switch_enum %1 : $BoolLike, case #BoolLike.true!enumelt: bb2, case #BoolLike.false!enumelt: bb1
bb1:
  unreachable
bb2:
  return %0 : $Int64
}

// CHECK-LABEL: @elim_trampoline
// CHECK: cond_br %0, bb1(%1 : $Int64), bb1(%2 : $Int64)
// CHECK: bb1
// CHECK-NEXT: return
sil @elim_trampoline : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%2 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb3(%4 : $Int64)

bb3(%5 : $Int64):
  return %5 : $Int64
}

// CHECK-LABEL: @elim_trampoline2
// CHECK-NOT: cond_br %0, bb1(%1 : $Int64), bb1(%1 : $Int64)
// CHECK: return
sil @elim_trampoline2 : $@thin (Builtin.Int1, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%1 : $Int64)

bb1(%2 : $Int64):
  br bb3(%2 : $Int64)

bb2(%3 : $Int64):
  br bb3(%3 : $Int64)

bb3(%4 : $Int64):
  return %4 : $Int64
}

// CHECK-LABEL: @elim_trampoline3
// CHECK: cond_br %0, bb1(%1 : $Int64), bb1(%2 : $Int64)
// CHECK: bb1
// CHECK-NEXT: return
sil @elim_trampoline3 : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%2 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb3(%4 : $Int64)

bb3(%5 : $Int64):
  br bb4(%5 : $Int64)

bb4(%6 : $Int64):
  return %6 : $Int64
}

// CHECK-LABEL: @elim_trampoline_loop
// Make sure we are not crashing on this one.
// CHECK: return
sil @elim_trampoline_loop : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%2 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb2(%4 : $Int64)

bb3(%5 : $Int64):
  br bb4(%5 : $Int64)

bb4(%6 : $Int64):
  return %6 : $Int64
}

// CHECK-LABEL: @elim_diamonds
// CHECK: bb0
// CHECK-NEXT: return %1
sil @elim_diamonds : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%1 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb3(%4 : $Int64)

bb3(%5 : $Int64):
  cond_br %0, bb4(%5 : $Int64), bb5(%5 : $Int64)

bb4(%6 : $Int64):
  br bb6(%6 : $Int64)

bb5(%7 : $Int64):
  br bb6(%7 : $Int64)

bb6(%8 : $Int64):
  return %8 : $Int64
}

// CHECK-LABEL: @infinite_loop
// CHECK: bb0
// CHECK-NEXT: br bb0
sil @infinite_loop : $@thin () -> () {
bb0:
  br bb0
}

import Builtin
import Swift

// CHECK-LABEL: @dead_loop
// CHECK-NOT: br
sil @dead_loop : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Int1, 0           // users: %1, %4
  %2 = integer_literal $Builtin.Int1, -1          // user: %11
  cond_br %0, bb1, bb3                            // id: %4

bb1:                                              // Preds: bb0
  %5 = integer_literal $Builtin.Word, 0           // users: %6, %7
  %6 = struct $Int (%5 : $Builtin.Word)
  br bb2(%5 : $Builtin.Word)                      // id: %7

bb2(%8 : $Builtin.Word):                          // Preds: bb1 bb2
  %9 = integer_literal $Builtin.Word, 1           // user: %11
  %10 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %11
  %11 = apply %10(%8, %9, %2) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // users: %12, %13
  %12 = tuple_extract %11 : $(Builtin.Word, Builtin.Int1), 0 // users: %15, %16
  %13 = tuple_extract %11 : $(Builtin.Word, Builtin.Int1), 1 // user: %14
  cond_fail %13 : $Builtin.Int1                   // id: %14
  %15 = struct $Int (%12 : $Builtin.Word)
  br bb2(%12 : $Builtin.Word)                     // id: %16

bb3:                                              // Preds: bb0
  %17 = tuple ()                                  // user: %18
  return %17 : $()                                // id: %18
}

// We should be able to compile this down to returning the parameter
// but we're not quite there yet.
// CHECK-LABEL: @nop
sil @nop : $@thin (Bool) -> Bool {
bb0(%0 : $Bool):
  %1 = struct_extract %0 : $Bool, #Bool.value
// CHECK: cond_br %1, [[TRUE:[a-zA-Z0-9]+]], [[FALSE:[a-zA-Z0-9]+]]
  cond_br %1, bb1, bb2

// CHECK: [[TRUE]]:
bb1:
  %3 = integer_literal $Builtin.Int1, 0
  %4 = struct $Bool (%3 : $Builtin.Int1)
// CHECK: br [[RETURN:[a-zA-Z0-9]+]]
  br bb3(%4 : $Bool)

// CHECK: [[FALSE]]:
bb2:
  %6 = integer_literal $Builtin.Int1, -1          // user: %7
  %7 = struct $Bool (%6 : $Builtin.Int1)          // user: %8
// CHECK: br [[RETURN]]
  br bb3(%7 : $Bool)                              // id: %8

// CHECK: [[RETURN]]
bb3(%9 : $Bool):                                  // Preds: bb1 bb2
// CHECK-NOT: struct_extract
  %10 = struct_extract %9 : $Bool, #Bool.value    // user: %11
// CHECK: return
  cond_br %10, bb4, bb5                           // id: %11

// CHECK-NOT: bb4
bb4:                                              // Preds: bb3
  %12 = integer_literal $Builtin.Int1, 0          // user: %13
  %13 = struct $Bool (%12 : $Builtin.Int1)        // user: %14
  br bb6(%13 : $Bool)                             // id: %14

// CHECK-NOT: bb5
bb5:                                              // Preds: bb3
  %15 = integer_literal $Builtin.Int1, -1         // user: %16
  %16 = struct $Bool (%15 : $Builtin.Int1)        // user: %17
  br bb6(%16 : $Bool)                             // id: %17

bb6(%18 : $Bool):                                 // Preds: bb4 bb5
  return %18 : $Bool                              // id: %19
}

class C {
  @final var value: Int
  init(v: Int)
}

// CHECK-LABEL: @redundant_switch_enum
sil @redundant_switch_enum : $@thin (@owned Optional<C>) -> Int {
bb0(%0 : $Optional<C>):
  switch_enum %0 : $Optional<C>, case #Optional.Some!enumelt.1: bb1, case #Optional.None!enumelt: bb2

// CHECK: bb1:
bb1:
  %9 = integer_literal $Builtin.Int1, -1
  %10 = struct $Bool (%9 : $Builtin.Int1)
// CHECK:  br [[DEST:[a-zA-Z0-9]+]]
  br bb3(%10 : $Bool)

// CHECK: bb2:
bb2:
  %17 = integer_literal $Builtin.Int1, 0
  %18 = struct $Bool (%17 : $Builtin.Int1)
// CHECK: br [[DEST]]
  br bb3(%18 : $Bool)

// CHECK: [[DEST]]({{.*}}):
bb3(%12 : $Bool):
  %15 = struct_extract %12 : $Bool, #Bool.value
// CHECK-NOT: cond_br
// CHECK: return
  cond_br %15, bb4, bb7

// CHECK-NOT: bb4:
bb4:
  %21 = alloc_stack $Optional<C>
  store %0 to %21#1 : $*Optional<C>
// CHECK-NOT: switch_enum
  switch_enum %0 : $Optional<C>, case #Optional.Some!enumelt.1: bb5, case #Optional.None!enumelt: bb6

bb5:
  %25 = take_enum_data_addr %21#1 : $*Optional<C>, #Optional.Some!enumelt.1
  %26 = load %25 : $*C
  dealloc_stack %21#0 : $*@local_storage Optional<C>
  %29 = ref_element_addr %26 : $C, #C.value
  %30 = load %29 : $*Int
  br bb8(%30 : $Int)

bb6:
  %33 = builtin_function_ref "int_trap" : $@thin @noreturn () -> ()
  %34 = apply %33() : $@thin @noreturn () -> ()
  unreachable

bb7:
  %36 = integer_literal $Builtin.Word, 0
  %37 = struct $Int (%36 : $Builtin.Word)
  br bb8(%37 : $Int)

bb8(%39 : $Int):
  release_value %0 : $Optional<C>
  return %39 : $Int
}
