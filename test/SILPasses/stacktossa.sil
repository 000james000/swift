// RUN: %sil-opt %s -stack-to-ssa | FileCheck %s

import Builtin
import swift


// CHECK-LABEL: sil @simple_reg_promotion
// This example should be completely promoted away and all allocs deleted.
sil @simple_reg_promotion : $[thin] (a : Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_stack $Int64
  %2 = store %0 to %1#1 : $*Int64
  %3 = alloc_stack $Int64
  %4 = load %1#1 : $*Int64
  %5 = store %4 to %3#1 : $*Int64
  %6 = load %3#1 : $*Int64
  %7 = dealloc_stack %3#0 : $*[local_storage] Int64
  %8 = dealloc_stack %1#0 : $*[local_storage] Int64
  %9 = return %6 : $Int64
  // CHECK: bb0(%0 : $Int64):
  // CHECK-NEXT: return %0 : $Int64
}

sil @takes_Int_inout : $[thin] (a : [inout] Int64) -> ()


// func used_by_inout(a : Int) -> (Int, Int) {
//  var t = a
//  takes_Int_inout(&a)
//  return (t,a)
//}
// CHECK-LABEL: sil @used_by_inout
sil @used_by_inout : $[thin] (a : Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  // This alloc_stack can't be removed since it is used by a inout call.
  // CHECK: %1 = alloc_stack $Int64
  %1 = alloc_stack $Int64
  %2 = store %0 to %1#1 : $*Int64
  
  // This load should be eliminated.
  %3 = load %1#1 : $*Int64
  %5 = function_ref @takes_Int_inout : $[thin] (a : [inout] Int64) -> ()
  %6 = apply %5(%1#1) : $[thin] (a : [inout] Int64) -> ()
  
  // This load is needed in case the callee modifies the allocation.
  // CHECK: [[RES:%[0-9]+]] = load %1
  %7 = load %1#1 : $*Int64
  
  // This should use the incoming argument to the function.
  // CHECK: tuple (%0 : $Int64, [[RES]] : $Int64)
  %8 = tuple (%3 : $Int64, %7 : $Int64)
  %10 = dealloc_stack %1#0 : $*[local_storage] Int64
  %11 = return %8 : $(Int64, Int64)
}
