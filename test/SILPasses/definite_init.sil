// RUN: %sil-opt %s -definite-init -verify | FileCheck %s

import Builtin
import swift


// CHECK-LABEL: sil @simple_reg_promotion
sil @simple_reg_promotion : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):                         // CHECK: bb0(%0 : $Int64):
  %1 = alloc_box $Int64
  store %0 to %1#1 : $*Int64
  %3 = alloc_box $Int64
  %4 = load %1#1 : $*Int64
  store %4 to %3#1 : $*Int64
  %6 = load %3#1 : $*Int64
  strong_release %3#0 : $Builtin.ObjectPointer
  strong_release %1#0 : $Builtin.ObjectPointer
  return %6 : $Int64

  // CHECK-NEXT: return %0 : $Int64
}


// CHECK-LABEL: sil @tuple_reg_promotion
sil @tuple_reg_promotion : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):                         // CHECK: bb0(%0 : $Int64):
  %1 = alloc_box $(Int64, Int64)
  
  %a = tuple_element_addr %1#1 : $*(Int64, Int64), 0
  %b = tuple_element_addr %1#1 : $*(Int64, Int64), 1
  store %0 to %a : $*Int64
  store %0 to %b : $*Int64

  %c = load %1#1 : $*(Int64, Int64)
  %d = tuple_extract %c : $(Int64, Int64), 0

  strong_release %1#0 : $Builtin.ObjectPointer

  return %d : $Int64

  // Verify that promotion has promoted the tuple load away, and we know that
  // %0 is being returned through scalar instructions in SSA form.
  // CHECK-NEXT: [[TUPLE:%[0-9]+]] = tuple ({{.*}} : $Int64, {{.*}} : $Int64)
  // CHECK-NEXT: [[TUPLE_ELT:%[0-9]+]] = tuple_extract [[TUPLE]] : $(Int64, Int64), 0

  // CHECK-NEXT: return [[TUPLE_ELT]] : $Int64
}


// CHECK-LABEL: sil @use_before_init
sil @use_before_init : $@thin () -> Int64 {
bb0:
  %1 = alloc_box $Int64                   // expected-note {{variable defined here}}
  %4 = load %1#1 : $*Int64                // expected-error {{variable '<unknown>' used before being initialized}}
  strong_release %1#0 : $Builtin.ObjectPointer
  %9 = return %4 : $Int64
}


sil @takes_Int_inout : $@thin (@inout Int64) -> ()

// CHECK-LABEL: @inout_uninit
sil @inout_uninit : $@thin () -> () {
bb0:
  %1 = alloc_box $Int64                                   // expected-note {{variable defined here}}

  %5 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %6 = apply %5(%1#1) : $@thin (@inout Int64) -> () // expected-error {{variable '<unknown>' passed by reference before being initialized}}
  
  %0 = tuple ()
  strong_release %1#0 : $Builtin.ObjectPointer
  return %0 : $()
}




// This function shouldn't produce any diagnostics.
//
// func used_by_inout(a : Int) -> (Int, Int) {
//  var t = a
//  takes_Int_inout(&a)
//  return (t,a)
//}
// CHECK-LABEL: sil @used_by_inout
sil @used_by_inout : $@thin (Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  // This alloc_stack can't be removed since it is used by a inout call.
  // CHECK: %1 = alloc_box $Int64
  %1 = alloc_box $Int64
  %2 = store %0 to %1#1 : $*Int64
  
  // This load should be eliminated.
  %3 = load %1#1 : $*Int64
  %5 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %6 = apply %5(%1#1) : $@thin (@inout Int64) -> ()
  
  // This load is needed in case the callee modifies the allocation.
  // CHECK: [[RES:%[0-9]+]] = load
  %7 = load %1#1 : $*Int64
  
  // This should use the incoming argument to the function.
  // CHECK: tuple ({{.*}} : $Int64, {{.*}} : $Int64)
  %8 = tuple (%3 : $Int64, %7 : $Int64)
  strong_release %1#0 : $Builtin.ObjectPointer
  %11 = return %8 : $(Int64, Int64)
}


struct AddressOnlyStruct {
  var a : protocol<>
  var b : Int
}

/// returns_generic_struct - This returns a struct by reference.
sil @returns_generic_struct : $@thin (@out AddressOnlyStruct) -> ()

// There should be no error in this function.
// CHECK-LABEL: sil @call_struct_return_function
sil @call_struct_return_function : $@thin () -> Int64 {
bb0:
  %1 = alloc_box $AddressOnlyStruct
  %2 = function_ref @returns_generic_struct : $@thin (@out AddressOnlyStruct) -> ()
  %3 = apply %2(%1#1) : $@thin (@out AddressOnlyStruct) -> ()
  %4 = struct_element_addr %1#1 : $*AddressOnlyStruct, #b
  %5 = load %4 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %5 : $Int64
}


// CHECK-LABEL: sil @tuple_elements1
sil @tuple_elements1 : $@thin (Int64) -> () {
bb0(%0 : $Int64):
  %3 = alloc_box $(Int64, Int64)     // expected-note 1 {{variable defined here}}
  %4 = tuple_element_addr %3#1 : $*(Int64, Int64), 0
  %5 = tuple_element_addr %3#1 : $*(Int64, Int64), 1
  %14 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %15 = tuple_element_addr %3#1 : $*(Int64, Int64), 1
  %16 = apply %14(%15) : $@thin (@inout Int64) -> ()  // expected-error {{variable '<unknown>.1' passed by reference before being initialized}}

  strong_release %3#0 : $Builtin.ObjectPointer
  %99 = tuple ()
  return %99 : $()
}

// CHECK-LABEL: sil @tuple_elements2
sil @tuple_elements2 : $@thin (Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  %3 = alloc_box $(Int64, Int64)     // expected-note {{variable defined here}}
  %18 = tuple_element_addr %3#1 : $*(Int64, Int64), 0
  store %0 to %18 : $*Int64
  %20 = load %3#1 : $*(Int64, Int64) // expected-error {{variable '<unknown>.1' used before being initialized}}
  %21 = tuple_extract %20 : $(Int64, Int64), 0
  %22 = tuple_extract %20 : $(Int64, Int64), 1
  %23 = tuple (%21 : $Int64, %22 : $Int64)
  strong_release %3#0 : $Builtin.ObjectPointer
  return %23 : $(Int64, Int64)
}



// CHECK-LABEL: sil @copy_addr1
sil @copy_addr1 : $@thin <T> (@out T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T):
  %4 = alloc_box $T
  copy_addr [take] %1 to [initialization] %4#1 : $*T
  copy_addr %4#1 to [initialization] %0 : $*T
  strong_release %4#0 : $Builtin.ObjectPointer
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @copy_addr2
sil @copy_addr2 : $@thin <T> (@out T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T):
  %4 = alloc_box $T         // expected-note {{variable defined here}}
  copy_addr %4#1 to [initialization] %0 : $*T   // expected-error {{variable '<unknown>' used before being initialized}}
  strong_release %4#0 : $Builtin.ObjectPointer
  %9 = tuple ()
  return %9 : $()
}


sil @takes_closure : $@thin (@callee_owned () -> ()) -> ()
sil @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()

// CHECK-LABEL: sil @closure_test
sil @closure_test : $@thin () -> () {
bb0:
  %0 = alloc_box $Int64    // expected-note {{variable defined here}}

  %5 = function_ref @takes_closure : $@thin (@callee_owned () -> ()) -> ()
  %6 = function_ref @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  %8 = partial_apply %6(%0#0, %0#1) : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()  // expected-error {{variable '<unknown>' captured by a closure before being initialized}}
  %9 = apply %5(%8) : $@thin (@callee_owned () -> ()) -> ()
  strong_release %0#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil @closure_test2
sil @closure_test2 : $@thin (Int64) -> Int64 {
bb0(%1 : $Int64):
  %0 = alloc_box $Int64
  store %1 to %0#1 : $*Int64  // CHECK: store

  %5 = function_ref @takes_closure : $@thin (@callee_owned () -> ()) -> ()
  %6 = function_ref @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  %8 = partial_apply %6(%0#0, %0#1) : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()
  %9 = apply %5(%8) : $@thin (@callee_owned () -> ()) -> ()
  strong_release %0#0 : $Builtin.ObjectPointer

  store %1 to %0#1 : $*Int64 // CHECK: store

  // In an escape region, we should not promote loads.
  %r = load %0#1 : $*Int64 // CHECK: load
  return %r : $Int64
}



class SomeClass {}

sil @getSomeClass : $@thin () -> @owned SomeClass


// CHECK-LABEL: sil @assign_test_trivial
sil @assign_test_trivial : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_box $Int64

  // These assigns are a mix of init + store forms, but because Int is trivial,
  // they all turn into stores.
  assign %0 to %1#1 : $*Int64
  assign %0 to %1#1 : $*Int64
  assign %0 to %1#1 : $*Int64

  %2 = load %1#1 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer

  // Verify that the load got forwarded from an assign.
  return %2 : $Int64                        // CHECK: return %0 : $Int64
}

// CHECK-LABEL: sil @assign_test_nontrivial
sil @assign_test_nontrivial : $@thin () -> () {
bb0:
  // Assignments of nontrivial types.  The first becomes an initialize (i.e.,
  // lone store), the second becomes an assignment (retain/release dance).

  %c = alloc_box $SomeClass
  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass

  %4 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  assign %4 to %c#1 : $*SomeClass

  %8 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  assign %8 to %c#1 : $*SomeClass
  destroy_addr %c#1 : $*SomeClass
  dealloc_box $SomeClass, %c#0 : $Builtin.ObjectPointer
  // CHECK-NEXT: strong_release [[C1]]
  // CHECK-NEXT: strong_release [[C2]]

  %11 = tuple ()
  return %11 : $()
}


// CHECK-LABEL: sil @assign_test_addressonly
sil @assign_test_addressonly : $@thin <T> (@out T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T):
  %2 = alloc_box $T
  // CHECK: alloc_box

  // This should become an initialization of %4
  copy_addr %1 to %2#1 : $*T
  // CHECK-NEXT: copy_addr %1 to [initialization] %2#1 : $*T

  // This should stay an assignment of %4
  copy_addr [take] %1 to %2#1 : $*T
  // CHECK-NEXT: copy_addr [take] %1 to %2#1 : $*T
  
  // This is a load, and shouldn't be changed.
  copy_addr %2#1 to [initialization] %0 : $*T
  // CHECK-NEXT: copy_addr %2#1 to [initialization] %0 : $*T

  strong_release %2#0 : $Builtin.ObjectPointer
  // CHECK-NEXT: strong_release %2#0
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @assign_test_weak
sil @assign_test_weak : $@thin() -> () {
bb0:
  // Assignments of weak pointer.  The first becomes an initialize, and the
  // second becomes an assignment.

  %c = alloc_box $@sil_weak SomeClass  // expected-note {{variable defined here}}
  
  // Invalid load to keep the alloc_box around so we can check init semantics.
  load %c#1 : $*@sil_weak SomeClass    // expected-error {{used before being initialized}}

  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass

  %4 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  // THis should become an initialization.
  store_weak %4 to %c#1 : $*@sil_weak SomeClass
  // CHECK-NEXT: store_weak [[C1]] to [initialization] %0#1

  strong_release %4 : $SomeClass
  // CHECK-NEXT: release [[C1]]

  %8 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  store_weak %8 to %c#1 : $*@sil_weak SomeClass
  // CHECK-NEXT: store_weak [[C2]] to %0#1

  strong_release %8 : $SomeClass
  // CHECK-NEXT: release [[C2]]

  strong_release %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil @assign_test_unowned
sil @assign_test_unowned : $@thin() -> () {
bb0:
  // Assignments of unowned pointer.  The first becomes an initialize, and the
  // second becomes an assignment.

  %c = alloc_box $@sil_unowned SomeClass

  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass

  %4 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  // This should become an initialization.
  %5 = ref_to_unowned %4 : $SomeClass to $@sil_unowned SomeClass
  unowned_retain %5 : $@sil_unowned SomeClass
  assign %5 to %c#1 : $*@sil_unowned SomeClass
  strong_release %4 : $SomeClass
  // CHECK-NEXT: [[C1u:%[0-9]+]] = ref_to_unowned [[C1]]
  // CHECK-NEXT: unowned_retain [[C1u]]
  // CHECK-NEXT: strong_release [[C1]]

  %8 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  %9 = ref_to_unowned %8 : $SomeClass to $@sil_unowned SomeClass
  unowned_retain %9 : $@sil_unowned SomeClass
  assign %9 to %c#1 : $*@sil_unowned SomeClass
  strong_release %8 : $SomeClass
  // CHECK: [[C2u:%[0-9]+]] = ref_to_unowned [[C2]]
  // CHECK-NEXT: unowned_retain [[C2u]]
  // CHECK-NEXT: unowned_release [[C1u]]
  // CHECK-NEXT: strong_release [[C2]]

  destroy_addr %c#1 : $*@sil_unowned SomeClass
  dealloc_box $SomeClass, %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}



struct ContainsObjectPointer {
  var x : Int 
  var y : Builtin.ObjectPointer
}

sil @test_struct : $@thin (@inout ContainsObjectPointer) -> () {
bb0(%0 : $*ContainsObjectPointer):
  %b = alloc_box $ContainsObjectPointer
  %1 = load %0 : $*ContainsObjectPointer
  assign %1 to %b#1 : $*ContainsObjectPointer
  
  strong_release %b#0 : $Builtin.ObjectPointer
  %x = tuple ()
  return %x : $()
}

// CHECK-LABEL: sil @non_box_assign_trivial
// CHECK-NOT: load
// CHECK: store
// CHECK: return
sil @non_box_assign_trivial : $@thin (@inout Bool, Bool) -> () {
bb0(%0 : $*Bool, %1 : $Bool):
  assign %1 to %0 : $*Bool
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @non_box_assign
// CHECK: load
// CHECK: store
// CHECK: return
sil @non_box_assign : $@thin (@inout SomeClass, @owned SomeClass) -> () {
bb0(%0 : $*SomeClass, %1 : $SomeClass):
  assign %1 to %0 : $*SomeClass
  %9 = tuple ()
  return %9 : $()
}

var int_global : Int


// CHECK-LABEL: sil @test_tlc
// CHECK-NOT: mark_uninitialized
// CHECK: return
sil @test_tlc : $() -> () {
  %0 = global_addr #int_global : $*Int64
  %1 = mark_uninitialized %0 : $*Int64

  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @promote_alloc_stack
sil @promote_alloc_stack : $@thin (Int64) -> Builtin.Int64 {
bb0(%0 : $Int64):
  %5 = integer_literal $Builtin.Int64, 1
  // CHECK: [[IL:%[0-9]+]] = integer_literal

  %18 = struct $Int64 (%5 : $Builtin.Int64)
  %22 = alloc_stack $Int64

  // CHECK-NOT: alloc_stack

  store %18 to %22#1 : $*Int64
  %24 = struct_element_addr %22#1 : $*Int64, #value
  %25 = load %24 : $*Builtin.Int64
  dealloc_stack %22#0 : $*@local_storage Int64
  // CHECK-NEXT: return [[IL]]
  return %25 : $Builtin.Int64
}

// CHECK-LABEL: sil @copy_addr_to_load
sil @copy_addr_to_load : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):               // CHECK: bb0(%0 : $Int64):
  %1 = alloc_stack $Int64
  store %0 to %1#1 : $*Int64
  %2 = alloc_stack $Int64
  
  copy_addr %1#1 to [initialization] %2#1 : $*Int64

  %3 = load %2#1 : $*Int64

  dealloc_stack %2#0 : $*@local_storage Int64
  dealloc_stack %1#0 : $*@local_storage Int64
  // CHECK-NEXT: return %0
  return %3 : $Int64
}

// rdar://15170149
// CHECK-LABEL: sil @store_to_copyaddr
sil @store_to_copyaddr : $(Bool) -> Bool {
bb0(%0 : $Bool):  // CHECK: bb0(%0 :
  %1 = alloc_stack $Bool
  store %0 to %1#1 : $*Bool
  %3 = alloc_stack $Bool
  copy_addr %1#1 to [initialization] %3#1 : $*Bool
  %5 = load %3#1 : $*Bool
  copy_addr %3#1 to %1#1 : $*Bool
  %12 = load %1#1 : $*Bool
  dealloc_stack %3#0 : $*@local_storage Bool
  dealloc_stack %1#0 : $*@local_storage Bool
  return %12 : $Bool                              // CHECK-NEXT: return %0
}

// CHECK-LABEL: sil @cross_block_load_promotion
sil @cross_block_load_promotion : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_stack $Int64
  store %0 to %1#1 : $*Int64
  %11 = integer_literal $Builtin.Int1, 1
  cond_br %11, bb1, bb2

bb1:
  br bb5

bb2:
  br bb5

bb5:
  %15 = load %1#1 : $*Int64
  dealloc_stack %1#0 : $*@local_storage Int64
  return %15 : $Int64

// CHECK: return %0 : $Int64
}

struct XYStruct { var x, y : Int }
sil @init_xy_struct : $@thin () -> XYStruct


// CHECK-LABEL: sil @cross_block_load_promotion_struct
sil @cross_block_load_promotion_struct : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %2 : $Int64):
  %1 = alloc_stack $XYStruct
  
  %7 = function_ref @init_xy_struct : $@thin () -> XYStruct
  %9 = apply %7() : $@thin () -> XYStruct
  store %9 to %1#1 : $*XYStruct

  %11 = struct_element_addr %1#1 : $*XYStruct, #y
  store %0 to %11 : $*Int64

  %12 = integer_literal $Builtin.Int1, 1          // user: %3
  cond_br %12, bb1, bb2

bb1:                                              // Preds: bb3
  %13 = struct_element_addr %1#1 : $*XYStruct, #x
  store %2 to %13 : $*Int64
  br bb5

bb2:                                              // Preds: bb0
  br bb5

bb5:                                              // Preds: bb4
  %15 = load %11 : $*Int64
  dealloc_stack %1#0 : $*@local_storage XYStruct
  return %15 : $Int64

// CHECK: return %0 : $Int64
}

// CHECK-LABEL: sil @cross_block_load_promotion_struct2
sil @cross_block_load_promotion_struct2 : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %2 : $Int64):
  %1 = alloc_stack $XYStruct
  
  %7 = function_ref @init_xy_struct : $@thin () -> XYStruct
  %9 = apply %7() : $@thin () -> XYStruct
  store %9 to %1#1 : $*XYStruct

  %11 = struct_element_addr %1#1 : $*XYStruct, #x
  store %0 to %11 : $*Int64

  %12 = integer_literal $Builtin.Int1, 1          // user: %3
  cond_br %12, bb1, bb2

bb1:                                              // Preds: bb3
  %13 = struct_element_addr %1#1 : $*XYStruct, #x
  store %0 to %13 : $*Int64
  br bb5

bb2:                                              // Preds: bb0
  br bb5

bb5:                                              // Preds: bb4
  %15 = load %11 : $*Int64
  dealloc_stack %1#0 : $*@local_storage XYStruct
  return %15 : $Int64

// CHECK: return %0 : $Int64
}


// CHECK-LABEL: sil @destroy_addr
sil @destroy_addr : $@cc(method) @thin (@owned SomeClass) -> @owned SomeClass {
bb0(%0 : $SomeClass):
  %1 = alloc_stack $SomeClass
  %2 = tuple ()
  store %0 to %1#1 : $*SomeClass
  %7 = load %1#1 : $*SomeClass
  strong_retain %7 : $SomeClass
  strong_release %7 : $SomeClass
  %12 = load %1#1 : $*SomeClass                   // users: %16, %13
  strong_retain %12 : $SomeClass                  // id: %13
  destroy_addr %1#1 : $*SomeClass                 // id: %14
  dealloc_stack %1#0 : $*@local_storage SomeClass // id: %15
  return %12 : $SomeClass                         // id: %16
}


protocol P {}
class C : P {}

sil @use : $@thin (@in P) -> ()


// rdar://15379013
// CHECK-LABEL: sil @init_existential_with_class
sil @init_existential_with_class : $@thin (@inout C) -> () {
entry(%a : $*C):
  %p = alloc_stack $P
  %q = init_existential %p#1 : $*P, $*C
  
  // CHECK: copy_addr {{.*}} to [initialization] %2 : $*C
  copy_addr %a to [initialization] %q : $*C
  %u = function_ref @use : $@thin (@in P) -> ()
  %v = apply %u(%p#1) : $@thin (@in P) -> ()
  dealloc_stack %p#0 : $*@local_storage P
  %z = tuple ()
  return %z : $()
}


// rdar://15492647
// CHECK-LABEL: sil @destroy_addr_removed
sil @destroy_addr_removed : $@thin () -> () {
bb0:
  %3 = alloc_stack $SomeClass
  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %9 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[CVAL:%[0-9]+]] = apply

  assign %9 to %3#1 : $*SomeClass
  destroy_addr %3#1 : $*SomeClass
  dealloc_stack %3#0 : $*@local_storage SomeClass
  %15 = tuple ()
  return %15 : $()
// CHECK-NEXT: strong_release [[CVAL]]
}

// CHECK-LABEL: sil @release_not_constructed
sil @release_not_constructed : $@thin () -> () {
bb0:  // CHECK: bb0:
  %3 = alloc_stack $SomeClass
  destroy_addr %3#1 : $*SomeClass
  dealloc_stack %3#0 : $*@local_storage SomeClass
  
   // CHECK-NEXT: tuple ()
  %15 = tuple ()
  return %15 : $()
}

// CHECK-LABEL: sil @release_some_constructed
sil @release_some_constructed : $@thin () -> () {
bb0:
  %0 = tuple ()
  %1 = alloc_stack $(SomeClass, SomeClass)
  %2 = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %3 = apply %2() : $@thin () -> @owned SomeClass
  %4 = tuple_element_addr %1#1 : $*(SomeClass, SomeClass), 0
  store %3 to %4 : $*SomeClass

  destroy_addr %1#1 : $*(SomeClass, SomeClass)
  dealloc_stack %1#0 : $*@local_storage (SomeClass, SomeClass)
  %8 = tuple ()
  return %8 : $()

// Only Element #0 should get released.  This should just be turned into
// release(apply())

// CHECK-NOT: alloc_stack
// CHECK: [[V:%[0-9]+]] = apply
// CHECK-NEXT: strong_release [[V]]
// CHECK-NOT: store
// CHECK-NOT: strong_release
// CHECK-NOT: dealloc_stack
}

// CHECK-LABEL: sil @conditional_init
// This test checks conditional destruction logic.  Because the value is only
// initialized on some paths, we need to either hoist up the destroy_addr or 
// emit a boolean control value to make sure the value is only destroyed if
//  actually initialized.
sil @conditional_init : $@thin (Bool) -> () {
bb0(%0 : $Bool):
  %3 = alloc_stack $SomeClass
// CHECK: [[CONTROL:%[0-9]+]] = alloc_stack $Builtin.Int1
// CHECK: [[ZERO:%[0-9]+]] = integer_literal $Builtin.Int1, 0
// CHECK: store [[ZERO]] to [[CONTROL]]#1 : $*Builtin.Int1
  %5 = integer_literal $Builtin.Int1, 1
  cond_br %5, bb1, bb2

bb1:
// CHECK: bb1:
// CHECK: function_ref @getSomeClass
// CHECK: [[ONE:%[0-9]+]] = integer_literal $Builtin.Int1, -1
// CHECK: store [[ONE]] to [[CONTROL]]#1 : $*Builtin.Int1
  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %6 = apply %f() : $@thin () -> @owned SomeClass
  assign %6 to %3#1 : $*SomeClass
  br bb2

bb2:
  destroy_addr %3#1 : $*SomeClass
  dealloc_stack %3#0 : $*@local_storage SomeClass
  %14 = tuple ()
  return %14 : $()
}

// CHECK-LABEL: sil @conditionalInitOrAssign
sil @conditionalInitOrAssign : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  // CHECK: [[CONTROL:%[0-9]+]] = alloc_stack $Builtin.Int1
  // CHECK: [[CLASSVAL:%[0-9]+]] = alloc_stack $SomeClass
  // CHECK: integer_literal $Builtin.Int1, 0
  // CHECK: store
  %6 = alloc_stack $SomeClass
  cond_br %0, bb1, bb2

bb1:
  // CHECK: = function_ref
  %2 = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[V1:%[0-9]+]] = apply
  %12 = apply %2() : $@thin () -> @owned SomeClass

  // This assign becomes a simple store, since it is an initialize. This updates
  // the control variable to say that it is initialized.
  // CHECK: integer_literal $Builtin.Int1, -1
  // CHECK: store {{.*}} to [[CONTROL]]
  // CHECK: store [[V1]] to [[CLASSVAL]]
  assign %12 to %6#1 : $*SomeClass                // id: %13
  br bb2                                          // id: %14

bb2:
  // CHECK: = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %3 = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[V2:%[0-9]+]] = apply
  %17 = apply %3() : $@thin () -> @owned SomeClass
  
  // This assign is either an initialize or an assign depending on whether %0 is
  // true or not.  This gets expanded out to a conditional destroy of the value.
  // CHECK:   load [[CONTROL]]
  // CHECK:   cond_br
  // CHECK: bb3:
  // CHECK:   destroy_addr [[CLASSVAL]]
  // CHECK:   br bb4
  // CHECK: bb4:
  // CHECK: store [[V2]] to [[CLASSVAL]]

  assign %17 to %6#1 : $*SomeClass                // id: %18
  destroy_addr %6#1 : $*SomeClass                 // id: %19
  dealloc_stack %6#0 : $*@local_storage SomeClass // id: %20
  %23 = tuple ()                                  // user: %24
  return %23 : $()                                // id: %24
}


