// RUN: %sil-opt %s -definite-init -verify | FileCheck %s

import Builtin
import swift


sil @takes_Int_inout : $@thin (@inout Int64) -> ()
sil @makesInt : $@thin () -> Int64



// CHECK-LABEL: sil @use_before_init
sil @use_before_init : $@thin () -> Int64 {
bb0:
  %1 = alloc_box $Int64                   // expected-note {{variable defined here}}
  %4 = load %1#1 : $*Int64                // expected-error {{variable '<unknown>' used before being initialized}}
  strong_release %1#0 : $Builtin.ObjectPointer
  %9 = return %4 : $Int64
}


// CHECK-LABEL: @inout_uninit
sil @inout_uninit : $@thin () -> () {
bb0:
  %1 = alloc_box $Int64                                   // expected-note {{variable defined here}}

  %5 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %6 = apply %5(%1#1) : $@thin (@inout Int64) -> () // expected-error {{variable '<unknown>' passed by reference before being initialized}}
  
  %0 = tuple ()
  strong_release %1#0 : $Builtin.ObjectPointer
  return %0 : $()
}




// This function shouldn't produce any diagnostics.
//
// func used_by_inout(a : Int) -> (Int, Int) {
//  var t = a
//  takes_Int_inout(&a)
//  return (t,a)
//}
// CHECK-LABEL: sil @used_by_inout
sil @used_by_inout : $@thin (Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  %1 = alloc_box $Int64
  %2 = store %0 to %1#1 : $*Int64
  %3 = load %1#1 : $*Int64
  %5 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %6 = apply %5(%1#1) : $@thin (@inout Int64) -> ()
  %7 = load %1#1 : $*Int64
  %8 = tuple (%3 : $Int64, %7 : $Int64)
  strong_release %1#0 : $Builtin.ObjectPointer
  %11 = return %8 : $(Int64, Int64)
}


struct AddressOnlyStruct {
  var a : protocol<>
  var b : Int
}

/// returns_generic_struct - This returns a struct by reference.
sil @returns_generic_struct : $@thin (@out AddressOnlyStruct) -> ()

// There should be no error in this function.
// CHECK-LABEL: sil @call_struct_return_function
sil @call_struct_return_function : $@thin () -> Int64 {
bb0:
  %1 = alloc_box $AddressOnlyStruct
  %2 = function_ref @returns_generic_struct : $@thin (@out AddressOnlyStruct) -> ()
  %3 = apply %2(%1#1) : $@thin (@out AddressOnlyStruct) -> ()
  %4 = struct_element_addr %1#1 : $*AddressOnlyStruct, #b
  %5 = load %4 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %5 : $Int64
}


// CHECK-LABEL: sil @tuple_elements1
sil @tuple_elements1 : $@thin (Int64) -> () {
bb0(%0 : $Int64):
  %3 = alloc_box $(Int64, Int64)     // expected-note 1 {{variable defined here}}
  %4 = tuple_element_addr %3#1 : $*(Int64, Int64), 0
  %5 = tuple_element_addr %3#1 : $*(Int64, Int64), 1
  %14 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %15 = tuple_element_addr %3#1 : $*(Int64, Int64), 1
  %16 = apply %14(%15) : $@thin (@inout Int64) -> ()  // expected-error {{variable '<unknown>.1' passed by reference before being initialized}}

  strong_release %3#0 : $Builtin.ObjectPointer
  %99 = tuple ()
  return %99 : $()
}

// CHECK-LABEL: sil @tuple_elements2
sil @tuple_elements2 : $@thin (Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  %3 = alloc_box $(Int64, Int64)     // expected-note {{variable defined here}}
  %18 = tuple_element_addr %3#1 : $*(Int64, Int64), 0
  store %0 to %18 : $*Int64
  %20 = load %3#1 : $*(Int64, Int64) // expected-error {{variable '<unknown>.1' used before being initialized}}
  %21 = tuple_extract %20 : $(Int64, Int64), 0
  %22 = tuple_extract %20 : $(Int64, Int64), 1
  %23 = tuple (%21 : $Int64, %22 : $Int64)
  strong_release %3#0 : $Builtin.ObjectPointer
  return %23 : $(Int64, Int64)
}



// CHECK-LABEL: sil @copy_addr1
sil @copy_addr1 : $@thin <T> (@out T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T):
  %4 = alloc_box $T
  copy_addr [take] %1 to [initialization] %4#1 : $*T
  copy_addr %4#1 to [initialization] %0 : $*T
  strong_release %4#0 : $Builtin.ObjectPointer
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @copy_addr2
sil @copy_addr2 : $@thin <T> (@out T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T):
  %4 = alloc_box $T         // expected-note {{variable defined here}}
  copy_addr %4#1 to [initialization] %0 : $*T   // expected-error {{variable '<unknown>' used before being initialized}}
  strong_release %4#0 : $Builtin.ObjectPointer
  %9 = tuple ()
  return %9 : $()
}


sil @takes_closure : $@thin (@callee_owned () -> ()) -> ()
sil @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()

// CHECK-LABEL: sil @closure_test
sil @closure_test : $@thin () -> () {
bb0:
  %0 = alloc_box $Int64    // expected-note {{variable defined here}}

  %5 = function_ref @takes_closure : $@thin (@callee_owned () -> ()) -> ()
  %6 = function_ref @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  %8 = partial_apply %6(%0#0, %0#1) : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()  // expected-error {{variable '<unknown>' captured by a closure before being initialized}}
  %9 = apply %5(%8) : $@thin (@callee_owned () -> ()) -> ()
  strong_release %0#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}


class SomeClass {}

sil @getSomeClass : $@thin () -> @owned SomeClass


// CHECK-LABEL: sil @assign_test_trivial
sil @assign_test_trivial : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_box $Int64

  // These assigns are a mix of init + store forms, but because Int is trivial,
  // they all turn into stores.
  assign %0 to %1#1 : $*Int64
  assign %0 to %1#1 : $*Int64
  assign %0 to %1#1 : $*Int64

  %2 = load %1#1 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer

  return %2 : $Int64
}

// CHECK-LABEL: sil @assign_test_nontrivial
sil @assign_test_nontrivial : $@thin () -> () {
bb0:
  // Assignments of nontrivial types.  The first becomes an initialize (i.e.,
  // lone store), the second becomes an assignment (retain/release dance).

  %c = alloc_box $SomeClass
  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass

  %4 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  assign %4 to %c#1 : $*SomeClass
  // CHECK-NEXT: store

  %8 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  assign %8 to %c#1 : $*SomeClass
  // CHECK-NEXT: load
  // CHECK-NEXT: store [[C2]]
  // CHECK-NEXT: strong_release

  destroy_addr %c#1 : $*SomeClass
  // CHECK-NEXT: destroy_addr
  dealloc_box $SomeClass, %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}


// CHECK-LABEL: sil @assign_test_addressonly
sil @assign_test_addressonly : $@thin <T> (@out T, @in T) -> () {
bb0(%0 : $*T, %1 : $*T):
  %2 = alloc_box $T
  // CHECK: alloc_box

  // This should become an initialization of %4
  copy_addr %1 to %2#1 : $*T
  // CHECK-NEXT: copy_addr %1 to [initialization] %2#1 : $*T

  // This should stay an assignment of %4
  copy_addr [take] %1 to %2#1 : $*T
  // CHECK-NEXT: copy_addr [take] %1 to %2#1 : $*T
  
  // This is a load, and shouldn't be changed.
  copy_addr %2#1 to [initialization] %0 : $*T
  // CHECK-NEXT: copy_addr %2#1 to [initialization] %0 : $*T

  strong_release %2#0 : $Builtin.ObjectPointer
  // CHECK-NEXT: strong_release %2#0
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @assign_test_weak
sil @assign_test_weak : $@thin() -> () {
bb0:
  // Assignments of weak pointer.  The first becomes an initialize, and the
  // second becomes an assignment.

  %c = alloc_box $@sil_weak SomeClass  // expected-note {{variable defined here}}
  
  // Invalid load to keep the alloc_box around so we can check init semantics.
  load %c#1 : $*@sil_weak SomeClass    // expected-error {{used before being initialized}}

  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass

  %4 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  // THis should become an initialization.
  store_weak %4 to %c#1 : $*@sil_weak SomeClass
  // CHECK-NEXT: store_weak [[C1]] to [initialization] %0#1

  strong_release %4 : $SomeClass
  // CHECK-NEXT: release [[C1]]

  %8 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  store_weak %8 to %c#1 : $*@sil_weak SomeClass
  // CHECK-NEXT: store_weak [[C2]] to %0#1

  strong_release %8 : $SomeClass
  // CHECK-NEXT: release [[C2]]

  strong_release %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil @assign_test_unowned
sil @assign_test_unowned : $@thin() -> () {
bb0:
  // Assignments of unowned pointer.  The first becomes an initialize, and the
  // second becomes an assignment.

  %c = alloc_box $@sil_unowned SomeClass

  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass

  %4 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  // This should become an initialization.
  %5 = ref_to_unowned %4 : $SomeClass to $@sil_unowned SomeClass
  // CHECK-NEXT: [[C1u:%[0-9]+]] = ref_to_unowned [[C1]]
  unowned_retain %5 : $@sil_unowned SomeClass
  // CHECK-NEXT: unowned_retain [[C1u]]
  assign %5 to %c#1 : $*@sil_unowned SomeClass
  // CHECK-NEXT: store [[C1u]]
  strong_release %4 : $SomeClass
  // CHECK-NEXT: strong_release [[C1]]

  %8 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  %9 = ref_to_unowned %8 : $SomeClass to $@sil_unowned SomeClass
  // CHECK: [[C2u:%[0-9]+]] = ref_to_unowned [[C2]]

  unowned_retain %9 : $@sil_unowned SomeClass
  // CHECK-NEXT: unowned_retain [[C2u]]

  assign %9 to %c#1 : $*@sil_unowned SomeClass
  // CHECK-NEXT: load
  // CHECK-NEXT: store
  // CHECK-NEXT: unowned_release

  strong_release %8 : $SomeClass
  // CHECK-NEXT: strong_release [[C2]]

  destroy_addr %c#1 : $*@sil_unowned SomeClass
  dealloc_box $SomeClass, %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}



struct ContainsObjectPointer {
  var x : Int 
  var y : Builtin.ObjectPointer
}

sil @test_struct : $@thin (@inout ContainsObjectPointer) -> () {
bb0(%0 : $*ContainsObjectPointer):
  %b = alloc_box $ContainsObjectPointer
  %1 = load %0 : $*ContainsObjectPointer
  assign %1 to %b#1 : $*ContainsObjectPointer
  
  strong_release %b#0 : $Builtin.ObjectPointer
  %x = tuple ()
  return %x : $()
}

// CHECK-LABEL: sil @non_box_assign_trivial
// CHECK-NOT: load
// CHECK: store
// CHECK: return
sil @non_box_assign_trivial : $@thin (@inout Bool, Bool) -> () {
bb0(%0 : $*Bool, %1 : $Bool):
  assign %1 to %0 : $*Bool
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @non_box_assign
// CHECK: load
// CHECK: store
// CHECK: return
sil @non_box_assign : $@thin (@inout SomeClass, @owned SomeClass) -> () {
bb0(%0 : $*SomeClass, %1 : $SomeClass):
  assign %1 to %0 : $*SomeClass
  %9 = tuple ()
  return %9 : $()
}

var int_global : Int


// CHECK-LABEL: sil @test_tlc
// CHECK-NOT: mark_uninitialized
// CHECK: return
sil @test_tlc : $() -> () {
  %0 = global_addr #int_global : $*Int64
  %1 = mark_uninitialized [globalvar] %0 : $*Int64

  %9 = tuple ()
  return %9 : $()
}


struct XYStruct { var x, y : Int }
sil @init_xy_struct : $@thin () -> XYStruct



protocol P {}
class C : P {}

sil @use : $@thin (@in P) -> ()


// CHECK-LABEL: sil @release_not_constructed
sil @release_not_constructed : $@thin () -> () {
bb0:  // CHECK: bb0:
  %3 = alloc_stack $SomeClass
  // CHECK-NEXT: alloc_stack

  // This should get removed.
  destroy_addr %3#1 : $*SomeClass

  dealloc_stack %3#0 : $*@local_storage SomeClass
  // CHECK-NEXT: dealloc_stack

   // CHECK-NEXT: tuple ()
  %15 = tuple ()
  return %15 : $()
}

// CHECK-LABEL: sil @release_some_constructed
sil @release_some_constructed : $@thin () -> () {
bb0:
  %0 = tuple ()
  %1 = alloc_stack $(SomeClass, SomeClass)
  %2 = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %3 = apply %2() : $@thin () -> @owned SomeClass
  %4 = tuple_element_addr %1#1 : $*(SomeClass, SomeClass), 0
  store %3 to %4 : $*SomeClass
  // CHECK: store

  // Only Element #0 should get released.

  // CHECK-NEXT: [[ELT0:%[0-9]+]] = tuple_element_addr {{.*}}, 0
  // CHECK-NEXT: destroy_addr [[ELT0]]
  destroy_addr %1#1 : $*(SomeClass, SomeClass)
  
  // CHECK-NEXT: dealloc_stack
  dealloc_stack %1#0 : $*@local_storage (SomeClass, SomeClass)
  %8 = tuple ()
  return %8 : $()
}



// rdar://15379013
// CHECK-LABEL: sil @init_existential_with_class
sil @init_existential_with_class : $@thin (@inout C) -> () {
entry(%a : $*C):
  %p = alloc_stack $P
  %q = init_existential %p#1 : $*P, $*C
  
  // CHECK: copy_addr {{.*}} to [initialization] %2 : $*C
  copy_addr %a to [initialization] %q : $*C
  %u = function_ref @use : $@thin (@in P) -> ()
  %v = apply %u(%p#1) : $@thin (@in P) -> ()
  dealloc_stack %p#0 : $*@local_storage P
  %z = tuple ()
  return %z : $()
}

// CHECK-LABEL: sil @conditional_init
// This test checks conditional destruction logic.  Because the value is only
// initialized on some paths, we need to either hoist up the destroy_addr or 
// emit a boolean control value to make sure the value is only destroyed if
//  actually initialized.
sil @conditional_init : $@thin (Bool) -> () {
bb0(%0 : $Bool):
  %3 = alloc_stack $SomeClass
// CHECK: [[CONTROL:%[0-9]+]] = alloc_stack $Builtin.Int1
// CHECK: [[ZERO:%[0-9]+]] = integer_literal $Builtin.Int1, 0
// CHECK: store [[ZERO]] to [[CONTROL]]#1 : $*Builtin.Int1
  %5 = integer_literal $Builtin.Int1, 1
  cond_br %5, bb1, bb2

bb1:
// CHECK: bb1:
// CHECK: function_ref @getSomeClass
// CHECK: [[ONE:%[0-9]+]] = integer_literal $Builtin.Int1, -1
// CHECK: store [[ONE]] to [[CONTROL]]#1 : $*Builtin.Int1
  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %6 = apply %f() : $@thin () -> @owned SomeClass
  assign %6 to %3#1 : $*SomeClass
  br bb2

bb2:
  destroy_addr %3#1 : $*SomeClass
  dealloc_stack %3#0 : $*@local_storage SomeClass
  %14 = tuple ()
  return %14 : $()
}

// CHECK-LABEL: sil @conditionalInitOrAssign
sil @conditionalInitOrAssign : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  // CHECK: [[CONTROL:%[0-9]+]] = alloc_stack $Builtin.Int1
  // CHECK: [[CLASSVAL:%[0-9]+]] = alloc_stack $SomeClass
  // CHECK: integer_literal $Builtin.Int1, 0
  // CHECK: store
  %6 = alloc_stack $SomeClass
  cond_br %0, bb1, bb2

bb1:
  // CHECK: = function_ref
  %2 = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[V1:%[0-9]+]] = apply
  %12 = apply %2() : $@thin () -> @owned SomeClass

  // This assign becomes a simple store, since it is an initialize. This updates
  // the control variable to say that it is initialized.
  // CHECK: integer_literal $Builtin.Int1, -1
  // CHECK: store {{.*}} to [[CONTROL]]
  // CHECK: store [[V1]] to [[CLASSVAL]]
  assign %12 to %6#1 : $*SomeClass                // id: %13
  br bb2                                          // id: %14

bb2:
  // CHECK: = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %3 = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  // CHECK-NEXT: [[V2:%[0-9]+]] = apply
  %17 = apply %3() : $@thin () -> @owned SomeClass
  
  // This assign is either an initialize or an assign depending on whether %0 is
  // true or not.  This gets expanded out to a conditional destroy of the value.
  // CHECK:   load [[CONTROL]]
  // CHECK:   cond_br
  // CHECK: bb3:
  // CHECK:   destroy_addr [[CLASSVAL]]
  // CHECK:   br bb4
  // CHECK: bb4:
  // CHECK: store [[V2]] to [[CLASSVAL]]

  assign %17 to %6#1 : $*SomeClass                // id: %18
  destroy_addr %6#1 : $*SomeClass                 // id: %19
  dealloc_stack %6#0 : $*@local_storage SomeClass // id: %20
  %23 = tuple ()                                  // user: %24
  return %23 : $()                                // id: %24
}

/// Root class tests.

class RootClassWithIVars {
  var x: Int
  var y: Int
  var z: (Int, Int)
  init()
}


// CHECK-LABEL: sil @rootclass_test1
sil @rootclass_test1 : $@cc(method) @thin (@owned RootClassWithIVars, Int64) -> @owned RootClassWithIVars {
bb0(%0 : $RootClassWithIVars, %1 : $Int64):
  %3 = mark_uninitialized [rootself] %0 : $RootClassWithIVars

  %10 = ref_element_addr %3 : $RootClassWithIVars, #x
  assign %1 to %10 : $*Int64

  %11 = ref_element_addr %3 : $RootClassWithIVars, #y
  assign %1 to %11 : $*Int64

  %12 = ref_element_addr %3 : $RootClassWithIVars, #z
  %13 = tuple_element_addr %12 : $*(Int64, Int64), 0
  assign %1 to %13 : $*Int64
  %14 = tuple_element_addr %12 : $*(Int64, Int64), 1
  assign %1 to %14 : $*Int64

  return %3 : $RootClassWithIVars
}

// CHECK-LABEL: sil @rootclass_test2
sil @rootclass_test2 : $@cc(method) @thin (@owned RootClassWithIVars, Int64) -> @owned RootClassWithIVars {
bb0(%0 : $RootClassWithIVars, %1 : $Int64):
  %3 = mark_uninitialized [rootself] %0 : $RootClassWithIVars

  %10 = ref_element_addr %3 : $RootClassWithIVars, #x
  assign %1 to %10 : $*Int64

  %11 = ref_element_addr %3 : $RootClassWithIVars, #y
  assign %1 to %11 : $*Int64

  %12 = ref_element_addr %3 : $RootClassWithIVars, #z
  %13 = tuple_element_addr %12 : $*(Int64, Int64), 0
  assign %1 to %13 : $*Int64

  return %3 : $RootClassWithIVars  // expected-error {{instance variable '<unknown>.z.1' not initialized at end of initializer}}
}

// CHECK-LABEL: sil @rootclass_test3
sil @rootclass_test3 : $@cc(method) @thin (@owned RootClassWithIVars, Int64) -> @owned RootClassWithIVars {
bb0(%0 : $RootClassWithIVars, %1 : $Int64):
  %3 = mark_uninitialized [rootself] %0 : $RootClassWithIVars  

  strong_retain %3 : $RootClassWithIVars             // id: %11
  %11 = ref_element_addr %3 : $RootClassWithIVars, #y
  assign %1 to %11 : $*Int64
  strong_release %3 : $RootClassWithIVars            // id: %14

  return %3 : $RootClassWithIVars    // expected-error {{instance variable '<unknown>.x' not initialized at end of initializer}}
}

class DerivedClassWithIVars : RootClassWithIVars {
  var a: Int
  init()
}

sil @superinit : $@cc(method) @thin (@owned RootClassWithIVars) -> @owned RootClassWithIVars


sil @derived_test1 :  $@cc(method) @thin (@owned DerivedClassWithIVars) -> @owned DerivedClassWithIVars {
bb0(%0 : $DerivedClassWithIVars):
  %1 = alloc_box $DerivedClassWithIVars
  %3 = mark_uninitialized [derivedself] %0 : $DerivedClassWithIVars
  store %3 to %1#1 : $*DerivedClassWithIVars

  // Get an int
  %5 = function_ref @makesInt : $@thin () -> Int64
  %7 = apply [transparent] %5() : $@thin () -> Int64

  // Initialize the 'a' ivar with the int.
  %8 = load %1#1 : $*DerivedClassWithIVars
  %9 = ref_element_addr %8 : $DerivedClassWithIVars, #a
  assign %7 to %9 : $*Int64
  

  %11 = load %1#1 : $*DerivedClassWithIVars
  strong_retain %11 : $DerivedClassWithIVars
  %13 = upcast %11 : $DerivedClassWithIVars to $RootClassWithIVars
  %14 = function_ref @superinit : $@cc(method) @thin (@owned RootClassWithIVars) -> @owned RootClassWithIVars
  %15 = apply %14(%13) : $@cc(method) @thin (@owned RootClassWithIVars) -> @owned RootClassWithIVars

  %16 = unconditional_checked_cast downcast %15 : $RootClassWithIVars to $DerivedClassWithIVars
  assign %16 to %1#1 : $*DerivedClassWithIVars
  %18 = load %1#1 : $*DerivedClassWithIVars
  strong_retain %18 : $DerivedClassWithIVars
  strong_release %1#0 : $Builtin.ObjectPointer
  return %18 : $DerivedClassWithIVars
}

sil @derived_test2 :  $@cc(method) @thin (@owned DerivedClassWithIVars) -> @owned DerivedClassWithIVars {
bb0(%0 : $DerivedClassWithIVars):
  %1 = alloc_box $DerivedClassWithIVars
  %3 = mark_uninitialized [derivedself] %0 : $DerivedClassWithIVars
  store %3 to %1#1 : $*DerivedClassWithIVars

  %11 = load %1#1 : $*DerivedClassWithIVars
  strong_retain %11 : $DerivedClassWithIVars
  %13 = upcast %11 : $DerivedClassWithIVars to $RootClassWithIVars   // expected-error {{instance variable '<unknown>.a' not initialized at super.init call}}
  %14 = function_ref @superinit : $@cc(method) @thin (@owned RootClassWithIVars) -> @owned RootClassWithIVars
  %15 = apply %14(%13) : $@cc(method) @thin (@owned RootClassWithIVars) -> @owned RootClassWithIVars

  %16 = unconditional_checked_cast downcast %15 : $RootClassWithIVars to $DerivedClassWithIVars
  assign %16 to %1#1 : $*DerivedClassWithIVars
  %18 = load %1#1 : $*DerivedClassWithIVars
  strong_retain %18 : $DerivedClassWithIVars
  strong_release %1#0 : $Builtin.ObjectPointer
  return %18 : $DerivedClassWithIVars
}


