// RUN: %sil-opt -enum-simplification -verify %s | FileCheck %s

import Builtin

class C {}

enum FakeOptional {
  case None
  case Some(Builtin.NativeObject)
}

enum Either {
  case First(Builtin.NativeObject)
  case Second(C)
}

enum ThreeCaseEnum {
  case A
  case B
  case C
}

enum FakeOptionalClass {
  case None
  case Some(C)
}

struct S {
  var ptr : Builtin.NativeObject
}

enum ThreeCaseAbstractionDifference {
  case A(Builtin.Int32)
  case B(Builtin.NativeObject)
  case C(S)
}

sil @get_object : $@thin () -> Builtin.NativeObject

// CHECK-LABEL: sil @test1 : $@thin (FakeOptional) -> () {
// CHECK: bb0
// CHECK-NEXT: retain_value
// CHECK-NEXT: release_value
sil @test1 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  retain_value %0 : $FakeOptional
  release_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test2 : $@thin (FakeOptional) -> () {
// CHECK: bb0
// CHECK: strong_retain
// CHECK: strong_release
sil @test2 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = unchecked_enum_data %0 : $FakeOptional, #FakeOptional.Some!enumelt.1
  retain_value %0 : $FakeOptional
  release_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test3 : $@thin () -> () {
// CHECK: bb0
// CHECK-NEXT: enum
// CHECK-NOT: strong_retain
// CHECK-NOT: strong_release
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @test3 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional, #FakeOptional.None!enumelt
  retain_value %0 : $FakeOptional
  release_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test4 : $@thin () -> () {
// CHECK: bb0
// CHECK-NEXT: get_object
// CHECK-NEXT: function_ref @get_object
// CHECK-NEXT: apply
// CHECK-NEXT: enum
// CHECK: strong_retain
// CHECK: strong_release
sil @test4 : $@thin () -> () {
bb0:
  %0 = function_ref @get_object : $@thin () -> Builtin.NativeObject
  %1 = apply %0() : $@thin () -> Builtin.NativeObject
  %2 = enum $FakeOptional, #FakeOptional.Some!enumelt.1, %1 : $Builtin.NativeObject
  retain_value %2 : $FakeOptional
  release_value %2 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test5 : $@thin () -> () {
// CHECK: bb1:
// CHECK-NEXT: [[DATA:%[0-9]+]] = unchecked_enum_data
// CHECK-NEXT: strong_retain [[DATA]]
// CHECK: bb2:
// CHECK-NEXT: [[DATA1:%[0-9]+]] = unchecked_enum_data
// CHECK-NEXT: strong_retain [[DATA1]]
sil @test5 : $@thin () -> () {
bb0:
  %0 = function_ref @get_object : $@thin () -> Builtin.NativeObject
  %1 = apply %0() : $@thin () -> Builtin.NativeObject
  %2 = enum $FakeOptional, #FakeOptional.Some!enumelt.1, %1 : $Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  retain_value %2 : $FakeOptional
  br bb3

bb2:
  retain_value %2 : $FakeOptional
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test6 : $@thin (FakeOptional) -> () {
// CHECK: bb1:
// CHECK-NEXT: [[DATA:%[0-9]+]] = unchecked_enum_data
// CHECK-NEXT: strong_retain [[DATA]]
// CHECK: bb2:
// CHECK-NEXT: [[DATA1:%[0-9]+]] = unchecked_enum_data
// CHECK-NEXT: strong_retain [[DATA1]]
sil @test6 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = unchecked_enum_data %0 : $FakeOptional, #FakeOptional.Some!enumelt.1
  cond_br undef, bb1, bb2

bb1:
  retain_value %0 : $FakeOptional
  br bb3

bb2:
  retain_value %0 : $FakeOptional
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()  
}

// CHECK-LABEL: sil @test7 : $@thin () -> () {
// CHECK-NOT: retain
// CHECK-NOT: retain
// CHECK: return
sil @test7 : $@thin () -> () {
bb0:
  %0 = enum $FakeOptional, #FakeOptional.None!enumelt
  cond_br undef, bb1, bb2

bb1:
  retain_value %0 : $FakeOptional
  br bb3

bb2:
  retain_value %0 : $FakeOptional
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test8 : $@thin (FakeOptional) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $FakeOptional):
// CHECK: bb2:
// CHECK-NEXT: retain_value [[INPUT]]
// CHECK: bb3:
// CHECK-NEXT: [[PAYLOAD:%[0-9]+]] = unchecked_enum_data [[INPUT]]
// CHECK-NEXT: strong_retain [[PAYLOAD]]
// CHECK: bb4:
// CHECK: retain_value [[INPUT]]
sil @test8 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  cond_br undef, bb1, bb2

bb1:
  %1 = unchecked_enum_data %0 : $FakeOptional, #FakeOptional.Some!enumelt.1
  cond_br undef, bb2, bb3

bb2:
  retain_value %0 : $FakeOptional
  br bb4

bb3:
  retain_value %0 : $FakeOptional
  br bb4

bb4:
  retain_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test9 : $@thin (FakeOptional) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $FakeOptional):
// CHECK: bb1:
// CHECK-NEXT: [[PAYLOAD:%[0-9]+]] = unchecked_enum_data [[INPUT]]
// CHECK-NEXT: strong_retain [[PAYLOAD]]
// CHECK: bb2:
// CHECK-NOT: retain
// CHECK: bb3:
// CHECK: retain_value [[INPUT]]
sil @test9 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  retain_value %0 : $FakeOptional
  br bb3

bb2:
  retain_value %0 : $FakeOptional
  br bb3

bb3:
  retain_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// Note, this is the same as test9, but for enums
// CHECK-LABEL: sil @test9_enums : $@thin (FakeOptional) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $FakeOptional):
// CHECK: bb1:
// CHECK-NEXT: [[PAYLOAD:%[0-9]+]] = unchecked_enum_data [[INPUT]]
// CHECK-NEXT: strong_retain [[PAYLOAD]]
// CHECK: bb2:
// CHECK-NOT: retain
// CHECK: bb3:
// CHECK: retain_value [[INPUT]]
sil @test9_enums : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  %1 = enum_is_tag $Builtin.Int1, %0 : $FakeOptional, #FakeOptional.Some!enumelt
  cond_br %1, bb1, bb2

bb1:
  retain_value %0 : $FakeOptional
  br bb3

bb2:
  retain_value %0 : $FakeOptional
  br bb3

bb3:
  retain_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

////////////////
// Loop Tests //
////////////////

// CHECK-LABEL: sil @test10 : $@thin (FakeOptional) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $FakeOptional):
// CHECK: retain_value [[INPUT]]
// CHECK: retain_value [[INPUT]]
// CHECK: retain_value [[INPUT]]
// CHECK: retain_value [[INPUT]]
sil @test10 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

// Single BB Loop
bb1:
  retain_value %0 : $FakeOptional
  cond_br undef, bb1, bb9999

// Two BB Loop. We can use loop or domination to handle this case. But we don't
// handle it now.
bb2:
  retain_value %0 : $FakeOptional
  br bb3

bb3:
  retain_value %0 : $FakeOptional
  cond_br undef, bb2, bb9999

bb9999:
  retain_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// Make sure we don't propagate state out of loops.
// CHECK-LABEL: sil @test11 : $@thin (FakeOptional) -> () {
// CHECK: bb0([[INPUT:%[0-9]+]] : $FakeOptional):
// CHECK: retain_value [[INPUT]]
// CHECK: retain_value [[INPUT]]
sil @test11 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  retain_value %0 : $FakeOptional
  cond_br undef, bb1, bb2

bb2:
  retain_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test12 : $@thin (FakeOptional) -> () {
// CHECK: bb1:
// CHECK: release
// CHECK: bb2:
// CHECK-NOT: release
// CHECK: bb3:
// CHECK-NOT: release
sil @test12 : $@thin (FakeOptional) -> () {
bb0(%0 : $FakeOptional):
  switch_enum %0 : $FakeOptional, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  release_value %0 : $FakeOptional
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test13 : $@thin (Either) -> () {
// CHECK: bb1:
// CHECK: strong_release
// CHECK: bb2:
// CHECK: strong_release
// CHECK: bb3:
// CHECK-NOT: release_value
sil @test13 : $@thin (Either) -> () {
bb0(%0 : $Either):
  cond_br undef, bb1, bb2

bb1:
  %1 = unchecked_enum_data %0 : $Either, #Either.First!enumelt.1
  br bb3

bb2:
  %2 = unchecked_enum_data %0 : $Either, #Either.Second!enumelt.1
  br bb3

bb3:
  release_value %0 : $Either
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test14 : $@thin (Either) -> () {
// CHECK: bb0(
// CHECK-NOT: release
// CHECK: bb1:
// CHECK: release
sil @test14 : $@thin (Either) -> () {
bb0(%0 : $Either):
  %1 = unchecked_enum_data %0 : $Either, #Either.First!enumelt.1
  cond_br undef, bb1, bb2

bb1:
  release_value %0 : $Either
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @test15 : $@thin (Either, ThreeCaseEnum) -> () {
// CHECK: bb1:
// CHECK: release
// CHECK: bb2:
// CHECK-NOT: release
// CHECK: bb3:
// CHECK-NOT: release
sil @test15 : $@thin (Either, ThreeCaseEnum) -> () {
bb0(%0 : $Either, %1 : $ThreeCaseEnum):
  %2 = unchecked_enum_data %0 : $Either, #Either.First!enumelt.1
  switch_enum %1 : $ThreeCaseEnum, case #ThreeCaseEnum.A!enumelt: bb1,
                  case #ThreeCaseEnum.B!enumelt: bb2,
                  case #ThreeCaseEnum.C!enumelt: bb3

bb1:
  release_value %0 : $Either
  br bb4

bb2:
  br bb4

bb3:
  br bb4

bb4:
  %9999 = tuple()
  return %9999 : $()
}

sil @unknown : $@thin () -> ()

// CHECK-LABEL: sil @test16 : $@thin (FakeOptionalClass) -> () {
// CHECK: bb1:
// CHECK-NOT: release
// CHECK: bb2:
// CHECK: unchecked_enum_data
// CHECK: release
// CHECK: bb3
// CHECK: release
sil @test16 : $@thin (FakeOptionalClass) -> () {
bb0(%0 : $FakeOptionalClass):
  switch_enum %0 : $FakeOptionalClass,
    case #FakeOptionalClass.None!enumelt: bb1,
    case #FakeOptionalClass.Some!enumelt.1: bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  %1 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %2 = integer_literal $Builtin.Word, 2
  %3 = integer_literal $Builtin.Word, 3
  %4 = integer_literal $Builtin.Int1, 0
  %5 = apply %1(%2, %3, %4) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  release_value %0 : $FakeOptionalClass
  %9998 = function_ref @unknown : $@thin () -> ()
  apply %9998() : $@thin () -> ()
  release_value %0 : $FakeOptionalClass
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @enum_simplification_abstraction_differences : $@thin (ThreeCaseAbstractionDifference) -> () {
// CHECK: bb0(
// CHECK-NOT: release
// CHECK: bb1:
// CHECK-NOT: release
// CHECK: bb2:
// CHECK: strong_release
// CHECK: bb3:
// CHECK: release_value
// CHECK: bb4:
// CHECK-NOT: release_value
sil @enum_simplification_abstraction_differences : $@thin (ThreeCaseAbstractionDifference) -> () {
bb0(%0 : $ThreeCaseAbstractionDifference):
  switch_enum %0 : $ThreeCaseAbstractionDifference,
     case #ThreeCaseAbstractionDifference.A!enumelt.1: bb1,
     case #ThreeCaseAbstractionDifference.B!enumelt.1: bb2,
     case #ThreeCaseAbstractionDifference.C!enumelt.1: bb3

bb1:
  br bb4

bb2:
  br bb4

bb3:
  br bb4

bb4:
  release_value %0 : $ThreeCaseAbstractionDifference
  %9999 = tuple()
  return %9999 : $()
}
