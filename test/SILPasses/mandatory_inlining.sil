// RUN: %sil-opt %s -mandatory-inlining -verify | FileCheck %s

import Builtin
import swift

sil @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
sil @fromLiteral : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64

// CHECK-LABEL: sil @test_add : $@thin (x: Int64) -> Int64 {
sil @test_add : $@thin (x: Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_box $Int64
  store %0 to %1#1 : $*Int64
  %3 = function_ref @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %4 = load %1#1 : $*Int64
  %5 = function_ref @fromLiteral : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %6 = metatype $Int64.metatype
  %7 = integer_literal $Builtin.Int128, 20
  %8 = apply %5(%7, %6) : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %9 = apply %3(%4, %8) : $@thin (lhs: Int64, rhs: Int64) -> Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %9 : $Int64
}

// CHECK-LABEL: sil @inline_test_add : $@thin (x: Int64) -> Int64 {
sil @inline_test_add : $@thin (x: Int64) -> Int64 {
// CHECK: [[BB0:.*]]([[VAL0:%.*]] : $Int64):
  // CHECK: [[VAL1:%.*]] = alloc_box $Int64
  // CHECK: store [[VAL0]] to [[VAL1]]#1
  // CHECK: [[VAL3:%.*]] = function_ref @plus
  // CHECK: [[VAL4:%.*]] = function_ref @plus
  // CHECK: [[VAL5:%.*]] = load [[VAL1]]#1
  // CHECK: [[VAL6:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL7:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL8:%.*]] = integer_literal $Builtin.Int128, 10
  // CHECK: [[VAL9:%.*]] = apply [[VAL6]]([[VAL8]], [[VAL7]])
  // CHECK: [[VAL10:%.*]] = apply [[VAL4]]([[VAL5]], [[VAL9]])
  // CHECK: [[VAL11:%.*]] = alloc_box $Int64
  // CHECK: store [[VAL10]] to [[VAL11]]#1
  // CHECK: [[VAL13:%.*]] = function_ref @plus
  // CHECK: [[VAL14:%.*]] = load [[VAL11]]#1
  // CHECK: [[VAL15:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL16:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL17:%.*]] = integer_literal $Builtin.Int128, 20
  // CHECK: [[VAL18:%.*]] = apply [[VAL15]]([[VAL17]], [[VAL16]])
  // CHECK: [[VAL19:%.*]] = apply [[VAL13]]([[VAL14]], [[VAL18]])
  // CHECK: strong_release [[VAL11]]#0
  // CHECK: [[VAL21:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL22:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL23:%.*]] = integer_literal $Builtin.Int128, 30
  // CHECK: [[VAL24:%.*]] = apply [[VAL21]]([[VAL23]], [[VAL22]])
  // CHECK: [[VAL25:%.*]] = apply [[VAL3]]([[VAL19]], [[VAL24]])
  // CHECK: strong_release [[VAL1]]#0
  // CHECK: return [[VAL25]]

bb0(%0 : $Int64):
  %1 = alloc_box $Int64
  store %0 to %1#1 : $*Int64
  %3 = function_ref @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %4 = function_ref @test_add : $@thin (x: Int64) -> Int64
  %5 = function_ref @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %6 = load %1#1 : $*Int64
  %7 = function_ref @fromLiteral : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %8 = metatype $Int64.metatype
  %9 = integer_literal $Builtin.Int128, 10
  %10 = apply %7(%9, %8) : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %11 = apply %5(%6, %10) : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %12 = apply [transparent] %4(%11) : $@thin (x: Int64) -> Int64
  %13 = function_ref @fromLiteral : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %14 = metatype $Int64.metatype
  %15 = integer_literal $Builtin.Int128, 30
  %16 = apply %13(%15, %14) : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %17 = apply %3(%12, %16) : $@thin (lhs: Int64, rhs: Int64) -> Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %17 : $Int64
}

// CHECK-LABEL: sil @inline_twice_test_add : $@thin (x: Int64) -> Int64 {
sil @inline_twice_test_add : $@thin (x: Int64) -> Int64 {
// CHECK: [[BB0:.*]]([[VAL0:%.*]] : $Int64):
  // CHECK: [[VAL1:%.*]] = alloc_box $Int64
  // CHECK: store [[VAL0]] to [[VAL1]]#1
  // CHECK: [[VAL3:%.*]] = function_ref @plus
  // CHECK: [[VAL4:%.*]] = function_ref @plus
  // CHECK: [[VAL5:%.*]] = load [[VAL1]]#1
  // CHECK: [[VAL6:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL7:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL8:%.*]] = integer_literal $Builtin.Int128, 10
  // CHECK: [[VAL9:%.*]] = apply [[VAL6]]([[VAL8]], [[VAL7]])
  // CHECK: [[VAL10:%.*]] = apply [[VAL4]]([[VAL5]], [[VAL9]])
  // CHECK: [[VAL11:%.*]] = alloc_box $Int64
  // CHECK: store [[VAL10]] to [[VAL11]]#1
  // CHECK: [[VAL13:%.*]] = function_ref @plus
  // CHECK: [[VAL14:%.*]] = load [[VAL11]]#1
  // CHECK: [[VAL15:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL16:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL17:%.*]] = integer_literal $Builtin.Int128, 20
  // CHECK: [[VAL18:%.*]] = apply [[VAL15]]([[VAL17]], [[VAL16]])
  // CHECK: [[VAL19:%.*]] = apply [[VAL13]]([[VAL14]], [[VAL18]])
  // CHECK: strong_release [[VAL11]]#0
  // CHECK: [[VAL21:%.*]] = alloc_box $Int64
  // CHECK: store [[VAL19]] to [[VAL21]]#1
  // CHECK: [[VAL23:%.*]] = function_ref @plus
  // CHECK: [[VAL24:%.*]] = load [[VAL21]]#1
  // CHECK: [[VAL25:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL26:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL27:%.*]] = integer_literal $Builtin.Int128, 20
  // CHECK: [[VAL28:%.*]] = apply [[VAL25]]([[VAL27]], [[VAL26]])
  // CHECK: [[VAL29:%.*]] = apply [[VAL23]]([[VAL24]], [[VAL28]])
  // CHECK: strong_release [[VAL21]]#0
  // CHECK: [[VAL31:%.*]] = function_ref @fromLiteral
  // CHECK: [[VAL32:%.*]] = metatype $Int64.metatype
  // CHECK: [[VAL33:%.*]] = integer_literal $Builtin.Int128, 30
  // CHECK: [[VAL34:%.*]] = apply [[VAL31]]([[VAL33]], [[VAL32]])
  // CHECK: [[VAL35:%.*]] = apply [[VAL3]]([[VAL29]], [[VAL34]])
  // CHECK: strong_release [[VAL1]]#0
  // CHECK: return [[VAL35]]

bb0(%0 : $Int64):
  %1 = alloc_box $Int64
  store %0 to %1#1 : $*Int64
  %3 = function_ref @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %4 = function_ref @test_add : $@thin (x: Int64) -> Int64
  %5 = function_ref @test_add : $@thin (x: Int64) -> Int64
  %6 = function_ref @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %7 = load %1#1 : $*Int64
  %8 = function_ref @fromLiteral : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %9 = metatype $Int64.metatype
  %10 = integer_literal $Builtin.Int128, 10
  %11 = apply %8(%10, %9) : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %12 = apply %6(%7, %11) : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %13 = apply [transparent] %5(%12) : $@thin (x: Int64) -> Int64
  %14 = apply [transparent] %4(%13) : $@thin (x: Int64) -> Int64
  %15 = function_ref @fromLiteral : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %16 = metatype $Int64.metatype
  %17 = integer_literal $Builtin.Int128, 30
  %18 = apply %15(%17, %16) : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %19 = apply %3(%14, %18) : $@thin (lhs: Int64, rhs: Int64) -> Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %19 : $Int64
}

protocol SomeProtocol {
}

// CHECK-LABEL: sil @test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype
sil @test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype {
bb0(%0 : $*SomeProtocol):
  %1 = alloc_box $SomeProtocol
  copy_addr [take] %0 to [initialization] %1#1 : $*SomeProtocol
  %4 = alloc_stack $SomeProtocol
  copy_addr %1#1 to [initialization] %4#1 : $*SomeProtocol
  %6 = protocol_metatype $SomeProtocol.metatype, %4#1 : $*SomeProtocol
  destroy_addr %4#1 : $*SomeProtocol
  dealloc_stack %4#0 : $*@local_storage SomeProtocol
  strong_release %1#0 : $Builtin.ObjectPointer
  return %6 : $SomeProtocol.metatype
}

// CHECK-LABEL: sil @inline_test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype
sil @inline_test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype {
// CHECK: [[BB0:.*]]([[VAL0:%.*]] : $*SomeProtocol):
  // CHECK: [[VAL1:%.*]] = alloc_box $SomeProtocol
  // CHECK: copy_addr [take] %0 to [initialization] [[VAL1]]#1
  // CHECK: [[VAL4:%.*]] = alloc_stack $SomeProtocol
  // CHECK: copy_addr [[VAL1]]#1 to [initialization] [[VAL4]]#1
  // CHECK: [[VAL6:%.*]] = protocol_metatype $SomeProtocol.metatype, [[VAL4]]#1
  // CHECK: destroy_addr [[VAL4]]#1
  // CHECK: dealloc_stack [[VAL4]]#0
  // CHECK: strong_release [[VAL1]]#0
  // CHECK: return [[VAL6]]

bb0(%0 : $*SomeProtocol):
  %1 = function_ref @test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype
  %2 = apply [transparent] %1(%0) : $@thin (p: SomeProtocol) -> SomeProtocol.metatype
  %3 = return %2 : $SomeProtocol.metatype
}

sil internal @top_level_code : $() -> () {
bb0:
  %0 = tuple ()
  return %0 : $()
}

sil @get_logic_value : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
sil @add_floats : $@thin (lhs: Float32, rhs: Float32) -> Float32
sil @convertFromBuiltinFloatLiteral : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
sil @sub_floats : $@thin (lhs: Float32, rhs: Float32) -> Float32

sil @foo : $@thin (x: Float32, y: Float32) -> Bool
sil @bar : $@thin (x: Float32) -> Bool

// CHECK-LABEL: sil @test_control_flow : $@thin (x: Float32, y: Float32) -> Float32
sil @test_control_flow : $@thin (x: Float32, y: Float32) -> Float32 {
bb0(%0 : $Float32, %1 : $Float32):
  %2 = alloc_box $Float32
  %3 = alloc_box $Float32
  store %0 to %2#1 : $*Float32
  store %1 to %3#1 : $*Float32
  %6 = function_ref @get_logic_value : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
  %7 = function_ref @foo : $@thin (x: Float32, y: Float32) -> Bool
  %8 = load %2#1 : $*Float32
  %9 = load %3#1 : $*Float32
  %10 = apply %7(%8, %9) : $@thin (x: Float32, y: Float32) -> Bool
  %11 = alloc_stack $Bool
  store %10 to %11#1 : $*Bool
  %13 = apply %6(%11#1) : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
  dealloc_stack %11#0 : $*@local_storage Bool
  cond_br %13, bb1, bb2

bb1:
  %16 = load %2#1 : $*Float32
  unreachable

bb2:
  br bb3

bb3:
  %19 = function_ref @get_logic_value : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
  %20 = function_ref @bar : $@thin (x: Float32) -> Bool
  %21 = load %3#1 : $*Float32
  %22 = apply %20(%21) : $@thin (x: Float32) -> Bool
  %23 = alloc_stack $Bool
  store %22 to %23#1 : $*Bool
  %25 = apply %19(%23#1) : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
  dealloc_stack %23#0 : $*@local_storage Bool
  cond_br %25, bb4, bb5

bb4:
  %28 = function_ref @add_floats : $@thin (lhs: Float32, rhs: Float32) -> Float32
  %29 = load %3#1 : $*Float32
  %30 = function_ref @convertFromBuiltinFloatLiteral : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %31 = metatype $Float32.metatype
  %32 = float_literal $Builtin.FPIEEE64, 0x3FF0000000000000
  %33 = apply %30(%32, %31) : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %34 = apply %28(%29, %33) : $@thin (lhs: Float32, rhs: Float32) -> Float32
  store %34 to %3#1 : $*Float32
  br bb3

bb5:
  %37 = load %3#1 : $*Float32
  br bb6(%37 : $Float32)

bb6(%39 : $Float32):
  strong_release %3#0 : $Builtin.ObjectPointer
  strong_release %2#0 : $Builtin.ObjectPointer
  return %39 : $Float32
}

// CHECK-LABEL: sil @inline_test_control_flow : $@thin (x: Float32) -> Float32
sil @inline_test_control_flow : $@thin (x: Float32) -> Float32 {

// CHECK: [[BB0:.*]]([[VAL0:%.*]] : $Float32):
  // CHECK: [[VAL1:%.*]] = alloc_box $Float32
  // CHECK: store [[VAL0]] to [[VAL1]]#1
  // CHECK: [[VAL3:%.*]] = function_ref @sub_floats
  // CHECK: [[VAL4:%.*]] = function_ref @add_floats
  // CHECK: [[VAL5:%.*]] = load [[VAL1]]#1
  // CHECK: [[VAL6:%.*]] = function_ref @convertFromBuiltinFloatLiteral
  // CHECK: [[VAL7:%.*]] = metatype $Float32.metatype
  // CHECK: [[VAL8:%.*]] = float_literal $Builtin.FPIEEE64, 0x3FF0000000000000
  // CHECK: [[VAL9:%.*]] = apply [[VAL6]]([[VAL8]], [[VAL7]])
  // CHECK: [[VAL10:%.*]] = apply [[VAL4]]([[VAL5]], [[VAL9]])
  // CHECK: [[VAL11:%.*]] = function_ref @convertFromBuiltinFloatLiteral
  // CHECK: [[VAL12:%.*]] = metatype $Float32.metatype
  // CHECK: [[VAL13:%.*]] = float_literal $Builtin.FPIEEE64, 0x4000000000000000
  // CHECK: [[VAL14:%.*]] = apply [[VAL11]]([[VAL13]], [[VAL12]])
  // CHECK: [[VAL15:%.*]] = alloc_box $Float32
  // CHECK: [[VAL16:%.*]] = alloc_box $Float32
  // CHECK: store [[VAL10]] to [[VAL15]]#1
  // CHECK: store [[VAL14]] to [[VAL16]]#1
  // CHECK: [[VAL19:%.*]] = function_ref @get_logic_value
  // CHECK: [[VAL20:%.*]] = function_ref @foo
  // CHECK: [[VAL21:%.*]] = load [[VAL15]]#1
  // CHECK: [[VAL22:%.*]] = load [[VAL16]]#1
  // CHECK: [[VAL23:%.*]] = apply [[VAL20]]([[VAL21]], [[VAL22]])
  // CHECK: [[VAL24:%.*]] = alloc_stack $Bool
  // CHECK: store [[VAL23]] to [[VAL24]]#1
  // CHECK: [[VAL26:%.*]] = apply [[VAL19]]([[VAL24]]#1)
  // CHECK: dealloc_stack [[VAL24]]#0
  // CHECK: cond_br [[VAL26]], [[BB1:bb[0-9]+]], [[BB2:bb[0-9]+]]

// CHECK: [[BB1]]:
  // CHECK: [[VAL29:%.*]] = load [[VAL15]]#1
  // CHECK: unreachable

// CHECK: [[BB2]]:
  // CHECK: br [[BB3:bb[0-9]+]]

// CHECK: [[BB3]]:
  // CHECK: [[VAL32:%.*]] = function_ref @get_logic_value
  // CHECK: [[VAL33:%.*]] = function_ref @bar
  // CHECK: [[VAL34:%.*]] = load [[VAL16]]#1
  // CHECK: [[VAL35:%.*]] = apply [[VAL33]]([[VAL34]])
  // CHECK: [[VAL36:%.*]] = alloc_stack $Bool
  // CHECK: store [[VAL35]] to [[VAL36]]#1
  // CHECK: [[VAL38:%.*]] = apply [[VAL32]]([[VAL36]]#1)
  // CHECK: dealloc_stack [[VAL36]]#0
  // CHECK: cond_br [[VAL38]], [[BB4:bb[0-9]+]], [[BB5:bb[0-9]+]]

// CHECK: [[BB4]]:
  // CHECK: [[VAL41:%.*]] = function_ref @add_floats
  // CHECK: [[VAL42:%.*]] = load [[VAL16]]#1
  // CHECK: [[VAL43:%.*]] = function_ref @convertFromBuiltinFloatLiteral
  // CHECK: [[VAL44:%.*]] = metatype $Float32.metatype
  // CHECK: [[VAL45:%.*]] = float_literal $Builtin.FPIEEE64, 0x3FF0000000000000
  // CHECK: [[VAL46:%.*]] = apply [[VAL43]]([[VAL45]], [[VAL44]])
  // CHECK: [[VAL47:%.*]] = apply [[VAL41]]([[VAL42]], [[VAL46]])
  // CHECK: store [[VAL47]] to [[VAL16]]#1
  // CHECK: br [[BB3]]

// CHECK: [[BB5]]:
  // CHECK: [[VAL50:%.*]] = load [[VAL16]]#1
  // CHECK: br [[BB6:.*]]([[VAL50]]

// CHECK: [[BB6]]([[VAL52:%.*]] : $Float32):
  // CHECK: strong_release [[VAL16]]#0
  // CHECK: strong_release [[VAL15]]#0
  // CHECK: br [[BB7:.*]]([[VAL52]]

// CHECK: [[BB7]]([[VAL56:%.*]] : $Float32):
  // CHECK: [[VAL57:%.*]] = function_ref @convertFromBuiltinFloatLiteral
  // CHECK: [[VAL58:%.*]] = metatype $Float32.metatype
  // CHECK: [[VAL59:%.*]] = float_literal $Builtin.FPIEEE64, 0x4008000000000000
  // CHECK: [[VAL60:%.*]] = apply [[VAL57]]([[VAL59]], [[VAL58]])
  // CHECK: [[VAL61:%.*]] = apply [[VAL3]]([[VAL56]], [[VAL60]])
  // CHECK: strong_release [[VAL1]]#0
  // CHECK: return [[VAL61]]

bb0(%0 : $Float32):
  %1 = alloc_box $Float32
  store %0 to %1#1 : $*Float32
  %3 = function_ref @sub_floats : $@thin (lhs: Float32, rhs: Float32) -> Float32
  %4 = function_ref @test_control_flow : $@thin (x: Float32, y: Float32) -> Float32
  %5 = function_ref @add_floats : $@thin (lhs: Float32, rhs: Float32) -> Float32
  %6 = load %1#1 : $*Float32
  %7 = function_ref @convertFromBuiltinFloatLiteral : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %8 = metatype $Float32.metatype
  %9 = float_literal $Builtin.FPIEEE64, 0x3FF0000000000000
  %10 = apply %7(%9, %8) : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %11 = apply %5(%6, %10) : $@thin (lhs: Float32, rhs: Float32) -> Float32
  %12 = function_ref @convertFromBuiltinFloatLiteral : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %13 = metatype $Float32.metatype
  %14 = float_literal $Builtin.FPIEEE64, 0x4000000000000000
  %15 = apply %12(%14, %13) : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %16 = apply [transparent] %4(%11, %15) : $@thin (x: Float32, y: Float32) -> Float32
  %17 = function_ref @convertFromBuiltinFloatLiteral : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %18 = metatype $Float32.metatype
  %19 = float_literal $Builtin.FPIEEE64, 0x4008000000000000
  %20 = apply %17(%19, %18) : $@thin ((value: Builtin.FPIEEE64), Float32.metatype) -> Float32
  %21 = apply %3(%16, %20) : $@thin (lhs: Float32, rhs: Float32) -> Float32
  strong_release %1#0 : $Builtin.ObjectPointer
  return %21 : $Float32
}

// CHECK-LABEL: @test_recursive_foo : $@thin (x: Float32) -> Float32
sil @test_recursive_foo : $@thin (x: Float32) -> Float32 {
  // CHECK-NOT: function_ref
  // CHECK-NOT: apply
  // CHECK: return

bb0(%0 : $Float32):
  %3 = function_ref @test_recursive_bar : $@thin (x: Float32) -> Float32
  %5 = apply [transparent] %3(%0) : $@thin (x: Float32) -> Float32
  return %5 : $Float32
}

// CHECK-LABEL: sil @test_recursive_bar : $@thin (x: Float32) -> Float32
sil @test_recursive_bar : $@thin (x: Float32) -> Float32 {
  // CHECK-NOT: function_ref
  // CHECK-NOT: apply
  // CHECK: return

bb0(%0 : $Float32):
  %3 = function_ref @test_recursive_baz : $@thin (x: Float32) -> Float32
  %5 = apply [transparent] %3(%0) : $@thin (x: Float32) -> Float32
  return %5 : $Float32
}

// CHECK-LABEL: sil @test_recursive_baz : $@thin (x: Float32) -> Float32
sil @test_recursive_baz : $@thin (x: Float32) -> Float32 {
  // CHECK-NOT: function_ref
  // CHECK-NOT: apply
  // CHECK: return

bb0(%0 : $Float32):
  return %0 : $Float32
}

// CHECK-LABEL: sil @test_partial_foo : $@thin Int64 -> Int64 {
sil @test_partial_foo : $@thin (Int64) -> Int64 {
// CHECK: [[BB0:.*]]([[VAL0:%.*]] : $Int64):
  // CHECK: [[VAL1:%.*]] = function_ref @plus
  // CHECK: [[VAL2:%.*]] = apply [[VAL1]]([[VAL0]], [[VAL0]])
  // CHECK: return [[VAL2]]

bb0(%0 : $Int64):
  %2 = function_ref @test_partial_bar : $@thin (Int64 -> Int64, Int64) -> Int64
  %3 = function_ref @test_partial_baz : $@thin (Int64, Int64) -> Int64
  %5 = partial_apply %3(%0) : $@thin (Int64, Int64) -> Int64
  %13 = apply [transparent] %2(%5, %0) : $@thin (Int64 -> Int64, Int64) -> Int64
  return %13 : $Int64
}

sil @test_partial_baz : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %1 : $Int64):
  %6 = function_ref @plus : $@thin (lhs: Int64, rhs: Int64) -> Int64
  %7 = apply %6(%0, %1) : $@thin (lhs: Int64, rhs: Int64) -> Int64
  return %7 : $Int64
}

sil @test_partial_bar : $@thin (Int64 -> Int64, Int64) -> Int64 {
bb0(%0 : $Int64 -> Int64, %1 : $Int64):
  %7 = apply [transparent] %0(%1) : $Int64 -> Int64
  return %7 : $Int64
}

sil @true_getter : $@thin () -> Bool

sil @short_circuit_or : $@thin (lhs: Bool, rhs : () -> Bool) -> Bool {
bb0(%0 : $Bool, %1 : $() -> Bool):
  %2 = alloc_box $Bool
  %3 = alloc_box $() -> Bool
  store %0 to %2#1 : $*Bool
  store %1 to %3#1 : $*() -> Bool
  %6 = function_ref @get_logic_value : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
  %7 = apply %6(%2#1) : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
  cond_br %7, bb1, bb2

bb1:

  %9 = function_ref @true_getter : $@thin () -> Bool
  %10 = apply %9() : $@thin () -> Bool
  br bb3(%10 : $Bool)

bb2:
  %12 = load %3#1 : $*() -> Bool
  strong_retain %12 : $() -> Bool
  %14 = apply [transparent] %12() : $() -> Bool
  br bb3(%14 : $Bool)

bb3(%16 : $Bool):
  strong_release %3#0 : $Builtin.ObjectPointer
  strong_release %2#0 : $Builtin.ObjectPointer
  return %16 : $Bool
}

sil internal @closure0 : $@thin ((), (Builtin.ObjectPointer, @inout Bool)) -> Bool {
bb0(%0 : $Builtin.ObjectPointer, %1 : $*Bool):
  %2 = tuple ()
  %3 = load %1 : $*Bool
  strong_release %0 : $Builtin.ObjectPointer
  return %3 : $Bool
}

sil @test_short_circuit : $@thin (x: Bool, y: Bool) -> Bool {

// CHECK-LABEL: sil @test_short_circuit : $@thin (x: Bool, y: Bool) -> Bool {

  // CHECK: cond_br {{%.*}}, [[BB1:bb[0-9]+]], [[BB3:bb[0-9]+]]

// CHECK: bb1:
  // CHECK: br [[BB2:.*]](

// CHECK: [[BB2]](
  // CHECK: br [[BB4:.*]](

// CHECK: [[BB3]]:
  // CHECK: strong_retain [[VAL3:.*]]#0
  // CHECK: {{%.*}} = tuple ()
  // CHECK: {{%.*}} = load [[VAL3]]#1
  // CHECK: strong_release [[VAL3]]#0
  // CHECK: br [[BB2]](

// CHECK: [[BB4]](
  // CHECK: strong_release [[VAL3]]#0
  // CHECK: return {{.*}}

bb0(%0 : $Bool, %1 : $Bool):
  %2 = alloc_box $Bool
  %3 = alloc_box $Bool
  store %0 to %2#1 : $*Bool
  store %1 to %3#1 : $*Bool
  %6 = function_ref @short_circuit_or : $@thin (lhs: Bool, rhs : () -> Bool) -> Bool
  %7 = load %2#1 : $*Bool
  %8 = function_ref @closure0 : $@thin ((), (Builtin.ObjectPointer, @inout Bool)) -> Bool
  strong_retain %3#0 : $Builtin.ObjectPointer
  %10 = partial_apply %8(%3#0, %3#1) : $@thin ((), (Builtin.ObjectPointer, @inout Bool)) -> Bool
  %11 = apply [transparent] %6(%7, %10) : $@thin (lhs: Bool, rhs: () -> Bool) -> Bool
  strong_release %3#0 : $Builtin.ObjectPointer
  strong_release %2#0 : $Builtin.ObjectPointer
  return %11 : $Bool
}

sil [transparent] @convertFromBultinIntegerLiteral : $@thin ((val: Builtin.Int2048), Int64.metatype) -> Int64 {
bb0(%0 : $Builtin.Int2048, %1 : $Int64.metatype):
  %2 = builtin_function_ref #Builtin.s_to_s_checked_trunc_Int2048_Int64 : $@thin Builtin.Int2048 -> (Builtin.Int64, Builtin.Int1)
  %3 = apply %2(%0) : $@thin Builtin.Int2048 -> (Builtin.Int64, Builtin.Int1)
  %4 = tuple_extract %3 : $(Builtin.Int64, Builtin.Int1), 0
  %5 = struct $Int64 (%4 : $Builtin.Int64)
  return %5 : $Int64
}

sil @test_with_dead_argument : $@thin () -> () {
bb0:
  %0 = tuple ()
  %1 = alloc_box $Int64
  %2 = function_ref @convertFromBultinIntegerLiteral : $@thin ((val: Builtin.Int2048), Int64.metatype) -> Int64
  %3 = metatype $Int64.metatype
  %4 = integer_literal $Builtin.Int2048, 1
  %5 = apply [transparent] %2(%4, %3) : $@thin ((val: Builtin.Int2048), Int64.metatype) -> Int64
  store %5 to %1#1 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  %8 = tuple ()
  return %8 : $()
}

// CHECK-LABEL: sil @test_with_dead_argument : $@thin () -> () {
// CHECK-NOT: metatype
