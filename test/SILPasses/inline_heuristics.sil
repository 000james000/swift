// RUN: rm -rf %t && mkdir -p %t
// RUN: %sil-opt %s -inline -debug-only=sil-inliner 2>%t/log | FileCheck %s
// RUN: FileCheck -check-prefix=LOG %s <%t/log
// REQUIRES: asserts

// This test checks the inline heuristics based on the debug log output of
// the performance inliner.
// Checking the final sil is just a goodie.


sil_stage canonical

import Builtin
import Swift
import SwiftShims

struct Cont {
	var cl: (Int) -> Int
}

// CHECK-LABEL: sil @testDirectClosure
// CHECK: [[C:%[0-9]+]] = thin_to_thick_function
// CHECK: apply [[C]](
// CHECK: return

// LOG-LABEL: Visiting Function: testDirectClosure 
// LOG: Eligible callee: takeDirectClosure
// LOG: Boost: apply const function

sil @testDirectClosure : $@thin () -> Int {
bb0:
  %0 = function_ref @takeDirectClosure : $@thin (@owned @callee_owned (Int) -> Int) -> Int
  %1 = function_ref @directClosure : $@thin (Int) -> Int
  %2 = thin_to_thick_function %1 : $@thin (Int) -> Int to $@callee_owned (Int) -> Int
  %3 = apply %0(%2) : $@thin (@owned @callee_owned (Int) -> Int) -> Int
  return %3 : $Int
}

sil @takeDirectClosure : $@thin (@owned @callee_owned (Int) -> Int) -> Int {
bb0(%0 : $@callee_owned (Int) -> Int):
  %1 = integer_literal $Builtin.Word, 27
  %2 = struct $Int (%1 : $Builtin.Word)
  %3 = apply %0(%2) : $@callee_owned (Int) -> Int
  return %3 : $Int
}

sil shared @directClosure : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 1
  %2 = struct_extract %0 : $Int, #Int.value
  %3 = integer_literal $Builtin.Int1, -1
  %4 = builtin "sadd_with_overflow_Word"(%2 : $Builtin.Word, %1 : $Builtin.Word, %3 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %5 = tuple_extract %4 : $(Builtin.Word, Builtin.Int1), 0
  %6 = tuple_extract %4 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %6 : $Builtin.Int1
  %8 = struct $Int (%5 : $Builtin.Word)
  return %8 : $Int
}

// CHECK-LABEL: sil @testStructClosure
// CHECK: [[C:%[0-9]+]] = struct_extract
// CHECK: apply [[C]](
// CHECK: return

// LOG-LABEL: Visiting Function: testStructClosure
// LOG: Eligible callee: takeStructClosure
// LOG: Boost: apply const function

sil @testStructClosure : $@thin () -> Int {
bb0:
  %0 = function_ref @takeStructClosure : $@thin (@owned Cont) -> Int
  %1 = function_ref @structClosure : $@thin (Int) -> Int
  %2 = thin_to_thick_function %1 : $@thin (Int) -> Int to $@callee_owned (Int) -> Int
  %3 = struct $Cont (%2 : $@callee_owned (Int) -> Int)
  %4 = apply %0(%3) : $@thin (@owned Cont) -> Int
  return %4 : $Int
}

sil @takeStructClosure : $@thin (@owned Cont) -> Int {
bb0(%0 : $Cont):
  %1 = struct_extract %0 : $Cont, #Cont.cl
  %2 = integer_literal $Builtin.Word, 27
  %3 = struct $Int (%2 : $Builtin.Word)
  %4 = apply %1(%3) : $@callee_owned (Int) -> Int
  return %4 : $Int
}

sil shared @structClosure : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 1
  %2 = struct_extract %0 : $Int, #Int.value
  %3 = integer_literal $Builtin.Int1, -1
  %4 = builtin "sadd_with_overflow_Word"(%2 : $Builtin.Word, %1 : $Builtin.Word, %3 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %5 = tuple_extract %4 : $(Builtin.Word, Builtin.Int1), 0
  %6 = tuple_extract %4 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %6 : $Builtin.Int1
  %8 = struct $Int (%5 : $Builtin.Word)
  return %8 : $Int
}

// CHECK-LABEL: sil @testStructAddrClosure
// CHECK: [[C:%[0-9]+]] = load
// CHECK: apply [[C]](
// CHECK: return

// LOG-LABEL: Visiting Function: testStructAddrClosure
// LOG: Eligible callee: takeStructAddrClosure
// LOG: Boost: apply const function

sil @testStructAddrClosure : $@thin () -> Int {
bb0:
  %0 = alloc_stack $Cont
  %1 = function_ref @structAddrClosure : $@thin (Int) -> Int
  %2 = thin_to_thick_function %1 : $@thin (Int) -> Int to $@callee_owned (Int) -> Int
  %3 = struct $Cont (%2 : $@callee_owned (Int) -> Int)
  store %3 to %0#1 : $*Cont
  %5 = function_ref @takeStructAddrClosure : $@thin (@inout Cont) -> Int
  %6 = apply %5(%0#1) : $@thin (@inout Cont) -> Int
  %7 = struct_element_addr %0#1 : $*Cont, #Cont.cl
  %8 = load %7 : $*@callee_owned (Int) -> Int
  strong_release %8 : $@callee_owned (Int) -> Int
  dealloc_stack %0#0 : $*@local_storage Cont
  return %6 : $Int
}

sil @takeStructAddrClosure : $@thin (@inout Cont) -> Int {
bb0(%0 : $*Cont):
  %1 = struct_element_addr %0 : $*Cont, #Cont.cl
  %2 = load %1 : $*@callee_owned (Int) -> Int
  %3 = integer_literal $Builtin.Word, 27
  %4 = struct $Int (%3 : $Builtin.Word)
  strong_retain %2 : $@callee_owned (Int) -> Int
  %6 = apply %2(%4) : $@callee_owned (Int) -> Int
  return %6 : $Int
}

sil shared @structAddrClosure : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 1
  %2 = struct_extract %0 : $Int, #Int.value
  %3 = integer_literal $Builtin.Int1, -1
  %4 = builtin "sadd_with_overflow_Word"(%2 : $Builtin.Word, %1 : $Builtin.Word, %3 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %5 = tuple_extract %4 : $(Builtin.Word, Builtin.Int1), 0
  %6 = tuple_extract %4 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %6 : $Builtin.Int1
  %8 = struct $Int (%5 : $Builtin.Word)
  return %8 : $Int
}

