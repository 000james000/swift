// RUN: %sil-opt %s -sil-combine -verify | FileCheck %s

sil_stage canonical

import Builtin
import Swift

class RawBuffer {}
class HeapBufferStorage<T,U> : RawBuffer {}

enum FakeOptional<T> {
  case None
  case Some(T)
}

struct StringData {
  var size: Builtin.Word
}

class B { }
class E : B { }

enum AddressOnlyEnum {
  case Loadable(Builtin.Int32)
  case AddressOnly(Any)
}

sil [global_init] @global_init_fun : $@thin () -> Builtin.RawPointer

//////////////////////
// Simple DCE Tests //
//////////////////////

// CHECK-LABEL: sil @dead_inst_elimination_one_bb
// CHECK-NOT: integer_literal $Builtin.Int64, 24
sil @dead_inst_elimination_one_bb : $@thin () -> () {
  %0 = integer_literal $Builtin.Int64, 24
  %1 = tuple()
  return %1 : $()
}

// CHECK-LABEL: sil @dead_inst_elimination_diamond
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK-NOT: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_diamond : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  %1 = integer_literal $Builtin.Int64, 24
  cond_br %0, bb1, bb2

bb1:
  %2 = integer_literal $Builtin.Int64, 48
  br bb3

bb2:
  %3 = integer_literal $Builtin.Int64, 96
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

sil @random_counter : $@thin () -> Builtin.Int1

// CHECK-LABEL: sil @dead_inst_elimination_loop
// CHECK: bb0
// CHECK-NOT: integer_literal
// CHECK: bb1
// CHECK: function_ref
// CHECK: apply
// CHECK-NOT: integer_literal
// CHECK: bb2
// CHECK-NOT: integer_literal
// CHECK: tuple
// CHECK: return
sil @dead_inst_elimination_loop : $@thin () -> () {
bb0:
  %1 = integer_literal $Builtin.Int64, 24
  br bb1

bb1:
  %2 = function_ref @random_counter : $@thin () -> Builtin.Int1
  %3 = apply %2() : $@thin () -> Builtin.Int1
  %4 = integer_literal $Builtin.Int64, 48
  cond_br %3, bb1, bb2

bb2:
  %5 = integer_literal $Builtin.Int64, 59
  %6 = tuple()
  return %6 : $()
}

// For now until the proper unreachable pruning code is committed for
// SILCombine, we should not dce dead instructions in unreachable code.

// CHECK-LABEL: sil @dead_inst_elimination_ignore_unreachable
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_ignore_unreachable : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Int64, 24
  br bb2

bb1:
  %1 = integer_literal $Builtin.Int64, 48
  br bb2

bb2:
  %2 = tuple()
  return %2 : $()
}

//////////////////////////////////////////////////////////
// Other DCE Tests taken from diagnose_unreachable.sil //
//////////////////////////////////////////////////////////

sil @exit : $@thin @noreturn () -> () {
bb0:
  %1 = tuple ()
  return %1 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadInstructions
// CHECK: store
// CHECK: strong_retain
// CHECK-NOT: unchecked_ref_cast
// CHECK: strong_release
// CHECK-NEXT: strong_release
// CHECK-NOT: unchecked_ref_cast
sil @removeTriviallyDeadInstructions : $@thin (@owned B) -> () {
bb0(%0 : $B):
  %1 = alloc_box $B
  %2 = store %0 to %1#1 : $*B
  %3 = load %1#1 : $*B
  %4 = strong_retain %3 : $B
  %5 = unchecked_ref_cast %3 : $B to $Builtin.NativeObject
  %7 = strong_release %3 : $B
  %8 = strong_release %1#0 : $Builtin.NativeObject
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %6 = unchecked_ref_cast %5 : $Builtin.NativeObject to $B
  %11 = tuple()
  %12 = return %11 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadCrossBasicBlocks
// CHECK-NOT: unchecked_ref_cast
// CHECK: cond_br
// CHECK-NOT: unchecked_ref_cast
// CHECK: }
sil @removeTriviallyDeadCrossBasicBlocks : $@thin (@owned B, Builtin.Int1) -> () {
bb0(%0: $B, %1: $Builtin.Int1):
  %5 = unchecked_ref_cast %0 : $B to $Builtin.NativeObject
  %13 = cond_br %1, bb1, bb2
bb1:
  %22 = br bb2
bb2:
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %21 = unchecked_ref_cast %5 : $Builtin.NativeObject to $B
  %32 = tuple ()
  %33 = return %32 : $()
}

// CHECK-LABEL: sil @dead_use_of_alloc_stack
// CHECK: bb
// CHECK: alloc_stack
// CHECK: dealloc_stack
// CHECK: }
sil @dead_use_of_alloc_stack : $@thin () -> () {
bb0:
  %1 = alloc_stack $((), (), ())
  %2 = tuple_element_addr %1#1 : $*((), (), ()), 0
  dealloc_stack %1#0 : $*@local_storage ((), (), ())
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil @tuple_extract
// CHECK: bb
// CHECK-NEXT: return %0
sil @tuple_extract : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = tuple (%0 : $Int64, %0 : $Int64)
  %2 = tuple_extract %1 : $(Int64, Int64), 0
  return %2 : $Int64
}

// CHECK-LABEL: sil @do_not_fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
sil @do_not_fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, 0
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, -1
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

enum BoolLike { case true, false }

// CHECK-LABEL: sil @fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
sil @fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @do_not_fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
sil @do_not_fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @struct_extract_load_to_load_struct_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*UInt8):
// CHECK-NEXT:  [[IN_GEP:%[0-9]+]] = struct_element_addr [[IN]] : $*UInt8, #UInt8.value
// CHECK-NEXT:  [[IN_LOADED:%[0-9]+]] = load [[IN_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  [[LITERAL:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  [[IN_GEP_STORE:%[0-9]+]] = struct_element_addr [[IN]] : $*UInt8, #UInt8.value
// CHECK-NEXT:  store [[LITERAL]] to [[IN_GEP_STORE]] : $*Builtin.Int8
// CHECK-NEXT:  return [[IN_LOADED]] : $Builtin.Int8
sil @struct_extract_load_to_load_struct_element_addr : $@thin (@inout UInt8) -> (Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #UInt8.value
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #UInt8.value
  return %5 : $Builtin.Int8
}

// CHECK-LABEL: sil @tuple_extract_load_to_load_tuple_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*(Builtin.Int8, Builtin.Int8)):
// CHECK-NEXT:  [[IN_GEP:%[0-9]+]] = tuple_element_addr [[IN]] : $*(Builtin.Int8, Builtin.Int8), 0
// CHECK-NEXT:  [[IN_LOADED:%[0-9]+]] = load [[IN_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  [[LITERAL:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  [[IN_STORE_GEP:%[0-9]+]] = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
// CHECK-NEXT:  store [[LITERAL]] to [[IN_STORE_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  return [[IN_LOADED]] : $Builtin.Int8
sil @tuple_extract_load_to_load_tuple_element_addr : $@thin (@inout (Builtin.Int8, Builtin.Int8)) -> (Builtin.Int8) {
bb0(%0 : $*(Builtin.Int8, Builtin.Int8)):
  %1 = load %0 : $*(Builtin.Int8, Builtin.Int8)
  %2 = integer_literal $Builtin.Int8, 1
  %3 = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int8), 0
  return %5 : $Builtin.Int8
}

// Do not perform the optimization of the input load has multiple uses.
//
// CHECK-LABEL: sil @multiple_use_struct_extract_load_to_load_struct_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*UInt8):
// CHECK-NEXT: load
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: store
// CHECK-NEXT: struct_extract
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @multiple_use_struct_extract_load_to_load_struct_element_addr : $@thin (@inout UInt8) -> (UInt8, Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #UInt8.value
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #UInt8.value
  %6 = tuple (%1 : $UInt8, %5 : $Builtin.Int8)
  return %6 : $(UInt8, Builtin.Int8)
}

// Do not perform the optimization of the input load has multiple uses.
//
// CHECK-LABEL: sil @multiple_use_tuple_extract_load_to_load_tuple_element_addr
// CHECK: bb0
// CHECK-NEXT: load
// CHECK-NEXT: integer_literal
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: store
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @multiple_use_tuple_extract_load_to_load_tuple_element_addr : $@thin (@inout (Builtin.Int8, Builtin.Int8)) -> ((Builtin.Int8, Builtin.Int8), Builtin.Int8) {
bb0(%0 : $*(Builtin.Int8, Builtin.Int8)):
  %1 = load %0 : $*(Builtin.Int8, Builtin.Int8)
  %2 = integer_literal $Builtin.Int8, 1
  %3 = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int8), 0
  %6 = tuple (%1 : $(Builtin.Int8, Builtin.Int8), %5 : $Builtin.Int8)
  return %6 : $((Builtin.Int8, Builtin.Int8), Builtin.Int8)
}

// CHECK-LABEL: sil @release_value_test
// CHECK: bb0({{%[0-9]+}} : $Builtin.Int8, [[RELEASE_TARGET:%[0-9]+]] : $Builtin.NativeObject):
// CHECK-NEXT: strong_release [[RELEASE_TARGET]] : $Builtin.NativeObject
// CHECK-NEXT: tuple ()
// CHECK-NEXT: return
sil @release_value_test : $@thin (Builtin.Int8, Builtin.NativeObject) -> () {
bb0(%0 : $Builtin.Int8, %1 : $Builtin.NativeObject):
  release_value %0 : $Builtin.Int8
  release_value %1 : $Builtin.NativeObject
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @retain_value_test
// CHECK: bb0([[TRIVIAL_TARGET:%[0-9]+]] : $Builtin.Int8, [[REFCOUNT_TARGET:%[0-9]+]] : $Builtin.NativeObject):
// CHECK-NEXT: strong_retain [[REFCOUNT_TARGET]] : $Builtin.NativeObject
// CHECK-NEXT: tuple ([[TRIVIAL_TARGET]] : $Builtin.Int8, [[REFCOUNT_TARGET]] : $Builtin.NativeObject)
// CHECK-NEXT: return
sil @retain_value_test : $@thin (Builtin.Int8, Builtin.NativeObject) -> (Builtin.Int8, Builtin.NativeObject) {
bb0(%0 : $Builtin.Int8, %1 : $Builtin.NativeObject):
  retain_value %0 : $Builtin.Int8
  retain_value %1 : $Builtin.NativeObject
  %4 = tuple(%0 : $Builtin.Int8, %1 : $Builtin.NativeObject)
  return %4 : $(Builtin.Int8, Builtin.NativeObject)
}

// CHECK-LABEL: sil @a2p_p2a_test
// CHECK: bb0([[ADR:%[0-9]+]] : $*Builtin.Word, [[RAWPTR:%[0-9]+]] : $Builtin.RawPointer):
// CHECK-NEXT: load
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @a2p_p2a_test : $@thin (@inout Builtin.Word, Builtin.RawPointer) -> (Builtin.Word, Builtin.RawPointer) {
bb0(%0 : $*Builtin.Word, %1 : $Builtin.RawPointer):
  %2 = address_to_pointer %0 : $*Builtin.Word to $Builtin.RawPointer
  %3 = pointer_to_address %1 : $Builtin.RawPointer to $*Builtin.Word
  %4 = pointer_to_address %2 : $Builtin.RawPointer to $*Builtin.Word
  %5 = address_to_pointer %3 : $*Builtin.Word to $Builtin.RawPointer
  %6 = load %4 : $*Builtin.Word
  %7 = tuple(%6 : $Builtin.Word, %5 : $Builtin.RawPointer)
  return %7 : $(Builtin.Word, Builtin.RawPointer)
}

// CHECK-LABEL: sil @a2p_p2a_reinterpret_cast_word_raw_pointer
// CHECK: bb0
// CHECK-NEXT: unchecked_addr_cast
// CHECK-NEXT: load
// CHECK-NEXT: return
sil @a2p_p2a_reinterpret_cast_word_raw_pointer : $@thin (@inout Builtin.Word, Builtin.RawPointer) -> Int32 {
bb0(%0 : $*Builtin.Word, %1 : $Builtin.RawPointer):
  %2 = address_to_pointer %0 : $*Builtin.Word to $Builtin.RawPointer
  %3 = pointer_to_address %2 : $Builtin.RawPointer to $*Int32
  %4 = load %3 : $*Int32
  return %4 : $Int32
}

// CHECK-LABEL: sil @sil_extract_of_string
//
// Make sure we only forward the first field of the string_literal
// instead of the whole string literal. Otherwise we run into arity
// issues.
sil @sil_extract_of_string : $@thin () -> Builtin.Word {
  %0 = string_literal utf8 ""
  %l1 = integer_literal $Builtin.Word, 0
  %1 = struct $StringData (%l1 : $Builtin.Word)
  %2 = struct_extract %1 : $StringData, #StringData.size
  return %2 : $Builtin.Word
}

class C {}

enum U {
  init()
  case X
  case Y(Builtin.Int64)
  case Z(C)
}

// CHECK-LABEL: sil @sil_destroyvalue_of_enum
// CHECK: bb0([[TYPE_ARG:%[0-9]+]] : $@thin U.Type, [[CLASS_ARG:%[0-9]+]] : $C):
// CHECK-NEXT: enum $U, #U.X!enumelt
// CHECK-NEXT: integer_literal $Builtin.Int64, 32
// CHECK-NEXT: enum $U, #U.Y!enumelt.1, {{%[0-9]+}} : $Builtin.Int64
// CHECK-NEXT: [[INVALID_CASE:%[0-9]+]] = enum $U, #U.Z!enumelt.1, {{%[0-9]+}} : $C
// CHECK-NEXT: strong_release [[CLASS_ARG]] : $C
// CHECK-NEXT: tuple ({{%[0-9]+}} : $U, {{%[0-9]+}} : $U, [[INVALID_CASE]] : $U)
// CHECK-NEXT: return
//
// release_value  of an  enum without  any payload  or with  a trivial
// typed payload  is a  no-op. Leave  enums with  non-trivial payloads
// alone.
//
// rdar://15568314
sil @sil_destroyvalue_of_enum : $@thin (@thin U.Type, C) -> (U, U, U) {
bb0(%0 : $@thin U.Type, %1 : $C):
  %2 = enum $U, #U.X!enumelt
  release_value %2 : $U
  %3 = integer_literal $Builtin.Int64, 32
  %4 = enum $U, #U.Y!enumelt.1, %3 : $Builtin.Int64
  release_value %4 : $U
  %5 = enum $U, #U.Z!enumelt.1, %1 : $C
  release_value %5 : $U
  %6 = tuple(%2 : $U, %4 : $U, %5 : $U)
  return %6 : $(U, U, U)
}

// CHECK-LABEL: sil @sil_copyvalue_of_enum
// CHECK: bb0([[TYPE_ARG:%[0-9]+]] : $@thin U.Type, [[CLASS_ARG:%[0-9]+]] : $C):
// CHECK-NEXT: enum $U, #U.X!enumelt
// CHECK-NEXT: integer_literal $Builtin.Int64, 32
// CHECK-NEXT: enum $U, #U.Y!enumelt.1, {{%[0-9]+}} : $Builtin.Int64
// CHECK-NEXT: [[INVALID_CASE:%[0-9]+]] = enum $U, #U.Z!enumelt.1, {{%[0-9]+}} : $C
// CHECK-NEXT: strong_retain [[CLASS_ARG]] : $C
// CHECK-NEXT: tuple ({{%[0-9]+}} : $U, {{%[0-9]+}} : $U, [[INVALID_CASE]] : $U)
// CHECK-NEXT: return
//
// copy of an enum without any payload or with a trivial typed payload
// is a no-op. Leave enums with non-trivial payloads alone.
//
// rdar://15568314
sil @sil_copyvalue_of_enum : $@thin (@thin U.Type, C) -> (U, U, U) {
bb0(%0 : $@thin U.Type, %1 : $C):
  %2 = enum $U, #U.X!enumelt
  retain_value %2 : $U
  %3 = integer_literal $Builtin.Int64, 32
  %4 = enum $U, #U.Y!enumelt.1, %3 : $Builtin.Int64
  retain_value %4 : $U
  %5 = enum $U, #U.Z!enumelt.1, %1 : $C
  retain_value %5 : $U
  %6 = tuple(%2 : $U, %4 : $U, %5 : $U)
  return %6 : $(U, U, U)
}

// RefToRawPointer pointer consumption.
//
// (ref_to_raw_pointer (unchecked_ref_cast x))
//    -> (ref_to_raw_pointer x)
// CHECK-LABEL: sil @ref_to_raw_pointer_unchecked_ref_cast_composition : $@thin (C) -> Builtin.RawPointer
// CHECK: bb0
// CHECK-NEXT: ref_to_raw_pointer
// CHECK-NEXT: return
sil @ref_to_raw_pointer_unchecked_ref_cast_composition : $@thin (C) -> Builtin.RawPointer {
bb0(%0 : $C):
  %1 = unchecked_ref_cast %0 : $C to $Builtin.NativeObject
  %2 = ref_to_raw_pointer %1 : $Builtin.NativeObject to $Builtin.RawPointer
  return %2 : $Builtin.RawPointer
}

// CHECK-LABEL: sil @downcast_upcast_roundtrip
// CHECK: bb0
// CHECK-NEXT: return
sil @downcast_upcast_roundtrip : $@thin <T_0_0, T_0_1> (HeapBufferStorage<T_0_0, T_0_1>) -> HeapBufferStorage<T_0_0, T_0_1> {
bb0(%0 : $HeapBufferStorage<T_0_0, T_0_1>):
  %2 = upcast %0 : $HeapBufferStorage<T_0_0, T_0_1> to $RawBuffer // user: %3
  %3 = unconditional_checked_cast downcast %2 : $RawBuffer to $HeapBufferStorage<T_0_0, T_0_1>
  return %3 : $HeapBufferStorage<T_0_0, T_0_1>
}

// CHECK-LABEL: sil @cond_fail_applied_to_zero_removal
// CHECK: bb0
// CHECK-NEXT: cond_fail
// CHECK-NEXT: tuple ()
// CHECK-NEXT: return
sil @cond_fail_applied_to_zero_removal : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  cond_fail %0 : $Builtin.Int1
  %1 = integer_literal $Builtin.Int1, 0
  cond_fail %1 : $Builtin.Int1
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil @release_then_retain_peephole
// CHECK: bb0
// CHECK-NOT: strong_release
// CHECK-NOT: strong_retain
// CHECK-NOT: retain_value
// CHECK-NOT: release_value
// CHECK-NEXT: return
sil @release_then_retain_peephole : $@thin (Builtin.NativeObject, FakeOptional<Builtin.NativeObject>) -> (Builtin.NativeObject) {
bb0(%0 : $Builtin.NativeObject, %1 : $FakeOptional<Builtin.NativeObject>):
  strong_release %0 : $Builtin.NativeObject
  strong_retain %0 : $Builtin.NativeObject
  release_value %1 : $FakeOptional<Builtin.NativeObject>
  retain_value %1 : $FakeOptional<Builtin.NativeObject>
  return %0 : $Builtin.NativeObject
}

// CHECK-LABEL: sil @unchecked_ref_cast_unchecked_ref_cast_round_trip
// CHECK: bb0
// CHECK-NEXT: return
sil @unchecked_ref_cast_unchecked_ref_cast_round_trip : $@thin <T_0_0, T_0_1> (HeapBufferStorage<T_0_0, T_0_1>) -> HeapBufferStorage<T_0_0, T_0_1> {
bb0(%0 : $HeapBufferStorage<T_0_0, T_0_1>):
  %1 = unchecked_ref_cast %0 : $HeapBufferStorage<T_0_0, T_0_1> to $Builtin.NativeObject
  %2 = unchecked_ref_cast %1 : $Builtin.NativeObject to $HeapBufferStorage<T_0_0, T_0_1>
  return %2 : $HeapBufferStorage<T_0_0, T_0_1>
}

// CHECK-LABEL: sil @raw_pointer_to_ref_ref_to_raw_pointer_round_trip
// CHECK: bb0
// CHECK-NEXT: return
sil @raw_pointer_to_ref_ref_to_raw_pointer_round_trip : $@thin (Builtin.RawPointer) -> Builtin.RawPointer {
bb0(%0 : $Builtin.RawPointer):
  %1 = raw_pointer_to_ref %0 : $Builtin.RawPointer to $C
  %2 = ref_to_raw_pointer %1 : $C to $Builtin.RawPointer
  return %2 : $Builtin.RawPointer
}

////////////////////////////////////////////
// Load Proj To GEP Load Canonicalization //
////////////////////////////////////////////

struct Y {
  var int : Builtin.Int64
  var ptr : Builtin.NativeObject
  var tup : (Builtin.Int32, Builtin.Int1)
}

struct X {
  var y : Y
  var t : (Builtin.NativeObject, Y)
}

sil @mix1 : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
sil @mix2 : $@thin (Builtin.NativeObject, Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()

// CHECK-LABEL: sil @load_proj_to_gep_load_canonicalization_no_rep_no_other_use_test : $@thin (@inout X) -> ()
// CHECK-NOT: struct_extract
// CHECK-NOT: tuple_extract
sil @load_proj_to_gep_load_canonicalization_no_rep_no_other_use_test : $@thin (@inout X) -> () {
bb0(%0 : $*X):
  %1 = load %0 : $*X
  %2 = struct_extract %1 : $X, #X.y
  %3 = struct_extract %2 : $Y, #Y.int
  %4 = struct_extract %2 : $Y, #Y.ptr
  %5 = struct_extract %2 : $Y, #Y.tup
  %6 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 0
  %7 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 1
  %8 = struct_extract %1 : $X, #X.t
  %9 = tuple_extract %8 : $(Builtin.NativeObject, Y), 0
  %10 = tuple_extract %8 : $(Builtin.NativeObject, Y), 1
  %11 = struct_extract %10 : $Y, #Y.int
  %12 = struct_extract %10 : $Y, #Y.ptr
  %13 = struct_extract %10 : $Y, #Y.tup
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 1
  %16 = function_ref @mix1 : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  apply %16(%3, %4, %6, %7) : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  %17 = function_ref @mix2 : $@thin (Builtin.NativeObject, Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  apply %17(%9, %11, %12, %14, %15) : $@thin (Builtin.NativeObject, Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  %18 = tuple()
  return %18 : $()
}

// CHECK-LABEL: sil @load_proj_to_gep_load_canonicalization_with_rep_no_other_use_test : $@thin (@inout X) -> ()
// CHECK-NOT: struct_extract
// CHECK-NOT: tuple_extract
// CHECK: apply {{%[0-9]+}}([[ARG1:%[0-9]+]], [[ARG2:%[0-9]+]], [[ARG3:%[0-9]+]], [[ARG4:%[0-9]+]]
// CHECK-NEXT: apply {{%[0-9]+}}([[ARG1]], [[ARG2]], [[ARG3]], [[ARG4]]
// CHECK-NOT: struct_extract
// CHECK-NOT: tuple_extract
sil @load_proj_to_gep_load_canonicalization_with_rep_no_other_use_test : $@thin (@inout X) -> () {
bb0(%0 : $*X):
  %1 = load %0 : $*X
  %2 = struct_extract %1 : $X, #X.y
  %3 = struct_extract %2 : $Y, #Y.int
  %4 = struct_extract %2 : $Y, #Y.ptr
  %5 = struct_extract %2 : $Y, #Y.tup
  %6 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 0
  %7 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 1
  %16 = function_ref @mix1 : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  apply %16(%3, %4, %6, %7) : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  %19 = struct_extract %2 : $Y, #Y.int
  %20 = struct_extract %2 : $Y, #Y.ptr
  %21 = struct_extract %2 : $Y, #Y.tup
  %22 = tuple_extract %21 : $(Builtin.Int32, Builtin.Int1), 0
  %23 = tuple_extract %21 : $(Builtin.Int32, Builtin.Int1), 1
  apply %16(%19, %20, %22, %23) : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  %18 = tuple()
  return %18 : $()
}

sil @disrupting_use : $@thin (Y) -> ()

// CHECK-LABEL: sil @load_proj_to_gep_load_canonicalization_no_rep_with_disrupting_use_test : $@thin (@inout X) -> ()
// CHECK: bb0
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_extract
// CHECK-NEXT: struct_extract
// CHECK-NEXT: struct_extract
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: function_ref
// CHECK-NEXT: function_ref
// CHECK-NEXT: apply
// CHECK-NEXT: function_ref
// CHECK-NEXT: function_ref
// CHECK-NEXT: apply
// CHECK-NEXT: function_ref
// CHECK-NEXT: function_ref
// CHECK-NEXT: apply
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @load_proj_to_gep_load_canonicalization_no_rep_with_disrupting_use_test : $@thin (@inout X) -> () {
bb0(%0 : $*X):
  %1 = load %0 : $*X
  %2 = struct_extract %1 : $X, #X.y
  %3 = struct_extract %2 : $Y, #Y.int
  %4 = struct_extract %2 : $Y, #Y.ptr
  %5 = struct_extract %2 : $Y, #Y.tup
  %6 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 0
  %7 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 1
  %8 = struct_extract %1 : $X, #X.t
  %9 = tuple_extract %8 : $(Builtin.NativeObject, Y), 0
  %10 = tuple_extract %8 : $(Builtin.NativeObject, Y), 1
  %11 = struct_extract %10 : $Y, #Y.int
  %12 = struct_extract %10 : $Y, #Y.ptr
  %13 = struct_extract %10 : $Y, #Y.tup
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 1
  %16 = function_ref @mix1 : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  apply %16(%3, %4, %6, %7) : $@thin (Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  %17 = function_ref @mix2 : $@thin (Builtin.NativeObject, Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  apply %17(%9, %11, %12, %14, %15) : $@thin (Builtin.NativeObject, Builtin.Int64, Builtin.NativeObject, Builtin.Int32, Builtin.Int1) -> ()
  %18 = function_ref @disrupting_use : $@thin (Y) -> ()
  apply %18(%10) : $@thin (Y) -> ()
  %19 = tuple()
  return %19 : $()
}

sil @stringcore_invariant_check : $@thin (@owned _StringCore) -> @owned Optional<_CocoaString>
sil @reabstruction_thunk : $@thin (@out Optional<_CocoaString>, @owned @callee_owned () -> @owned Optional<_CocoaString>) -> ()

// CHECK-LABEL: sil @dead_closure_elimination : $@thin (@owned _StringCore) -> ()
// CHECK: bb0
// CHECK-NEXT: release_value
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @dead_closure_elimination : $@thin (@owned _StringCore) -> () {
bb0(%0 : $_StringCore):
  %1 = function_ref @stringcore_invariant_check : $@thin (@owned _StringCore) -> @owned Optional<_CocoaString>
  %2 = partial_apply %1(%0) : $@thin (@owned _StringCore) -> @owned Optional<_CocoaString>
  %3 = function_ref @reabstruction_thunk : $@thin (@out Optional<_CocoaString>, @owned @callee_owned () -> @owned Optional<_CocoaString>) -> ()
  %4 = partial_apply %3(%2) : $@thin (@out Optional<_CocoaString>, @owned @callee_owned () -> @owned Optional<_CocoaString>) -> ()
  strong_release %4 : $@callee_owned (@out Optional<_CocoaString>) -> ()
  %5 = tuple()
  return %5 : $()
}

class C1 {}
class C2 : C1 {}
class C3 : C2 {}

// CHECK-LABEL: sil @upcast_upcast_merge
// CHECK-NEXT: bb0
// CHECK-NEXT: upcast
// CHECK-NEXT: return
sil @upcast_upcast_merge : $@thin(C3) -> C1 {
bb0(%0 : $C3):
  %1 = upcast %0 : $C3 to $C2
  %2 = upcast %1 : $C2 to $C1
  return %2 : $C1
}


struct XS {
  var m: Int
  var k: Float
  init(x: XS)
}

//CHECK-LABEL: strc_from_extr
//CHECK-NOT: struct_extract
//CHECK-NOT: struct
//CHECK: return
sil @strc_from_extr : $@thin (XS, @thin XS.Type) -> XS {
bb0(%0 : $XS, %1 : $@thin XS.Type):
  %2 = struct_extract %0 : $XS, #XS.m
  %3 = struct_extract %0 : $XS, #XS.k
  %4 = struct $XS (%2 : $Int, %3 : $Float)
  return %4 : $XS
}

//CHECK-LABEL: tup_from_extr_tup
//CHECK-NOT: tuple_extract
//CHECK-NOT: tuple
//CHECK: return
sil @tup_from_extr_tup : $@thin () -> (Int, Int) {
bb0:
  // function_ref x
  %0 = function_ref @tup_from_extr_tup : $@thin () -> (Int, Int)  // user: %1
  %1 = apply %0() : $@thin () -> (Int, Int)       // users: %2, %3
  %2 = tuple_extract %1 : $(Int, Int), 0          // user: %4
  %3 = tuple_extract %1 : $(Int, Int), 1          // user: %4
  %4 = tuple (%2 : $Int, %3 : $Int)               // user: %5
  return %4 : $(Int, Int)                         // id: %5
}

//CHECK-LABEL: apply_and_pa_merge
//CHECK-NOT: partial_apply
//CHECK: %1 = function_ref @some_closure
//CHECK: %2 = partial_apply
//CHECK: function_ref @print_a_number
//CHECK: strong_retain %2
//CHECK: apply %1
//CHECK: strong_release %2
//CHECK: apply
//CHECK: strong_release %2
//CHECK: return
sil @apply_and_pa_merge : $@thin (Int) -> () {
bb0(%0 : $Int):
  %1 = function_ref @some_closure : $@thin (Int) -> Int // user: %2
  %2 = partial_apply %1(%0) : $@thin (Int) -> Int // users: %4, %5, %7
  %3 = function_ref @print_a_number : $@thin (Int) -> () // user: %6
  strong_retain %2 : $@callee_owned () -> Int     // id: %4
  %5 = apply %2() : $@callee_owned () -> Int      // user: %6
  %6 = apply %3(%5) : $@thin (Int) -> ()
  strong_release %2 : $@callee_owned () -> Int    // id: %7
  %8 = tuple ()                                   // user: %9
  return %8 : $()                                 // id: %9
}

sil @some_closure : $@thin (Int) -> Int
sil @print_a_number : $@thin (Int) -> ()

//CHECK-LABEL: remove_init_ex
//CHECK: alloc_stack $Bool
//CHECK-NOT: init_existential
//CHECK: return
sil @remove_init_ex : $@thin (Int) -> () {
bb0(%0 : $Int):
  %1 = alloc_stack $LogicValue
  %2 = init_existential %1#1 : $*LogicValue, $*Bool
  %3 = integer_literal $Builtin.Int1, 1
  %4 = struct $Bool (%3 : $Builtin.Int1)
  store %4 to %2 : $*Bool
  destroy_addr %1#1 : $*LogicValue
  dealloc_stack %1#0 : $*@local_storage LogicValue
  %8 = tuple ()
  return %8 : $()
}

// CHECK-LABEL: sil @generic_is_objc
sil @generic_is_objc : $@thin <T> (@in T) -> Bool {
bb0(%0 : $*T):
// CHECK: [[TYPE:%[a-zA-Z0-9]+]] = metatype $@thick [[ARCH:[a-zA-Z]+]].Type
  %1 = metatype $@thick T.Type                    // user: %3
// CHECK: [[FUNCTION:%[a-zA-Z0-9]+]] = builtin_function_ref "canBeClass"
  %2 = builtin_function_ref "canBeClass" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Int1 // user: %3
// CHECK: apply [[FUNCTION]]<[[ARCH]]>([[TYPE]])
  %3 = apply %2<T>(%1) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Int1 // user: %4
  %4 = struct $Bool (%3 : $Builtin.Int1)          // user: %6
  destroy_addr %0 : $*T                           // id: %5
  return %4 : $Bool                               // id: %6
}

// CHECK-LABEL: sil @is_int_objc
sil @is_int_objc : $@thin (Int) -> Bool {
bb0(%0 : $Int):
  %1 = metatype $@thick Int.Type                  // user: %3
// CHECK-NOT: builtin_function_ref "canBeClass"
  %2 = builtin_function_ref "canBeClass" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Int1 // user: %3
// CHECK-NOT: apply
  %3 = apply %2<Int>(%1) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Int1 // user: %4
// CHECK: [[LITERAL:%[a-zA-Z0-9]+]] = integer_literal $Builtin.Int1, 0
// CHECK: [[RESULT:%[a-zA-Z0-9]+]] = struct $Bool ([[LITERAL]] : $Builtin.Int1)
  %4 = struct $Bool (%3 : $Builtin.Int1)          // user: %5
// CHECK: return [[RESULT]] : $Bool
  return %4 : $Bool                               // id: %5
}

@objc class MyClass {
}

// CHECK-LABEL: sil @is_objc_class_objc
sil @is_objc_class_objc : $@thin (@owned MyClass) -> Bool {
bb0(%0 : $MyClass):
  %1 = metatype $@thick MyClass.Type              // user: %3
// CHECK-NOT: builtin_function_ref "canBeClass"
  %2 = builtin_function_ref "canBeClass" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Int1 // user: %3
// CHECK-NOT: apply
  %3 = apply %2<MyClass>(%1) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Int1 // user: %4
// CHECK: [[LITERAL:%[a-zA-Z0-9]+]] = integer_literal $Builtin.Int1, -1
// CHECK: [[RESULT:%[a-zA-Z0-9]+]] = struct $Bool ([[LITERAL]] : $Builtin.Int1)
  %4 = struct $Bool (%3 : $Builtin.Int1)          // user: %6
  strong_release %0 : $MyClass                    // id: %5
// CHECK: return [[RESULT]] : $Bool
  return %4 : $Bool                               // id: %6
}

// CHECK-LABEL: sil @constant_expect_hint
// CHECK: bb0:
// CHECK-NEXT: [[INT1:%[0-9]+]] = integer_literal $Builtin.Int1, 0
// CHECK-NEXT: [[INT2:%[0-9]+]] = integer_literal $Builtin.Int32, 5
// CHECK-NEXT: [[INT3:%[0-9]+]] = integer_literal $Builtin.Int64, 32
// CHECK-NEXT: [[TUPLE:%[0-9]+]] = tuple ([[INT1]] : $Builtin.Int1, [[INT2]] : $Builtin.Int32, [[INT3]] : $Builtin.Int64)
// CHECK-NEXT: return [[TUPLE]]
// CHECK-NEXT: }
sil @constant_expect_hint : $@thin () -> (Builtin.Int1, Builtin.Int32, Builtin.Int64) {
bb0:
  %0 = integer_literal $Builtin.Int1, 0
  %1 = integer_literal $Builtin.Int32, 5
  %2 = integer_literal $Builtin.Int64, 32

  %3 = integer_literal $Builtin.Int1, 1
  %4 = integer_literal $Builtin.Int32, 400
  %5 = integer_literal $Builtin.Int64, 5000

  %6 = builtin_function_ref "int_expect_Int1" : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  %7 = builtin_function_ref "int_expect_Int32" : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32
  %8 = builtin_function_ref "int_expect_Int64" : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64

  %9 = apply %6(%0, %3) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  %10 = apply %7(%1, %4) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32
  %11 = apply %8(%2, %5) : $@thin (Builtin.Int64, Builtin.Int64) -> Builtin.Int64

  %12 = tuple (%9 : $Builtin.Int1, %10 : $Builtin.Int32, %11 : $Builtin.Int64)
  return %12 : $(Builtin.Int1, Builtin.Int32, Builtin.Int64)
}

// CHECK-LABEL: sil @enum_promotion_of_concrete_types
// CHECK: bb0([[INT_PTR:%[0-9]+]]
// CHECK-NEXT: [[ALLOCA1:%[0-9]+]] = alloc_stack $FakeOptional<Builtin.Int1>
// CHECK-NEXT: [[ENUM1:%[0-9]+]] = enum $FakeOptional<Builtin.Int1>, #FakeOptional.None!enumelt
// CHECK-NEXT: store [[ENUM1]] to [[ALLOCA1]]#1
// CHECK-NEXT: [[ALLOCA2:%[0-9]+]] = alloc_stack $FakeOptional<Builtin.Int1>
// CHECK-NEXT: [[INT:%[0-9]+]] = load [[INT_PTR]] : $*Builtin.Int1
// CHECK-NEXT: [[ENUM2:%[0-9]+]] = enum $FakeOptional<Builtin.Int1>, #FakeOptional.Some!enumelt.1, [[INT]] : $Builtin.Int1
// CHECK-NEXT: store [[ENUM2]] to [[ALLOCA2]]#1 : $*FakeOptional<Builtin.Int1>
// CHECK-NEXT: [[RESULT1:%[0-9]+]] = load [[ALLOCA1:%[0-9]+]]#1
// CHECK-NEXT: [[RESULT2:%[0-9]+]] = load [[ALLOCA2:%[0-9]+]]#1
// CHECK-NEXT: [[RESULT:%[0-9]+]] = tuple ([[RESULT1]] : $FakeOptional<Builtin.Int1>, [[RESULT2]] : $FakeOptional<Builtin.Int1>)
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: return [[RESULT]]
sil @enum_promotion_of_concrete_types : $@thin (@in Builtin.Int1) -> (FakeOptional<Builtin.Int1>, FakeOptional<Builtin.Int1>) {
bb0(%0 : $*Builtin.Int1):
  %1 = alloc_stack $FakeOptional<Builtin.Int1>
  inject_enum_addr %1#1 : $*FakeOptional<Builtin.Int1>, #FakeOptional.None!enumelt

  %2 = integer_literal $Builtin.Int1, 1
  %3 = alloc_stack $FakeOptional<Builtin.Int1>
  %4 = init_enum_data_addr %3#1 : $*FakeOptional<Builtin.Int1>, #FakeOptional.Some!enumelt.1
  %5 = load %0 : $*Builtin.Int1
  store %5 to %4 : $*Builtin.Int1
  inject_enum_addr %3#1 : $*FakeOptional<Builtin.Int1>, #FakeOptional.Some!enumelt.1

  %6 = load %1#1 : $*FakeOptional<Builtin.Int1>
  %7 = load %3#1 : $*FakeOptional<Builtin.Int1>

  %8 = tuple(%6 : $FakeOptional<Builtin.Int1>, %7 : $FakeOptional<Builtin.Int1>)

  dealloc_stack %3#0 : $*@local_storage FakeOptional<Builtin.Int1>
  dealloc_stack %1#0 : $*@local_storage FakeOptional<Builtin.Int1>
  return %8 : $(FakeOptional<Builtin.Int1>, FakeOptional<Builtin.Int1>)
}

// Negative test corresponding to the previous test.
// CHECK-LABEL: sil @no_enum_promotion_of_non_concrete_types
// CHECK: bb0
// CHECK-NEXT: alloc_stack $FakeOptional<T>
// CHECK-NEXT: inject_enum_addr {{%[0-9]+}}#1 : $*FakeOptional<T>, #FakeOptional.None!enumelt
// CHECK-NEXT: alloc_stack $FakeOptional<T>
// CHECK-NEXT: init_enum_data_addr {{%[0-9]+}}#1 : $*FakeOptional<T>, #FakeOptional.Some!enumelt.1
// CHECK-NEXT: copy_addr
// CHECK-NEXT:  inject_enum_addr
// CHECK-NEXT: cond_br
// CHECK: bb1:
// CHECK-NEXT: br bb3
// CHECK: bb2:
// CHECK-NEXT: br bb3
// CHECK: bb3
// CHECK-NEXT: copy_addr
// CHECK-NEXT: tuple
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: dealloc_stack
// CHECK-NEXT: return
sil @no_enum_promotion_of_non_concrete_types : $@thin <T> (@out FakeOptional<T>, @inout T, Builtin.Int1) -> () {
bb0(%0 : $*FakeOptional<T>, %1 : $*T, %2 : $Builtin.Int1):
  %3 = alloc_stack $FakeOptional<T>
  inject_enum_addr %3#1 : $*FakeOptional<T>, #FakeOptional.None!enumelt
  %4 = alloc_stack $FakeOptional<T>
  %5 = init_enum_data_addr %4#1 : $*FakeOptional<T>, #FakeOptional.Some!enumelt.1
  copy_addr [take] %1 to [initialization] %5 : $*T
  inject_enum_addr %4#1 : $*FakeOptional<T>, #FakeOptional.Some!enumelt.1
  cond_br %2, bb1, bb2

bb1:
  br bb3(%3#1 : $*FakeOptional<T>)

bb2:
  br bb3(%4#1 : $*FakeOptional<T>)

bb3(%6 : $*FakeOptional<T>):
  copy_addr [take] %6 to [initialization] %0 : $*FakeOptional<T>
  %7 = tuple()
  dealloc_stack %4#0 : $*@local_storage FakeOptional<T>
  dealloc_stack %3#0 : $*@local_storage FakeOptional<T>
  return %7 : $()
}

// (ref-to-object-pointer-inst (object-pointer-to-ref-inst x) typeof(x)) -> x
// CHECK-LABEL: sil @unchecked_ref_cast_round_trip : $@thin (B) -> B {
// CHECK: bb0
// CHECK-NEXT: return
sil @unchecked_ref_cast_round_trip : $@thin (B) -> B {
bb0(%0 : $B):
  %1 = unchecked_ref_cast %0 : $B to $Builtin.NativeObject
  %2 = unchecked_ref_cast %1 : $Builtin.NativeObject to $B
  return %2 : $B
}

// (upcast X2->X (ref-to-object-pointer-inst (object-pointer-to-ref-inst x) typeof(x))) -> x
// CHECK-LABEL: sil @upcast_unchecked_ref_cast_round_trip : $@thin (E) -> E {
// CHECK: bb0
// CHECK-NEXT: return
sil @upcast_unchecked_ref_cast_round_trip : $@thin (E) -> E {
bb0(%0 : $E):
  %1 = upcast %0 : $E to $B
  %2 = unchecked_ref_cast %1 : $B to $Builtin.NativeObject
  %3 = unchecked_ref_cast %2 : $Builtin.NativeObject to $E
  return %3 : $E
}

// (load (upcast-addr %x)) -> (upcast-ref (load %x))
// CHECK-LABEL: sil @load_upcast_addr_to_upcast_ref_load_canonicalization : $@thin (@inout E) -> B {
// CHECK: bb0
// CHECK-NEXT: load
// CHECK-NEXT: upcast
// CHECK-NEXT: return
sil @load_upcast_addr_to_upcast_ref_load_canonicalization : $@thin (@inout E) -> B {
bb0(%0 : $*E):
  %1 = upcast %0 : $*E to $*B
  %2 = load %1 : $*B
  return %2 : $B
}

// CHECK-LABEL: sil @unchecked_enum_data_of_enum : $@thin () -> Builtin.Int1 {
// CHECK-NEXT: bb0
// CHECK-NEXT: integer_literal
// CHECK-NEXT: return
sil @unchecked_enum_data_of_enum : $@thin () -> Builtin.Int1 {
bb0:
  %0 = integer_literal $Builtin.Int1, 0
  %1 = enum $FakeOptional<Builtin.Int1>, #FakeOptional.Some!enumelt.1, %0 : $Builtin.Int1
  %2 = unchecked_enum_data %1 : $FakeOptional<Builtin.Int1>, #FakeOptional.Some!enumelt.1
  return %2 : $Builtin.Int1
}

// CHECK-LABEL: sil @unchecked_addr_cast_formation : $@thin (@inout Builtin.NativeObject) -> Builtin.Word {
// CHECK: bb0([[INPUT_PTR:%[0-9]+]] : $*Builtin.NativeObject):
// CHECK-NEXT: [[CAST_PTR:%[0-9]+]] = unchecked_addr_cast [[INPUT_PTR]] : $*Builtin.NativeObject to $*Builtin.Word
// CHECK-NEXT: load [[CAST_PTR]]
// CHECK-NEXT: return
sil @unchecked_addr_cast_formation : $@thin (@inout Builtin.NativeObject) -> Builtin.Word {
bb0(%0 : $*Builtin.NativeObject):
  %1 = address_to_pointer %0 : $*Builtin.NativeObject to $Builtin.RawPointer
  %2 = pointer_to_address %1 : $Builtin.RawPointer to $*Builtin.Word
  %3 = load %2 : $*Builtin.Word
  return %3 : $Builtin.Word
}

// CHECK-LABEL: sil @unchecked_addr_cast_forwarding : $@thin (@inout Builtin.NativeObject) -> Builtin.Word {
// CHECK: bb0([[INPUT_PTR:%[0-9]+]] : $*Builtin.NativeObject):
// CHECK-NEXT: [[CAST_PTR:%[0-9]+]] = unchecked_addr_cast [[INPUT_PTR]] : $*Builtin.NativeObject to $*Builtin.Word
// CHECK-NEXT: load [[CAST_PTR]]
// CHECK-NEXT: return
sil @unchecked_addr_cast_forwarding : $@thin (@inout Builtin.NativeObject) -> Builtin.Word {
bb0(%0 : $*Builtin.NativeObject):
  %1 = unchecked_addr_cast %0 : $*Builtin.NativeObject to $*Builtin.RawPointer
  %2 = unchecked_addr_cast %1 : $*Builtin.RawPointer to $*Builtin.Word
  %3 = load %2 : $*Builtin.Word
  return %3 : $Builtin.Word
}

class F : E {}

// CHECK-LABEL: sil @unchecked_ref_cast_forwarding : $@thin (B) -> F {
// CHECK: bb0([[INPUT_REF:%[0-9]+]] : $B):
// CHECK-NEXT: [[CAST_REF:%[0-9]+]] = unchecked_ref_cast [[INPUT_REF]] : $B to $F
// CHECK-NEXT: return
sil @unchecked_ref_cast_forwarding : $@thin (B) -> F {
bb0(%0 : $B):
  %1 = unchecked_ref_cast %0 : $B to $E
  %2 = unchecked_ref_cast %1 : $E to $F
  return %2 : $F
}

// CHECK-LABEL: sil @unchecked_ref_cast_formation : $@thin (B) -> F {
// CHECK: bb0([[INPUT_REF:%[0-9]+]] : $B):
// CHECK-NEXT: [[CAST_REF:%[0-9]+]] = unchecked_ref_cast [[INPUT_REF]] : $B to $F
// CHECK-NEXT: return
sil @unchecked_ref_cast_formation : $@thin (B) -> F {
bb0(%0 : $B):
  %1 = ref_to_raw_pointer %0 : $B to $Builtin.RawPointer
  %2 = raw_pointer_to_ref %1 : $Builtin.RawPointer to $F
  return %2 : $F
}

// CHECK-LABEL: sil @upcast_unchecked_ref_cast_roundtrip : $@thin (B) -> B {
// CHECK: bb0(
// CHECK-NEXT: return
sil @upcast_unchecked_ref_cast_roundtrip : $@thin (B) -> B {
bb0(%0 : $B):
  %1 = unchecked_ref_cast %0 : $B to $E
  %2 = upcast %1 : $E to $B
  return %2 : $B
}

// CHECK-LABEL: sil @unchecked_ref_cast_upcast_roundtrip : $@thin (E) -> E {
// CHECK: bb0
// CHECK-NEXT: return
sil @unchecked_ref_cast_upcast_roundtrip : $@thin (E) -> E {
bb0(%0 : $E):
  %1 = upcast %0 : $E to $B
  %2 = unchecked_ref_cast %1 : $B to $E
  return %2 : $E
}

// CHECK-LABEL: sil @unchecked_ref_cast_upcast_combine : $@thin (E) -> Builtin.NativeObject {
// CHECK: bb0
// CHECK-NEXT: unchecked_ref_cast
// CHECK-NEXT: return
sil @unchecked_ref_cast_upcast_combine : $@thin E -> Builtin.NativeObject {
bb0(%0 : $E):
  %1 = upcast %0 : $E to $B
  %2 = unchecked_ref_cast %1 : $B to $Builtin.NativeObject
  return %2 : $Builtin.NativeObject
}

// CHECK-LABEL: sil @unchecked_take_enum_data_addr_promotion : $@thin (@inout FakeOptional<B>) -> B {
// CHECK: bb0(%0 : $*FakeOptional<B>):
// CHECK-NEXT: switch_enum_addr
// CHECK: bb1:
// CHECK-NEXT: load
// CHECK-NEXT: unchecked_enum_data
// CHECK-NEXT: return
sil @unchecked_take_enum_data_addr_promotion : $@thin (@inout FakeOptional<B>) -> B {
bb0(%0 : $*FakeOptional<B>):
  %1 = switch_enum_addr %0 : $*FakeOptional<B>, case #FakeOptional.Some!enumelt.1: bb1, case #FakeOptional.None!enumelt: bb2

bb1:
  %2 = unchecked_take_enum_data_addr %0 : $*FakeOptional<B>, #FakeOptional.Some!enumelt.1
  %3 = load %2 : $*B
  return %3 : $B

bb2:
  unreachable
}

sil @weird_function : $@thin (@inout E, E, Builtin.Int1) -> ()

// CHECK-LABEL: sil @convert_function_simplification : $@thin (@inout B, B, Builtin.Int1) -> () {
// CHECK: bb0([[ADDR:%[0-9]+]] : $*B, [[REF:%[0-9]+]] : $B, [[NA:%[0-9]+]] : $Builtin.Int1):
// CHECK-NEXT: function_ref weird_function
// CHECK-NEXT: [[FUN:%[0-9]+]] = function_ref @weird_function : $@thin (@inout E, E, Builtin.Int1) -> ()
// CHECK-NEXT: [[ADDR_CAST:%[0-9]+]] = unchecked_addr_cast %0 : $*B to $*E
// CHECK-NEXT: [[REF_CAST:%[0-9]+]] = unchecked_ref_cast %1 : $B to $E
// CHECK-NEXT: apply [[FUN]]([[ADDR_CAST]], [[REF_CAST]], [[NA]])
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @convert_function_simplification : $@thin (@inout B, B, Builtin.Int1) -> () {
bb0(%0 : $*B, %1 : $B, %2 : $Builtin.Int1):
  %3 = function_ref @weird_function : $@thin (@inout E, E, Builtin.Int1) -> ()
  %4 = convert_function %3 : $@thin (@inout E, E, Builtin.Int1) -> () to $@thin (@inout B, B, Builtin.Int1) -> ()
  %5 = apply %4(%0, %1, %2) : $@thin (@inout B, B, Builtin.Int1) -> ()
  %6 = tuple()
  return %6 : $()
}

// CHECK-LABEL: sil @upcast_formation : $@thin (@inout E, E, @inout B) -> B {
// CHECK: bb0
// CHECK-NEXT: upcast
// CHECK-NEXT: load
// CHECK-NEXT: upcast
// CHECK-NEXT: store
// CHECK-NEXT: return
sil @upcast_formation : $@thin (@inout E, E, @inout B) -> (B) {
bb0(%0 : $*E, %1 : $E, %2 : $*B):
  %3 = unchecked_addr_cast %0 : $*E to $*B
  %4 = unchecked_ref_cast %1 : $E to $B
  %5 = load %3 : $*B
  store %5 to %2 : $*B
  return %4 : $B
}

// CHECK-LABEL: sil @dont_form_upcast_when_casts_are_identity : $@thin (@inout E, E, @inout E) -> E {
// CHECK: bb0
// CHECK-NEXT: load
// CHECK-NEXT: store
// CHECK-NEXT: return
sil @dont_form_upcast_when_casts_are_identity : $@thin (@inout E, E, @inout E) -> E {
bb0(%0 : $*E, %1 : $E, %2 : $*E):
  %3 = unchecked_addr_cast %0 : $*E to $*E
  %4 = unchecked_ref_cast %1 : $E to $E
  %5 = load %3 : $*E
  store %5 to %2 : $*E
  return %4 : $E
}

// CHECK-LABEL: sil @indexrawpointer_to_indexaddr : $@thin (Builtin.RawPointer, Builtin.Word) -> Int8 {
// CHECK: bb0
// CHECK-NEXT: pointer_to_address
// CHECK-NEXT: index_addr
// CHECK-NEXT: load
// CHECK-NEXT: return
sil @indexrawpointer_to_indexaddr : $@thin (Builtin.RawPointer, Builtin.Word) -> Int8 {
bb0(%0 : $Builtin.RawPointer, %1 : $Builtin.Word):
  %2 = builtin_function_ref "strideof" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word
  %3 = metatype $@thick Int8.Type
  %4 = apply %2<Int8>(%3) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word
  %5 = builtin_function_ref "smul_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %6 = integer_literal $Builtin.Int1, -1
  %7 = apply %5(%4, %1, %6) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %8 = tuple_extract %7 : $(Builtin.Word, Builtin.Int1), 0
  %9 = index_raw_pointer %0 : $Builtin.RawPointer, %8 : $Builtin.Word
  %10 = pointer_to_address %9 : $Builtin.RawPointer to $*Int8
  %11 = load %10 : $*Int8
  return %11 : $Int8
}

// CHECK-LABEL: sil @indexrawpointer_to_indexaddr_mismatched_metatype : $@thin (Builtin.RawPointer, Builtin.Word) -> Int32 {
// CHECK-NOT: index_addr
sil @indexrawpointer_to_indexaddr_mismatched_metatype : $@thin (Builtin.RawPointer, Builtin.Word) -> Int32 {
bb0(%0 : $Builtin.RawPointer, %1 : $Builtin.Word):
  %2 = builtin_function_ref "strideof" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word
  %3 = metatype $@thick Int8.Type
  %4 = apply %2<Int8>(%3) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word
  %5 = builtin_function_ref "smul_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %6 = integer_literal $Builtin.Int1, -1
  %7 = apply %5(%4, %1, %6) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %8 = tuple_extract %7 : $(Builtin.Word, Builtin.Int1), 0
  %9 = index_raw_pointer %0 : $Builtin.RawPointer, %8 : $Builtin.Word
  %10 = pointer_to_address %9 : $Builtin.RawPointer to $*Int32
  %11 = load %10 : $*Int32
  return %11 : $Int32
}

sil @eliminate_dead_thin_to_thick_function_fun : $@thin () -> ()

// CHECK-LABEL: sil @eliminate_dead_thin_to_thick_function : $@thin () -> () {
// CHECK: bb0
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @eliminate_dead_thin_to_thick_function : $@thin () -> () {
bb0:
  %0 = function_ref @eliminate_dead_thin_to_thick_function_fun : $@thin () -> ()
  %1 = thin_to_thick_function %0 : $@thin () -> () to $@callee_owned () -> ()  
  strong_release %1 : $@callee_owned () -> ()
  %2 = thin_to_thick_function %0 : $@thin () -> () to $@callee_owned () -> ()
  strong_retain %2 : $@callee_owned () -> ()
  %3 = tuple()
  return %3 : $()
}

// CHECK-LABEL: sil @ref_ops_of_enum_is_equivalent_to_ref_ops_of_payload : $@thin (Builtin.NativeObject) -> FakeOptional<Builtin.NativeObject> {
// CHECK: bb0
// CHECK-NEXT: enum
// CHECK-NEXT: strong_retain
// CHECK-NEXT: br bb1
// CHECK: bb1
// CHECK-NEXT: strong_release
// CHECK-NEXT: return
sil @ref_ops_of_enum_is_equivalent_to_ref_ops_of_payload : $@thin (Builtin.NativeObject) -> FakeOptional<Builtin.NativeObject> {
bb0(%0 : $Builtin.NativeObject):
  %1 = enum $FakeOptional<Builtin.NativeObject>, #FakeOptional.Some!enumelt.1, %0 : $Builtin.NativeObject
  retain_value %1 : $FakeOptional<Builtin.NativeObject>
  br bb1
  
bb1:
  release_value %1 : $FakeOptional<Builtin.NativeObject>
  return %1 : $FakeOptional<Builtin.NativeObject>
}

// CHECK-LABEL: sil @loadable_payload_address_only_enum_payload_promotion : $@thin (@in AddressOnlyEnum) -> Builtin.Int32 {
// CHECK: bb0
// CHECK-NEXT: unchecked_take_enum_data_addr
// CHECK-NEXT: load
// CHECK-NEXT: return
sil @loadable_payload_address_only_enum_payload_promotion : $@thin (@in AddressOnlyEnum) -> Builtin.Int32 {
bb0(%0 : $*AddressOnlyEnum):
  %1 = unchecked_take_enum_data_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.Loadable!enumelt.1
  %2 = load %1 : $*Builtin.Int32
  return %2 : $Builtin.Int32
}

sil @partial_apply_arg_fun : $@thin (Builtin.Int32, Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32, %1 : $Builtin.Int32):
  %2 = tuple()
  return %2 : $()
}
sil @partial_apply_generic_func : $@thin <T> () -> () {
bb0:
  %0 = tuple()
  return %0 : $()
}

sil @partial_apply_nothing : $@thin () -> () {
  %0 = tuple()
  return %0 : $()
}

// CHECK-LABEL: sil @partial_apply_without_subs_or_args_is_thin_to_thick
// CHECK: bb0:
// CHECK-NEXT: function_ref partial_apply_nothing
// CHECK-NEXT: function_ref @partial_apply_nothing
// CHECK-NEXT: thin_to_thick_function
// CHECK-NEXT: function_ref partial_apply_arg_fun
// CHECK-NEXT: function_ref @partial_apply_arg_fun
// CHECK-NEXT: integer_literal
// CHECK-NEXT: partial_apply
// CHECK-NEXT: function_ref partial_apply_generic_func
// CHECK-NEXT: function_ref @partial_apply_generic_func
// CHECK-NEXT: partial_apply
sil @partial_apply_without_subs_or_args_is_thin_to_thick : $@thin () -> (@callee_owned () -> ()) {
bb0:
  %0 = function_ref @partial_apply_nothing : $@thin () -> ()
  %1 = partial_apply %0() : $@thin () -> ()
  %2 = function_ref @partial_apply_arg_fun : $@thin (Builtin.Int32, Builtin.Int32) -> ()
  %3 = integer_literal $Builtin.Int32, 0
  %4 = partial_apply %2(%3) : $@thin (Builtin.Int32, Builtin.Int32) -> ()
  %5 = function_ref @partial_apply_generic_func : $@thin <T> () -> ()
  %6 = partial_apply %5<Builtin.Int32>() : $@thin <T> () -> ()
  return %1 : $@callee_owned () -> ()
}

// CHECK-LABEL: sil @dead_global_init_call : $@thin () -> () {
// CHECK-NEXT: bb0:
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @dead_global_init_call : $@thin () -> () {
bb0:
  %0 = function_ref @global_init_fun : $@thin () -> Builtin.RawPointer
  %1 = apply %0() : $@thin () -> Builtin.RawPointer
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @sub_pointers : $@thin (Builtin.RawPointer) -> Builtin.Word
// CHECK-NEXT: bb0
// CHECK-NEXT: integer_literal
// CHECK-NEXT: return
sil @sub_pointers : $@thin (Builtin.RawPointer) -> Builtin.Word {
bb0(%0 : $Builtin.RawPointer):
  %1 = integer_literal $Builtin.Word, 0
  %23 = index_raw_pointer %0 : $Builtin.RawPointer, %1 : $Builtin.Word
  %24 = builtin_function_ref "sub_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word
  %25 = builtin_function_ref "ptrtoint_Word" : $@thin (Builtin.RawPointer) -> Builtin.Word
  %26 = apply %25(%23) : $@thin (Builtin.RawPointer) -> Builtin.Word
  %27 = apply %25(%0) : $@thin (Builtin.RawPointer) -> Builtin.Word
  %28 = apply %24(%26, %27) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word
  return %28 : $Builtin.Word
}

// CHECK-LABEL: sil @sub_same_value : $@thin (Builtin.RawPointer) -> Builtin.Word
// CHECK-NEXT: bb0
// CHECK-NEXT: integer_literal
// CHECK-NEXT: return
sil @sub_same_value : $@thin (Builtin.RawPointer) -> Builtin.Word {
bb0(%0 : $Builtin.RawPointer):
  %24 = builtin_function_ref "sub_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word
  %25 = builtin_function_ref "ptrtoint_Word" : $@thin (Builtin.RawPointer) -> Builtin.Word
  %27 = apply %25(%0) : $@thin (Builtin.RawPointer) -> Builtin.Word
  %28 = apply %24(%27, %27) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word
  return %28 : $Builtin.Word
}

sil @generic_call_with_indirect_result : $@thin <T> (@in T, @out T) -> ()
sil @generic_call_without_indirect_result : $@thin <T> (@in T) -> Bool
sil @generic_call_with_direct_result : $@thin <T> (T) -> T

// CHECK-LABEL: sil @generic_partial_apply : $@thin () -> () {
// CHECK-NOT: partial_apply
sil @generic_partial_apply : $@thin () -> () {
bb0:
  %0 = function_ref @generic_call_with_indirect_result : $@thin <τ_0_0> (@in τ_0_0, @out τ_0_0) -> ()
  %1 = function_ref @generic_call_without_indirect_result : $@thin <τ_0_0> (@in τ_0_0) -> Bool
  %2 = partial_apply %0<Builtin.Int32>() : $@thin <τ_0_0> (@in τ_0_0, @out τ_0_0) -> ()
  %3 = alloc_stack $Builtin.Int32
  %4 = alloc_stack $Builtin.Int32
  %5 = apply %2(%3#1, %4#1) : $@callee_owned (@in Builtin.Int32, @out Builtin.Int32) -> ()
  %6 = partial_apply %1<Builtin.Int32>() : $@thin <τ_0_0> (@in τ_0_0) -> Bool
  %7 = apply %6(%3#1) : $@callee_owned (@in Builtin.Int32) -> Bool
  %8 = integer_literal $Builtin.Int32, 0
  %9 = function_ref @generic_call_with_direct_result : $@thin <τ_0_0> (τ_0_0) -> τ_0_0
  %10 = partial_apply %9<Builtin.Int32>() : $@thin <τ_0_0> (τ_0_0) -> τ_0_0
  %11 = apply %10(%8) : $@callee_owned (Builtin.Int32) -> Builtin.Int32
  %12 = partial_apply %9<Builtin.Int32>(%8) : $@thin <τ_0_0> (τ_0_0) -> τ_0_0
  %13 = apply %12() : $@callee_owned () -> Builtin.Int32
  dealloc_stack %4#0 : $*@local_storage Builtin.Int32
  dealloc_stack %3#0 : $*@local_storage Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

struct rs_E {
  var ptr : Builtin.NativeObject
  var i : Int
}
struct rs_F {
  var e : rs_E
}
struct rs_D {
  var i : Int
}
struct rs_C {
  var d : rs_D
}

struct rs_B {
  var ptr : Builtin.NativeObject
}
struct rs_A {
  var b : rs_B
}

enum TwoStateEnum {
  case State1(rs_A)
  case State2(rs_C)
}

// CHECK-LABEL: sil @reinterpretcast_simplification_unchecked_addr : $@thin (@inout FakeOptional<rs_A>, @inout FakeOptional<rs_C>, @inout FakeOptional<rs_F>, @inout TwoStateEnum, @inout TwoStateEnum) -> (Builtin.NativeObject, Int, Builtin.NativeObject, Builtin.NativeObject, Int) {
// CHECK: bb0([[INPTR_0:%[0-9]+]] : $*FakeOptional<rs_A>, [[INPTR_1:%[0-9]+]] : $*FakeOptional<rs_C>, [[INPTR_2:%[0-9]+]] : $*FakeOptional<rs_F>, [[INPTR_3:%[0-9]+]] : $*TwoStateEnum, [[INPTR_4:%[0-9]+]] : $*TwoStateEnum):
// CHECK-NEXT: [[RS_A:%[0-9]+]] = unchecked_take_enum_data_addr [[INPTR_0]] : $*FakeOptional<rs_A>, #FakeOptional.Some!enumelt.1
// CHECK-NEXT: [[RS_B:%[0-9]+]] = struct_element_addr [[RS_A]] : $*rs_A, #rs_A.b
// CHECK-NEXT: struct_element_addr [[RS_B]] : $*rs_B, #rs_B.ptr
// CHECK-NEXT: [[RS_C:%[0-9]+]] = unchecked_take_enum_data_addr [[INPTR_1]] : $*FakeOptional<rs_C>, #FakeOptional.Some!enumelt.1
// CHECK-NEXT: [[RS_D:%[0-9]+]] = struct_element_addr [[RS_C]] : $*rs_C, #rs_C.d
// CHECK-NEXT: struct_element_addr [[RS_D]] : $*rs_D, #rs_D.i
// CHECK-NEXT: unchecked_addr_cast [[INPTR_2]] : $*FakeOptional<rs_F> to $*Builtin.NativeObject
// CHECK-NEXT: [[RS_A_2:%[0-9]+]] = unchecked_take_enum_data_addr [[INPTR_3]] : $*TwoStateEnum, #TwoStateEnum.State1!enumelt.1
// CHECK-NEXT: [[RS_B_2:%[0-9]+]] = struct_element_addr [[RS_A_2]] : $*rs_A, #rs_A.b
// CHECK-NEXT: [[RS_PTR_2:%[0-9]+]] = struct_element_addr [[RS_B_2]] : $*rs_B, #rs_B.ptr
// CHECK-NEXT: unchecked_addr_cast [[INPTR_4]] : $*TwoStateEnum to $*Int
sil @reinterpretcast_simplification_unchecked_addr
  : $@thin (@inout FakeOptional<rs_A>, @inout FakeOptional<rs_C>, @inout FakeOptional<rs_F>, @inout TwoStateEnum,
            @inout TwoStateEnum)
     -> (Builtin.NativeObject, Int, Builtin.NativeObject, Builtin.NativeObject, Int) {
bb0(%0 : $*FakeOptional<rs_A>, %1 : $*FakeOptional<rs_C>, %2 : $*FakeOptional<rs_F>, %3 : $*TwoStateEnum, %4 : $*TwoStateEnum):
  %5 = unchecked_addr_cast %0 : $*FakeOptional<rs_A> to $*Builtin.NativeObject
  %6 = unchecked_addr_cast %1 : $*FakeOptional<rs_C> to $*Int
  %7 = unchecked_addr_cast %2 : $*FakeOptional<rs_F> to $*Builtin.NativeObject
  %8 = unchecked_addr_cast %3 : $*TwoStateEnum to $*Builtin.NativeObject
  %9 = unchecked_addr_cast %4 : $*TwoStateEnum to $*Int
  %10 = load %5 : $*Builtin.NativeObject
  %11 = load %6 : $*Int
  %12 = load %7 : $*Builtin.NativeObject
  %13 = load %8 : $*Builtin.NativeObject
  %14 = load %9 : $*Int
  %15 = tuple(%10 : $Builtin.NativeObject, %11 : $Int, %12 : $Builtin.NativeObject, %13 : $Builtin.NativeObject, %14 : $Int)
  return %15 : $(Builtin.NativeObject, Int, Builtin.NativeObject, Builtin.NativeObject, Int)
}
