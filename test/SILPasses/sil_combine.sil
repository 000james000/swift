// RUN: %sil-opt %s -sil-combine -verify | FileCheck %s

sil_stage canonical

import Builtin
import swift


//////////////////////
// Simple DCE Tests //
//////////////////////

// CHECK-LABEL: sil @dead_inst_elimination_one_bb
// CHECK-NOT: integer_literal $Builtin.Int64, 24
sil @dead_inst_elimination_one_bb : $@thin () -> () {
  %0 = integer_literal $Builtin.Int64, 24
  %1 = tuple()
  return %1 : $()
}

// CHECK-LABEL: sil @dead_inst_elimination_diamond
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK-NOT: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_diamond : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  %1 = integer_literal $Builtin.Int64, 24
  cond_br %0, bb1, bb2

bb1:
  %2 = integer_literal $Builtin.Int64, 48
  br bb3

bb2:
  %3 = integer_literal $Builtin.Int64, 96
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

sil @random_counter : $@thin () -> Builtin.Int1

// CHECK-LABEL: sil @dead_inst_elimination_loop
// CHECK: bb0
// CHECK-NOT: integer_literal
// CHECK: bb1
// CHECK: function_ref
// CHECK: apply
// CHECK-NOT: integer_literal
// CHECK: bb2
// CHECK-NOT: integer_literal
// CHECK: tuple
// CHECK: return
sil @dead_inst_elimination_loop : $@thin () -> () {
bb0:
  %1 = integer_literal $Builtin.Int64, 24
  br bb1

bb1:
  %2 = function_ref @random_counter : $@thin () -> Builtin.Int1
  %3 = apply %2() : $@thin () -> Builtin.Int1
  %4 = integer_literal $Builtin.Int64, 48
  cond_br %3, bb1, bb2

bb2:
  %5 = integer_literal $Builtin.Int64, 59
  %6 = tuple()
  return %6 : $()
}

// For now until the proper unreachable pruning code is committed for
// SILCombine, we should not dce dead instructions in unreachable code.

// CHECK-LABEL: sil @dead_inst_elimination_ignore_unreachable
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_ignore_unreachable : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Int64, 24
  br bb2

bb1:
  %1 = integer_literal $Builtin.Int64, 48
  br bb2

bb2:
  %2 = tuple()
  return %2 : $()
}

//////////////////////////////////////////////////////////
// Other DCE Tests taken from dead_code_elimination.sil //
//////////////////////////////////////////////////////////

class B { }
class E : B { }

sil @exit : $@thin @noreturn () -> () {
bb0:
  %1 = tuple ()
  return %1 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadInstructions
// CHECK: store
// CHECK: strong_retain
// CHECK-NOT: ref_to_object_pointer
// CHECK: strong_release
// CHECK-NEXT: strong_release
// CHECK-NOT: object_pointer_to_ref
sil @removeTriviallyDeadInstructions : $@thin (@owned B) -> () {
bb0(%0 : $B):
  %1 = alloc_box $B
  %2 = store %0 to %1#1 : $*B
  %3 = load %1#1 : $*B
  %4 = strong_retain %3 : $B
  %5 = ref_to_object_pointer %3 : $B to $Builtin.ObjectPointer
  %7 = strong_release %3 : $B
  %8 = strong_release %1#0 : $Builtin.ObjectPointer
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %6 = object_pointer_to_ref %5 : $Builtin.ObjectPointer to $B
  %11 = tuple()
  %12 = return %11 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadCrossBasicBlocks
// CHECK-NOT: ref_to_object_pointer
// CHECK: cond_br
// CHECK-NOT: object_pointer_to_ref
// CHECK: }
sil @removeTriviallyDeadCrossBasicBlocks : $@thin (@owned B, Builtin.Int1) -> () {
bb0(%0: $B, %1: $Builtin.Int1):
  %5 = ref_to_object_pointer %0 : $B to $Builtin.ObjectPointer
  %13 = cond_br %1, bb1, bb2
bb1:
  %22 = br bb2
bb2:
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %21 = object_pointer_to_ref %5 : $Builtin.ObjectPointer to $B
  %32 = tuple ()
  %33 = return %32 : $()
}

// CHECK-LABEL: sil @dead_use_of_alloc_stack
// CHECK: bb
// CHECK: alloc_stack
// CHECK: dealloc_stack
// CHECK: }
sil @dead_use_of_alloc_stack : $@thin () -> () {
bb0:
  %1 = alloc_stack $((), (), ())
  %2 = tuple_element_addr %1#1 : $*((), (), ()), 0
  dealloc_stack %1#0 : $*@local_storage ((), (), ())
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil @tuple_extract
// CHECK: bb
// CHECK-NEXT: return %0
sil @tuple_extract : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = tuple (%0 : $Int64, %0 : $Int64)
  %2 = tuple_extract %1 : $(Int64, Int64), 0
  return %2 : $Int64
}

// CHECK-LABEL: sil @fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NOT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: integer_literal
// CHECK-NEXT: br
sil @fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, -1
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, 0
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

// CHECK-LABEL: sil @do_not_fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
sil @do_not_fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, 0
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, -1
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

enum BoolLike { case true, false }

// CHECK-LABEL: sil @fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
sil @fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @do_not_fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
sil @do_not_fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @struct_extract_load_to_load_struct_element_addr
// CHECK: bb0(%0 : $*UInt8):
// CHECK-NEXT:  %1 = struct_element_addr %0 : $*UInt8, #value
// CHECK-NEXT:  %2 = load %1 : $*Builtin.Int8
// CHECK-NEXT:  %3 = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  %4 = struct_element_addr %0 : $*UInt8, #value
// CHECK-NEXT:  store %3 to %4 : $*Builtin.Int8
// CHECK-NEXT:  return %2 : $Builtin.Int8

sil @struct_extract_load_to_load_struct_element_addr : $@thin (@inout UInt8) -> (Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #value
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #value
  return %5 : $Builtin.Int8
}

// CHECK-LABEL: sil @destroy_value_test
// CHECK: bb0({{%[0-9]+}} : $Builtin.Int8, [[RELEASE_TARGET:%[0-9]+]] : $Builtin.ObjectPointer):
// CHECK-NEXT: strong_release [[RELEASE_TARGET]] : $Builtin.ObjectPointer
// CHECK-NEXT: tuple ()
// CHECK-NEXT: return
sil @destroy_value_test : $@thin (Builtin.Int8, Builtin.ObjectPointer) -> () {
bb0(%0 : $Builtin.Int8, %1 : $Builtin.ObjectPointer):
  destroy_value %0 : $Builtin.Int8
  destroy_value %1 : $Builtin.ObjectPointer
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @copy_value_test
// CHECK: bb0([[TRIVIAL_TARGET:%[0-9]+]] : $Builtin.Int8, [[REFCOUNT_TARGET:%[0-9]+]] : $Builtin.ObjectPointer):
// CHECK-NEXT: strong_retain [[REFCOUNT_TARGET]] : $Builtin.ObjectPointer
// CHECK-NEXT: tuple ([[TRIVIAL_TARGET]] : $Builtin.Int8, [[REFCOUNT_TARGET]] : $Builtin.ObjectPointer)
// CHECK-NEXT: return
sil @copy_value_test : $@thin (Builtin.Int8, Builtin.ObjectPointer) -> (Builtin.Int8, Builtin.ObjectPointer) {
bb0(%0 : $Builtin.Int8, %1 : $Builtin.ObjectPointer):
  %2 = copy_value %0 : $Builtin.Int8
  %3 = copy_value %1 : $Builtin.ObjectPointer
  %4 = tuple(%2 : $Builtin.Int8, %3 : $Builtin.ObjectPointer)
  return %4 : $(Builtin.Int8, Builtin.ObjectPointer)
}

// CHECK-LABEL: sil @a2p_p2a_test
// CHECK: bb0([[ADR:%[0-9]+]] : $*Builtin.Word, [[RAWPTR:%[0-9]+]] : $Builtin.RawPointer):
// CHECK-NEXT: load
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @a2p_p2a_test : $@thin (@inout Builtin.Word, Builtin.RawPointer) -> (Builtin.Word, Builtin.RawPointer) {
bb0(%0 : $*Builtin.Word, %1 : $Builtin.RawPointer):
  %2 = address_to_pointer %0 : $*Builtin.Word to $Builtin.RawPointer
  %3 = pointer_to_address %1 : $Builtin.RawPointer to $*Builtin.Word 
  %4 = pointer_to_address %2 : $Builtin.RawPointer to $*Builtin.Word
  %5 = address_to_pointer %3 : $*Builtin.Word to $Builtin.RawPointer
  %6 = load %4 : $*Builtin.Word
  %7 = tuple(%6 : $Builtin.Word, %5 : $Builtin.RawPointer)
  return %7 : $(Builtin.Word, Builtin.RawPointer)
}

struct StringData {
  var size: Builtin.Word
}

// CHECK-LABEL: sil @sil_extract_of_string
//
// Make sure we only forward the first field of the string_literal
// instead of the whole string literal. Otherwise we run into arity
// issues.
sil @sil_extract_of_string : $@thin () -> Builtin.Word {
  %0 = string_literal utf8 ""
  %1 = struct $StringData (%0#1 : $Builtin.Word)
  %2 = struct_extract %1 : $StringData, #size  
  return %2 : $Builtin.Word
}

class C {}

enum U {
  init()
  case X
  case Y(Builtin.Int64)
  case Z(C)
}

// CHECK-LABEL: sil @sil_destroyvalue_of_enum
// CHECK: bb0
// CHECK-NEXT: enum $U, #U.X!enumelt
// CHECK-NEXT: integer_literal $Builtin.Int64, 32
// CHECK-NEXT: enum $U, #U.Y!enumelt.1, {{%[0-9]+}} : $Builtin.Int64
// CHECK-NEXT: [[INVALID_CASE:%[0-9]+]] = enum $U, #U.Z!enumelt.1, {{%[0-9]+}} : $C
// CHECK-NEXT: destroy_value [[INVALID_CASE]] : $U
// CHECK-NEXT: tuple ({{%[0-9]+}} : $U, {{%[0-9]+}} : $U, [[INVALID_CASE]] : $U)
// CHECK-NEXT: return
//
// destroy_value  of an  enum without  any payload  or with  a trivial
// typed payload  is a  no-op. Leave  enums with  non-trivial payloads
// alone.
//
// rdar://15568314
sil @sil_destroyvalue_of_enum : $@thin (@thin U.metatype, C) -> (U, U, U) {
bb0(%0 : $@thin U.metatype, %1 : $C):
  %2 = enum $U, #U.X!enumelt
  destroy_value %2 : $U
  %3 = integer_literal $Builtin.Int64, 32
  %4 = enum $U, #U.Y!enumelt.1, %3 : $Builtin.Int64
  destroy_value %4 : $U
  %5 = enum $U, #U.Z!enumelt.1, %1 : $C
  destroy_value %5 : $U
  %6 = tuple(%2 : $U, %4 : $U, %5 : $U)  
  return %6 : $(U, U, U)
}

// CHECK-LABEL: sil @sil_copyvalue_of_enum
// CHECK: bb0
// CHECK-NEXT: enum $U, #U.X!enumelt
// CHECK-NEXT: integer_literal $Builtin.Int64, 32
// CHECK-NEXT: enum $U, #U.Y!enumelt.1, {{%[0-9]+}} : $Builtin.Int64
// CHECK-NEXT: [[INVALID_CASE:%[0-9]+]] = enum $U, #U.Z!enumelt.1, {{%[0-9]+}} : $C
// CHECK-NEXT: copy_value [[INVALID_CASE]] : $U
// CHECK-NEXT: tuple ({{%[0-9]+}} : $U, {{%[0-9]+}} : $U, [[INVALID_CASE]] : $U)
// CHECK-NEXT: return
//
// copy of an enum without any payload or with a trivial typed payload
// is a no-op. Leave enums with non-trivial payloads alone.
//
// rdar://15568314
sil @sil_copyvalue_of_enum : $@thin (@thin U.metatype, C) -> (U, U, U) {
bb0(%0 : $@thin U.metatype, %1 : $C):
  %2 = enum $U, #U.X!enumelt
  copy_value %2 : $U
  %3 = integer_literal $Builtin.Int64, 32
  %4 = enum $U, #U.Y!enumelt.1, %3 : $Builtin.Int64
  copy_value %4 : $U
  %5 = enum $U, #U.Z!enumelt.1, %1 : $C
  copy_value %5 : $U
  %6 = tuple(%2 : $U, %4 : $U, %5 : $U)
  return %6 : $(U, U, U)
}

// (ref_to_raw_pointer (ref_to_object_pointer x))
//    -> (ref_to_raw_pointer x)
// CHECK-LABEL: sil @ref_to_raw_pointer_ref_to_object_pointer_composition : $@thin (C) -> Builtin.RawPointer
// CHECK: bb0([[IN:%[0-9]+]] : $C):
// CHECK-NEXT: ref_to_object_pointer
// CHECK-NEXT: [[OUT:%[0-9]+]] = ref_to_raw_pointer [[IN]]
// CHECK-NEXT: return [[OUT]]
sil @ref_to_raw_pointer_ref_to_object_pointer_composition : $@thin (C) -> Builtin.RawPointer {
bb0(%0 : $C):
  %1 = ref_to_object_pointer %0 : $C to $Builtin.ObjectPointer
  %2 = ref_to_raw_pointer %1 : $Builtin.ObjectPointer to $Builtin.RawPointer
  return %2 : $Builtin.RawPointer
}

// CHECK-LABEL: sil @downcast_upcast_roundtrip
// CHECK: bb0
// CHECK-NEXT: return
sil @downcast_upcast_roundtrip : $@thin <T_0_0, T_0_1> (HeapBuffer<T_0_0, T_0_1>) -> HeapBuffer<T_0_0, T_0_1> {
bb0(%0 : $HeapBuffer<T_0_0, T_0_1>):
  %2 = upcast %0 : $HeapBuffer<T_0_0, T_0_1> to $RawBuffer // user: %3                                                                                     
  %3 = unconditional_checked_cast downcast %2 : $RawBuffer to $HeapBuffer<T_0_0, T_0_1>
  return %3 : $HeapBuffer<T_0_0, T_0_1>
}

