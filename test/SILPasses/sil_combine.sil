// RUN: %sil-opt %s -sil-combine -verify | FileCheck %s

sil_stage canonical

import Builtin
import Swift


//////////////////////
// Simple DCE Tests //
//////////////////////

// CHECK-LABEL: sil @dead_inst_elimination_one_bb
// CHECK-NOT: integer_literal $Builtin.Int64, 24
sil @dead_inst_elimination_one_bb : $@thin () -> () {
  %0 = integer_literal $Builtin.Int64, 24
  %1 = tuple()
  return %1 : $()
}

// CHECK-LABEL: sil @dead_inst_elimination_diamond
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK-NOT: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_diamond : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  %1 = integer_literal $Builtin.Int64, 24
  cond_br %0, bb1, bb2

bb1:
  %2 = integer_literal $Builtin.Int64, 48
  br bb3

bb2:
  %3 = integer_literal $Builtin.Int64, 96
  br bb3

bb3:
  %4 = tuple()
  return %4 : $()
}

sil @random_counter : $@thin () -> Builtin.Int1

// CHECK-LABEL: sil @dead_inst_elimination_loop
// CHECK: bb0
// CHECK-NOT: integer_literal
// CHECK: bb1
// CHECK: function_ref
// CHECK: apply
// CHECK-NOT: integer_literal
// CHECK: bb2
// CHECK-NOT: integer_literal
// CHECK: tuple
// CHECK: return
sil @dead_inst_elimination_loop : $@thin () -> () {
bb0:
  %1 = integer_literal $Builtin.Int64, 24
  br bb1

bb1:
  %2 = function_ref @random_counter : $@thin () -> Builtin.Int1
  %3 = apply %2() : $@thin () -> Builtin.Int1
  %4 = integer_literal $Builtin.Int64, 48
  cond_br %3, bb1, bb2

bb2:
  %5 = integer_literal $Builtin.Int64, 59
  %6 = tuple()
  return %6 : $()
}

// For now until the proper unreachable pruning code is committed for
// SILCombine, we should not dce dead instructions in unreachable code.

// CHECK-LABEL: sil @dead_inst_elimination_ignore_unreachable
// CHECK: bb0
// CHECK-NOT: integer_literal $Builtin.Int64, 24
// CHECK: bb1
// CHECK: integer_literal $Builtin.Int64, 48
sil @dead_inst_elimination_ignore_unreachable : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Int64, 24
  br bb2

bb1:
  %1 = integer_literal $Builtin.Int64, 48
  br bb2

bb2:
  %2 = tuple()
  return %2 : $()
}

//////////////////////////////////////////////////////////
// Other DCE Tests taken from dead_code_elimination.sil //
//////////////////////////////////////////////////////////

class B { }
class E : B { }

sil @exit : $@thin @noreturn () -> () {
bb0:
  %1 = tuple ()
  return %1 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadInstructions
// CHECK: store
// CHECK: strong_retain
// CHECK-NOT: ref_to_object_pointer
// CHECK: strong_release
// CHECK-NEXT: strong_release
// CHECK-NOT: object_pointer_to_ref
sil @removeTriviallyDeadInstructions : $@thin (@owned B) -> () {
bb0(%0 : $B):
  %1 = alloc_box $B
  %2 = store %0 to %1#1 : $*B
  %3 = load %1#1 : $*B
  %4 = strong_retain %3 : $B
  %5 = ref_to_object_pointer %3 : $B to $Builtin.ObjectPointer
  %7 = strong_release %3 : $B
  %8 = strong_release %1#0 : $Builtin.ObjectPointer
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %6 = object_pointer_to_ref %5 : $Builtin.ObjectPointer to $B
  %11 = tuple()
  %12 = return %11 : $()
}

// CHECK-LABEL: sil @removeTriviallyDeadCrossBasicBlocks
// CHECK-NOT: ref_to_object_pointer
// CHECK: cond_br
// CHECK-NOT: object_pointer_to_ref
// CHECK: }
sil @removeTriviallyDeadCrossBasicBlocks : $@thin (@owned B, Builtin.Int1) -> () {
bb0(%0: $B, %1: $Builtin.Int1):
  %5 = ref_to_object_pointer %0 : $B to $Builtin.ObjectPointer
  %13 = cond_br %1, bb1, bb2
bb1:
  %22 = br bb2
bb2:
  %9 = function_ref @exit : $@thin @noreturn () -> () // ret.exit : () -> ()
  %10 = apply %9() : $@thin @noreturn () -> ()
  %21 = object_pointer_to_ref %5 : $Builtin.ObjectPointer to $B
  %32 = tuple ()
  %33 = return %32 : $()
}

// CHECK-LABEL: sil @dead_use_of_alloc_stack
// CHECK: bb
// CHECK: alloc_stack
// CHECK: dealloc_stack
// CHECK: }
sil @dead_use_of_alloc_stack : $@thin () -> () {
bb0:
  %1 = alloc_stack $((), (), ())
  %2 = tuple_element_addr %1#1 : $*((), (), ()), 0
  dealloc_stack %1#0 : $*@local_storage ((), (), ())
  %3 = tuple ()
  return %3 : $()
}

// CHECK-LABEL: sil @tuple_extract
// CHECK: bb
// CHECK-NEXT: return %0
sil @tuple_extract : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = tuple (%0 : $Int64, %0 : $Int64)
  %2 = tuple_extract %1 : $(Int64, Int64), 0
  return %2 : $Int64
}

// CHECK-LABEL: sil @fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NOT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: integer_literal
// CHECK-NEXT: br
sil @fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, -1
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, 0
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

// CHECK-LABEL: sil @do_not_fold_integer_literal
// CHECK: bb
// CHECK: cond_br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: integer_literal
// CHECK-NEXT: br
sil @do_not_fold_integer_literal : $@thin (Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %1 = integer_literal $Builtin.Int1, 0
  br bb2(%1 : $Builtin.Int1)

bb3:
  %2 = integer_literal $Builtin.Int1, -1
  br bb2(%2 : $Builtin.Int1)

bb2(%3 : $Builtin.Int1):
  return %3 : $Builtin.Int1
}

enum BoolLike { case true, false }

// CHECK-LABEL: sil @fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NOT: enum
// CHECK-NEXT: br
sil @fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @do_not_fold_enum
// CHECK: bb
// CHECK: switch_enum
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
// CHECK: {{^bb}}
// CHECK-NEXT: enum
// CHECK-NEXT: br
sil @do_not_fold_enum : $@thin (BoolLike) -> BoolLike {
bb0(%0 : $BoolLike):
  switch_enum %0 : $BoolLike, case #BoolLike.true!enumelt: bb1, case #BoolLike.false!enumelt: bb2

bb1:
  %1 = enum $BoolLike, #BoolLike.false!enumelt
  br bb3(%1 : $BoolLike)

bb2:
  %2 = enum $BoolLike, #BoolLike.true!enumelt
  br bb3(%2 : $BoolLike)

bb3(%3 : $BoolLike):
  return %3 : $BoolLike
}

// CHECK-LABEL: sil @struct_extract_load_to_load_struct_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*UInt8):
// CHECK-NEXT:  [[IN_GEP:%[0-9]+]] = struct_element_addr [[IN]] : $*UInt8, #value
// CHECK-NEXT:  [[IN_LOADED:%[0-9]+]] = load [[IN_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  [[LITERAL:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  [[IN_GEP_STORE:%[0-9]+]] = struct_element_addr [[IN]] : $*UInt8, #value
// CHECK-NEXT:  store [[LITERAL]] to [[IN_GEP_STORE]] : $*Builtin.Int8
// CHECK-NEXT:  return [[IN_LOADED]] : $Builtin.Int8
sil @struct_extract_load_to_load_struct_element_addr : $@thin (@inout UInt8) -> (Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #value
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #value
  return %5 : $Builtin.Int8
}

// CHECK-LABEL: sil @tuple_extract_load_to_load_tuple_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*(Builtin.Int8, Builtin.Int8)):
// CHECK-NEXT:  [[IN_GEP:%[0-9]+]] = tuple_element_addr [[IN]] : $*(Builtin.Int8, Builtin.Int8), 0
// CHECK-NEXT:  [[IN_LOADED:%[0-9]+]] = load [[IN_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  [[LITERAL:%[0-9]+]] = integer_literal $Builtin.Int8, 1
// CHECK-NEXT:  [[IN_STORE_GEP:%[0-9]+]] = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
// CHECK-NEXT:  store [[LITERAL]] to [[IN_STORE_GEP]] : $*Builtin.Int8
// CHECK-NEXT:  return [[IN_LOADED]] : $Builtin.Int8
sil @tuple_extract_load_to_load_tuple_element_addr : $@thin (@inout (Builtin.Int8, Builtin.Int8)) -> (Builtin.Int8) {
bb0(%0 : $*(Builtin.Int8, Builtin.Int8)):
  %1 = load %0 : $*(Builtin.Int8, Builtin.Int8)
  %2 = integer_literal $Builtin.Int8, 1
  %3 = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int8), 0
  return %5 : $Builtin.Int8
}

// Do not perform the optimization of the input load has multiple uses.
//
// CHECK-LABEL: sil @multiple_use_struct_extract_load_to_load_struct_element_addr
// CHECK: bb0([[IN:%[0-9]+]] : $*UInt8):
// CHECK-NEXT: load
// CHECK-NEXT: integer_literal
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: store
// CHECK-NEXT: struct_extract
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @multiple_use_struct_extract_load_to_load_struct_element_addr : $@thin (@inout UInt8) -> (UInt8, Builtin.Int8) {
bb0(%0 : $*UInt8):
  %1 = load %0 : $*UInt8
  %2 = integer_literal $Builtin.Int8, 1
  %3 = struct_element_addr %0 : $*UInt8, #value
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = struct_extract %1 : $UInt8, #value
  %6 = tuple (%1 : $UInt8, %5 : $Builtin.Int8)
  return %6 : $(UInt8, Builtin.Int8)
}

// Do not perform the optimization of the input load has multiple uses.
//
// CHECK-LABEL: sil @multiple_use_tuple_extract_load_to_load_tuple_element_addr
// CHECK: bb0
// CHECK-NEXT: load
// CHECK-NEXT: integer_literal
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: store
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @multiple_use_tuple_extract_load_to_load_tuple_element_addr : $@thin (@inout (Builtin.Int8, Builtin.Int8)) -> ((Builtin.Int8, Builtin.Int8), Builtin.Int8) {
bb0(%0 : $*(Builtin.Int8, Builtin.Int8)):
  %1 = load %0 : $*(Builtin.Int8, Builtin.Int8)
  %2 = integer_literal $Builtin.Int8, 1
  %3 = tuple_element_addr %0 : $*(Builtin.Int8, Builtin.Int8), 0
  %4 = store %2 to %3 : $*Builtin.Int8
  %5 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int8), 0
  %6 = tuple (%1 : $(Builtin.Int8, Builtin.Int8), %5 : $Builtin.Int8)
  return %6 : $((Builtin.Int8, Builtin.Int8), Builtin.Int8)
}

// CHECK-LABEL: sil @destroy_value_test
// CHECK: bb0({{%[0-9]+}} : $Builtin.Int8, [[RELEASE_TARGET:%[0-9]+]] : $Builtin.ObjectPointer):
// CHECK-NEXT: strong_release [[RELEASE_TARGET]] : $Builtin.ObjectPointer
// CHECK-NEXT: tuple ()
// CHECK-NEXT: return
sil @destroy_value_test : $@thin (Builtin.Int8, Builtin.ObjectPointer) -> () {
bb0(%0 : $Builtin.Int8, %1 : $Builtin.ObjectPointer):
  destroy_value %0 : $Builtin.Int8
  destroy_value %1 : $Builtin.ObjectPointer
  %2 = tuple()
  return %2 : $()
}

// CHECK-LABEL: sil @copy_value_test
// CHECK: bb0([[TRIVIAL_TARGET:%[0-9]+]] : $Builtin.Int8, [[REFCOUNT_TARGET:%[0-9]+]] : $Builtin.ObjectPointer):
// CHECK-NEXT: strong_retain [[REFCOUNT_TARGET]] : $Builtin.ObjectPointer
// CHECK-NEXT: tuple ([[TRIVIAL_TARGET]] : $Builtin.Int8, [[REFCOUNT_TARGET]] : $Builtin.ObjectPointer)
// CHECK-NEXT: return
sil @copy_value_test : $@thin (Builtin.Int8, Builtin.ObjectPointer) -> (Builtin.Int8, Builtin.ObjectPointer) {
bb0(%0 : $Builtin.Int8, %1 : $Builtin.ObjectPointer):
  %2 = copy_value %0 : $Builtin.Int8
  %3 = copy_value %1 : $Builtin.ObjectPointer
  %4 = tuple(%2 : $Builtin.Int8, %3 : $Builtin.ObjectPointer)
  return %4 : $(Builtin.Int8, Builtin.ObjectPointer)
}

// CHECK-LABEL: sil @a2p_p2a_test
// CHECK: bb0([[ADR:%[0-9]+]] : $*Builtin.Word, [[RAWPTR:%[0-9]+]] : $Builtin.RawPointer):
// CHECK-NEXT: load
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @a2p_p2a_test : $@thin (@inout Builtin.Word, Builtin.RawPointer) -> (Builtin.Word, Builtin.RawPointer) {
bb0(%0 : $*Builtin.Word, %1 : $Builtin.RawPointer):
  %2 = address_to_pointer %0 : $*Builtin.Word to $Builtin.RawPointer
  %3 = pointer_to_address %1 : $Builtin.RawPointer to $*Builtin.Word 
  %4 = pointer_to_address %2 : $Builtin.RawPointer to $*Builtin.Word
  %5 = address_to_pointer %3 : $*Builtin.Word to $Builtin.RawPointer
  %6 = load %4 : $*Builtin.Word
  %7 = tuple(%6 : $Builtin.Word, %5 : $Builtin.RawPointer)
  return %7 : $(Builtin.Word, Builtin.RawPointer)
}

// CHECK-LABEL: sil @a2p_p2a_fail
// CHECK: address_to_pointer
// CHECK: pointer_to_address
// CHECK: return
sil @a2p_p2a_fail : $@thin (@inout Builtin.Word, Builtin.RawPointer) -> Int32 {
  bb0(%0 : $*Builtin.Word, %1 : $Builtin.RawPointer):
  %2 = address_to_pointer %0 : $*Builtin.Word to $Builtin.RawPointer
  %3 = pointer_to_address %2 : $Builtin.RawPointer to $*Int32
  %4 = load %3 : $*Int32
  return %4 : $Int32
}

struct StringData {
  var size: Builtin.Word
}

// CHECK-LABEL: sil @sil_extract_of_string
//
// Make sure we only forward the first field of the string_literal
// instead of the whole string literal. Otherwise we run into arity
// issues.
sil @sil_extract_of_string : $@thin () -> Builtin.Word {
  %0 = string_literal utf8 ""
  %l1 = integer_literal $Builtin.Word, 0
  %1 = struct $StringData (%l1 : $Builtin.Word)
  %2 = struct_extract %1 : $StringData, #size  
  return %2 : $Builtin.Word
}

class C {}

enum U {
  init()
  case X
  case Y(Builtin.Int64)
  case Z(C)
}

// CHECK-LABEL: sil @sil_destroyvalue_of_enum
// CHECK: bb0
// CHECK-NEXT: enum $U, #U.X!enumelt
// CHECK-NEXT: integer_literal $Builtin.Int64, 32
// CHECK-NEXT: enum $U, #U.Y!enumelt.1, {{%[0-9]+}} : $Builtin.Int64
// CHECK-NEXT: [[INVALID_CASE:%[0-9]+]] = enum $U, #U.Z!enumelt.1, {{%[0-9]+}} : $C
// CHECK-NEXT: destroy_value [[INVALID_CASE]] : $U
// CHECK-NEXT: tuple ({{%[0-9]+}} : $U, {{%[0-9]+}} : $U, [[INVALID_CASE]] : $U)
// CHECK-NEXT: return
//
// destroy_value  of an  enum without  any payload  or with  a trivial
// typed payload  is a  no-op. Leave  enums with  non-trivial payloads
// alone.
//
// rdar://15568314
sil @sil_destroyvalue_of_enum : $@thin (@thin U.Type, C) -> (U, U, U) {
bb0(%0 : $@thin U.Type, %1 : $C):
  %2 = enum $U, #U.X!enumelt
  destroy_value %2 : $U
  %3 = integer_literal $Builtin.Int64, 32
  %4 = enum $U, #U.Y!enumelt.1, %3 : $Builtin.Int64
  destroy_value %4 : $U
  %5 = enum $U, #U.Z!enumelt.1, %1 : $C
  destroy_value %5 : $U
  %6 = tuple(%2 : $U, %4 : $U, %5 : $U)  
  return %6 : $(U, U, U)
}

// CHECK-LABEL: sil @sil_copyvalue_of_enum
// CHECK: bb0
// CHECK-NEXT: enum $U, #U.X!enumelt
// CHECK-NEXT: integer_literal $Builtin.Int64, 32
// CHECK-NEXT: enum $U, #U.Y!enumelt.1, {{%[0-9]+}} : $Builtin.Int64
// CHECK-NEXT: [[INVALID_CASE:%[0-9]+]] = enum $U, #U.Z!enumelt.1, {{%[0-9]+}} : $C
// CHECK-NEXT: copy_value [[INVALID_CASE]] : $U
// CHECK-NEXT: tuple ({{%[0-9]+}} : $U, {{%[0-9]+}} : $U, [[INVALID_CASE]] : $U)
// CHECK-NEXT: return
//
// copy of an enum without any payload or with a trivial typed payload
// is a no-op. Leave enums with non-trivial payloads alone.
//
// rdar://15568314
sil @sil_copyvalue_of_enum : $@thin (@thin U.Type, C) -> (U, U, U) {
bb0(%0 : $@thin U.Type, %1 : $C):
  %2 = enum $U, #U.X!enumelt
  copy_value %2 : $U
  %3 = integer_literal $Builtin.Int64, 32
  %4 = enum $U, #U.Y!enumelt.1, %3 : $Builtin.Int64
  copy_value %4 : $U
  %5 = enum $U, #U.Z!enumelt.1, %1 : $C
  copy_value %5 : $U
  %6 = tuple(%2 : $U, %4 : $U, %5 : $U)
  return %6 : $(U, U, U)
}

// RefToRawPointer pointer consumption.
//
// (ref_to_raw_pointer (ref_to_object_pointer x))
//    -> (ref_to_raw_pointer x)
// CHECK-LABEL: sil @ref_to_raw_pointer_ref_to_object_pointer_composition : $@thin (C) -> Builtin.RawPointer
// CHECK: bb0
// CHECK-NEXT: ref_to_raw_pointer
// CHECK-NEXT: return
sil @ref_to_raw_pointer_ref_to_object_pointer_composition : $@thin (C) -> Builtin.RawPointer {
bb0(%0 : $C):
  %1 = ref_to_object_pointer %0 : $C to $Builtin.ObjectPointer
  %2 = ref_to_raw_pointer %1 : $Builtin.ObjectPointer to $Builtin.RawPointer
  return %2 : $Builtin.RawPointer
}

// CHECK-LABEL: sil @downcast_upcast_roundtrip
// CHECK: bb0
// CHECK-NEXT: return
sil @downcast_upcast_roundtrip : $@thin <T_0_0, T_0_1> (HeapBufferStorage<T_0_0, T_0_1>) -> HeapBufferStorage<T_0_0, T_0_1> {
bb0(%0 : $HeapBufferStorage<T_0_0, T_0_1>):
  %2 = upcast %0 : $HeapBufferStorage<T_0_0, T_0_1> to $RawBuffer // user: %3                                                                                     
  %3 = unconditional_checked_cast downcast %2 : $RawBuffer to $HeapBufferStorage<T_0_0, T_0_1>
  return %3 : $HeapBufferStorage<T_0_0, T_0_1>
}

// CHECK-LABEL: sil @cond_fail_applied_to_zero_removal
// CHECK: bb0
// CHECK-NEXT: cond_fail
// CHECK-NEXT: tuple ()
// CHECK-NEXT: return
sil @cond_fail_applied_to_zero_removal : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  cond_fail %0 : $Builtin.Int1
  %1 = integer_literal $Builtin.Int1, 0
  cond_fail %1 : $Builtin.Int1
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil @release_then_retain_peephole
// CHECK: bb0
// CHECK-NOT: strong_release
// CHECK-NOT: strong_retain
// CHECK-NEXT: return
sil @release_then_retain_peephole : $@thin (Builtin.ObjectPointer) -> (Builtin.ObjectPointer) {
bb0(%0 : $Builtin.ObjectPointer):
  strong_release %0 : $Builtin.ObjectPointer
  strong_retain %0 : $Builtin.ObjectPointer
  return %0 : $Builtin.ObjectPointer
}

// CHECK-LABEL: sil @object_pointer_to_ref_ref_to_object_pointer_round_trip
// CHECK: bb0
// CHECK-NEXT: return
sil @object_pointer_to_ref_ref_to_object_pointer_round_trip : $@thin <T_0_0, T_0_1> (HeapBufferStorage<T_0_0, T_0_1>) -> HeapBufferStorage<T_0_0, T_0_1> {
bb0(%0 : $HeapBufferStorage<T_0_0, T_0_1>):
  %1 = ref_to_object_pointer %0 : $HeapBufferStorage<T_0_0, T_0_1> to $Builtin.ObjectPointer
  %2 = object_pointer_to_ref %1 : $Builtin.ObjectPointer to $HeapBufferStorage<T_0_0, T_0_1>
  return %2 : $HeapBufferStorage<T_0_0, T_0_1>
}

// CHECK-LABEL: sil @raw_pointer_to_ref_ref_to_raw_pointer_round_trip
// CHECK: bb0
// CHECK-NEXT: return
sil @raw_pointer_to_ref_ref_to_raw_pointer_round_trip : $@thin (Builtin.RawPointer) -> Builtin.RawPointer {
bb0(%0 : $Builtin.RawPointer):
  %1 = raw_pointer_to_ref %0 : $Builtin.RawPointer to $C
  %2 = ref_to_raw_pointer %1 : $C to $Builtin.RawPointer
  return %2 : $Builtin.RawPointer
}

////////////////////////////////////////////
// Load Proj To GEP Load Canonicalization //
////////////////////////////////////////////

struct Y {
  var int : Builtin.Int64
  var ptr : Builtin.ObjectPointer
  var tup : (Builtin.Int32, Builtin.Int1)
}

struct X {
  var y : Y
  var t : (Builtin.ObjectPointer, Y)
}

sil @mix1 : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> () 
sil @mix2 : $@thin (Builtin.ObjectPointer, Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> () 

// CHECK-LABEL: sil @load_proj_to_gep_load_canonicalization_no_rep_no_other_use_test : $@thin (@inout X) -> ()
// CHECK-NOT: struct_extract
// CHECK-NOT: tuple_extract
sil @load_proj_to_gep_load_canonicalization_no_rep_no_other_use_test : $@thin (@inout X) -> () {
bb0(%0 : $*X):
  %1 = load %0 : $*X
  %2 = struct_extract %1 : $X, #y
  %3 = struct_extract %2 : $Y, #int
  %4 = struct_extract %2 : $Y, #ptr
  %5 = struct_extract %2 : $Y, #tup
  %6 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 0
  %7 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 1
  %8 = struct_extract %1 : $X, #t
  %9 = tuple_extract %8 : $(Builtin.ObjectPointer, Y), 0
  %10 = tuple_extract %8 : $(Builtin.ObjectPointer, Y), 1
  %11 = struct_extract %10 : $Y, #int
  %12 = struct_extract %10 : $Y, #ptr
  %13 = struct_extract %10 : $Y, #tup
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 1
  %16 = function_ref @mix1 : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  apply %16(%3, %4, %6, %7) : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  %17 = function_ref @mix2 : $@thin (Builtin.ObjectPointer, Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  apply %17(%9, %11, %12, %14, %15) : $@thin (Builtin.ObjectPointer, Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  %18 = tuple()
  return %18 : $()
}

// CHECK-LABEL: sil @load_proj_to_gep_load_canonicalization_with_rep_no_other_use_test : $@thin (@inout X) -> ()
// CHECK-NOT: struct_extract
// CHECK-NOT: tuple_extract
// CHECK: apply {{%[0-9]+}}([[ARG1:%[0-9]+]], [[ARG2:%[0-9]+]], [[ARG3:%[0-9]+]], [[ARG4:%[0-9]+]]
// CHECK-NEXT: apply {{%[0-9]+}}([[ARG1]], [[ARG2]], [[ARG3]], [[ARG4]]
// CHECK-NOT: struct_extract
// CHECK-NOT: tuple_extract
sil @load_proj_to_gep_load_canonicalization_with_rep_no_other_use_test : $@thin (@inout X) -> () {
bb0(%0 : $*X):
  %1 = load %0 : $*X
  %2 = struct_extract %1 : $X, #y
  %3 = struct_extract %2 : $Y, #int
  %4 = struct_extract %2 : $Y, #ptr
  %5 = struct_extract %2 : $Y, #tup
  %6 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 0
  %7 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 1
  %16 = function_ref @mix1 : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  apply %16(%3, %4, %6, %7) : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  %19 = struct_extract %2 : $Y, #int
  %20 = struct_extract %2 : $Y, #ptr
  %21 = struct_extract %2 : $Y, #tup
  %22 = tuple_extract %21 : $(Builtin.Int32, Builtin.Int1), 0
  %23 = tuple_extract %21 : $(Builtin.Int32, Builtin.Int1), 1
  apply %16(%19, %20, %22, %23) : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  %18 = tuple()
  return %18 : $()
}

sil @disrupting_use : $@thin (Y) -> ()

// CHECK-LABEL: sil @load_proj_to_gep_load_canonicalization_no_rep_with_disrupting_use_test : $@thin (@inout X) -> ()
// CHECK: bb0
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_element_addr
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: tuple_element_addr
// CHECK-NEXT: load
// CHECK-NEXT: struct_extract
// CHECK-NEXT: struct_extract
// CHECK-NEXT: struct_extract
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: tuple_extract
// CHECK-NEXT: function_ref
// CHECK-NEXT: function_ref
// CHECK-NEXT: apply
// CHECK-NEXT: function_ref
// CHECK-NEXT: function_ref
// CHECK-NEXT: apply
// CHECK-NEXT: function_ref
// CHECK-NEXT: function_ref
// CHECK-NEXT: apply
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @load_proj_to_gep_load_canonicalization_no_rep_with_disrupting_use_test : $@thin (@inout X) -> () {
bb0(%0 : $*X):
  %1 = load %0 : $*X
  %2 = struct_extract %1 : $X, #y
  %3 = struct_extract %2 : $Y, #int
  %4 = struct_extract %2 : $Y, #ptr
  %5 = struct_extract %2 : $Y, #tup
  %6 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 0
  %7 = tuple_extract %5 : $(Builtin.Int32, Builtin.Int1), 1
  %8 = struct_extract %1 : $X, #t
  %9 = tuple_extract %8 : $(Builtin.ObjectPointer, Y), 0
  %10 = tuple_extract %8 : $(Builtin.ObjectPointer, Y), 1
  %11 = struct_extract %10 : $Y, #int
  %12 = struct_extract %10 : $Y, #ptr
  %13 = struct_extract %10 : $Y, #tup
  %14 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 0
  %15 = tuple_extract %13 : $(Builtin.Int32, Builtin.Int1), 1
  %16 = function_ref @mix1 : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  apply %16(%3, %4, %6, %7) : $@thin (Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  %17 = function_ref @mix2 : $@thin (Builtin.ObjectPointer, Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  apply %17(%9, %11, %12, %14, %15) : $@thin (Builtin.ObjectPointer, Builtin.Int64, Builtin.ObjectPointer, Builtin.Int32, Builtin.Int1) -> ()
  %18 = function_ref @disrupting_use : $@thin (Y) -> ()
  apply %18(%10) : $@thin (Y) -> ()
  %19 = tuple()
  return %19 : $()
}

sil @stringcore_invariant_check : $@thin (@owned StringCore) -> @owned Optional<_CocoaString>
sil @reabstruction_thunk : $@thin (@out Optional<_CocoaString>, @owned @callee_owned () -> @owned Optional<_CocoaString>) -> ()

// CHECK-LABEL: sil @dead_closure_elimination : $@thin (@owned StringCore) -> ()
// CHECK: bb0
// CHECK-NEXT: destroy_value
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @dead_closure_elimination : $@thin (@owned StringCore) -> () {
bb0(%0 : $StringCore):
  %1 = function_ref @stringcore_invariant_check : $@thin (@owned StringCore) -> @owned Optional<_CocoaString>
  %2 = partial_apply %1(%0) : $@thin (@owned StringCore) -> @owned Optional<_CocoaString>
  %3 = function_ref @reabstruction_thunk : $@thin (@out Optional<_CocoaString>, @owned @callee_owned () -> @owned Optional<_CocoaString>) -> ()
  %4 = partial_apply %3(%2) : $@thin (@out Optional<_CocoaString>, @owned @callee_owned () -> @owned Optional<_CocoaString>) -> ()
  strong_release %4 : $@callee_owned (@out Optional<_CocoaString>) -> ()
  %5 = tuple()
  return %5 : $()
}
