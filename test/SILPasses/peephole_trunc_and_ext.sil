// RUN: %swift %s -emit-sil -O -o - -verify | FileCheck %s
sil_stage canonical

import Builtin
import Swift
import SwiftShims

// top_level_code
sil private @top_level_code : $@thin () -> () {
bb0:
  %0 = tuple ()                                   // user: %1
  return %0 : $()                                 // id: %1
}

// peephole: Word(Int64(x >> 1)) -> (x >> 1)
// CHECK-LABEL: sil @_TF4test29test_trunc_u_to_s_zext_lshr_1FSuSi : $@thin (UInt) -> Int
// CHECK: builtin_function_ref "lshr_Word"
// CHECK-NOT: builtin_function_ref "zextOrBitCast_Word_Int64"
// CHECK-NOT: builtin_function_ref "u_to_s_checked_conversion_Int64"
// CHECK-NOT: builtin_function_ref "truncOrBitCast_Int64_Word"
// CHECK: return
// test.test_trunc_u_to_s_zext_lshr_1 (Swift.UInt) -> Swift.Int
sil @_TF4test29test_trunc_u_to_s_zext_lshr_1FSuSi : $@thin (UInt) -> Int {
bb0(%0 : $UInt):
  debug_value %0 : $UInt  // let x                // id: %1
  %2 = integer_literal $Builtin.Word, 1           // user: %7
  br bb1                                          // id: %3

bb1:                                              // Preds: bb0
  br bb2                                          // id: %4

bb2:                                              // Preds: bb1
  %5 = builtin_function_ref "lshr_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %7
  %6 = struct_extract %0 : $UInt, #UInt.value     // user: %7
  %7 = apply %5(%6, %2) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %8
  %8 = struct $UInt (%7 : $Builtin.Word)          // user: %11
  br bb3                                          // id: %9

bb3:                                              // Preds: bb2
  %10 = builtin_function_ref "zextOrBitCast_Word_Int64" : $@thin (Builtin.Word) -> Builtin.Int64 // user: %12
  %11 = struct_extract %8 : $UInt, #UInt.value    // user: %12
  %12 = apply %10(%11) : $@thin (Builtin.Word) -> Builtin.Int64 // user: %14
  %13 = builtin_function_ref "u_to_s_checked_conversion_Int64" : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // user: %14
  %14 = apply %13(%12) : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // users: %15, %16
  %15 = tuple_extract %14 : $(Builtin.Int64, Builtin.Int1), 0 // user: %18
  %16 = tuple_extract %14 : $(Builtin.Int64, Builtin.Int1), 1 // user: %17
  cond_fail %16 : $Builtin.Int1                   // id: %17
  %18 = struct $Int64 (%15 : $Builtin.Int64)      // user: %19
  %19 = struct_extract %18 : $Int64, #Int64.value // user: %21
  %20 = builtin_function_ref "truncOrBitCast_Int64_Word" : $@thin (Builtin.Int64) -> Builtin.Word // user: %21
  %21 = apply %20(%19) : $@thin (Builtin.Int64) -> Builtin.Word // user: %22
  %22 = struct $Int (%21 : $Builtin.Word)         // users: %23, %24
  debug_value %22 : $Int  // let v1               // id: %23
  return %22 : $Int                               // id: %24
}


// peephole: Word(Int64(x >> 10)) -> (x >> 1)
// CHECK-LABEL: sil @_TF4test30test_trunc_u_to_s_zext_lshr_10FSuSi : $@thin (UInt) -> Int
// CHECK: builtin_function_ref "lshr_Word"
// CHECK-NOT: builtin_function_ref "zextOrBitCast_Word_Int64"
// CHECK-NOT: builtin_function_ref "u_to_s_checked_conversion_Int64"
// CHECK-NOT: builtin_function_ref "truncOrBitCast_Int64_Word"
// CHECK: return
// test.test_trunc_u_to_s_zext_lshr_10 (Swift.UInt) -> Swift.Int
sil @_TF4test30test_trunc_u_to_s_zext_lshr_10FSuSi : $@thin (UInt) -> Int {
bb0(%0 : $UInt):
  debug_value %0 : $UInt  // let x                // id: %1
  %2 = integer_literal $Builtin.Word, 10          // user: %7
  br bb1                                          // id: %3

bb1:                                              // Preds: bb0
  br bb2                                          // id: %4

bb2:                                              // Preds: bb1
  %5 = builtin_function_ref "lshr_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %7
  %6 = struct_extract %0 : $UInt, #UInt.value     // user: %7
  %7 = apply %5(%6, %2) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %8
  %8 = struct $UInt (%7 : $Builtin.Word)          // user: %11
  br bb3                                          // id: %9

bb3:                                              // Preds: bb2
  %10 = builtin_function_ref "zextOrBitCast_Word_Int64" : $@thin (Builtin.Word) -> Builtin.Int64 // user: %12
  %11 = struct_extract %8 : $UInt, #UInt.value    // user: %12
  %12 = apply %10(%11) : $@thin (Builtin.Word) -> Builtin.Int64 // user: %14
  %13 = builtin_function_ref "u_to_s_checked_conversion_Int64" : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // user: %14
  %14 = apply %13(%12) : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // users: %15, %16
  %15 = tuple_extract %14 : $(Builtin.Int64, Builtin.Int1), 0 // user: %18
  %16 = tuple_extract %14 : $(Builtin.Int64, Builtin.Int1), 1 // user: %17
  cond_fail %16 : $Builtin.Int1                   // id: %17
  %18 = struct $Int64 (%15 : $Builtin.Int64)      // user: %19
  %19 = struct_extract %18 : $Int64, #Int64.value // user: %21
  %20 = builtin_function_ref "truncOrBitCast_Int64_Word" : $@thin (Builtin.Int64) -> Builtin.Word // user: %21
  %21 = apply %20(%19) : $@thin (Builtin.Int64) -> Builtin.Word // user: %22
  %22 = struct $Int (%21 : $Builtin.Word)         // users: %23, %24
  debug_value %22 : $Int  // let v1               // id: %23
  return %22 : $Int                               // id: %24
}

// no peephole: Word(Int64(x >> c)), where c is a variable
// This should not trigger the optimization as it is not known if c > 0
// CHECK-LABEL: sil @_TF4test31test_trunc_u_to_s_zext_lshr_varFTSuSu_Si : $@thin (UInt, UInt) -> Int
// CHECK: builtin_function_ref "u_to_s_checked_conversion_Int64"
// CHECK: builtin_function_ref "truncOrBitCast_Int64_Word"
// CHECK: return
// test.test_trunc_u_to_s_zext_lshr_var (Swift.UInt, Swift.UInt) -> Swift.Int
sil @_TF4test31test_trunc_u_to_s_zext_lshr_varFTSuSu_Si : $@thin (UInt, UInt) -> Int {
bb0(%0 : $UInt, %1 : $UInt):
  debug_value %0 : $UInt  // let x                // id: %2
  debug_value %1 : $UInt  // let c                // id: %3
  %4 = string_literal utf8 "shift amount is larger than type size in bits" // user: %7
  %5 = integer_literal $Builtin.Word, 45          // user: %7
  %6 = integer_literal $Builtin.Word, 2           // users: %7, %10, %31
  %7 = struct $StaticString (%4 : $Builtin.RawPointer, %5 : $Builtin.Word, %6 : $Builtin.Word) // user: %32
  %8 = string_literal utf8 "/Users/roman/build/swift/Ninja-RelWithDebInfo/swift/stdlib/core/8/FixedPoint.swift" // user: %10
  %9 = integer_literal $Builtin.Word, 82          // user: %10
  %10 = struct $StaticString (%8 : $Builtin.RawPointer, %9 : $Builtin.Word, %6 : $Builtin.Word) // user: %32
  %11 = integer_literal $Builtin.Word, 5712       // user: %12
  %12 = struct $UInt (%11 : $Builtin.Word)        // user: %32
  br bb1                                          // id: %13

bb1:                                              // Preds: bb0
  %14 = integer_literal $Builtin.Word, 64         // user: %17
  %15 = builtin_function_ref "cmp_ult_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %17
  %16 = struct_extract %1 : $UInt, #UInt.value    // user: %17
  %17 = apply %15(%16, %14) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %20
  %18 = integer_literal $Builtin.Int1, -1         // user: %20
  %19 = builtin_function_ref "int_expect_Int1" : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %20
  %20 = apply %19(%17, %18) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %21
  cond_br %20, bb2, bb3                           // id: %21

bb2:                                              // Preds: bb1
  %22 = builtin_function_ref "lshr_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %25
  %23 = struct_extract %0 : $UInt, #UInt.value    // user: %25
  %24 = struct_extract %1 : $UInt, #UInt.value    // user: %25
  %25 = apply %22(%23, %24) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %26
  %26 = struct $UInt (%25 : $Builtin.Word)        // user: %35
  br bb4                                          // id: %27

bb3:                                              // Preds: bb1
  // function_ref Swift._fatalErrorMessage (Swift.StaticString, Swift.StaticString, Swift.StaticString, Swift.UInt) -> ()
  %28 = function_ref @_TFSs18_fatalErrorMessageFTVSs12StaticStringS_S_Su_T_ : $@thin @noreturn (StaticString, StaticString, StaticString, UInt) -> () // user: %32
  %29 = string_literal utf8 "fatal error"         // user: %31
  %30 = integer_literal $Builtin.Word, 11         // user: %31
  %31 = struct $StaticString (%29 : $Builtin.RawPointer, %30 : $Builtin.Word, %6 : $Builtin.Word) // user: %32
  %32 = apply %28(%31, %7, %10, %12) : $@thin @noreturn (StaticString, StaticString, StaticString, UInt) -> ()
  unreachable                                     // id: %33

bb4:                                              // Preds: bb2
  %34 = builtin_function_ref "zextOrBitCast_Word_Int64" : $@thin (Builtin.Word) -> Builtin.Int64 // user: %36
  %35 = struct_extract %26 : $UInt, #UInt.value   // user: %36
  %36 = apply %34(%35) : $@thin (Builtin.Word) -> Builtin.Int64 // user: %38
  %37 = builtin_function_ref "u_to_s_checked_conversion_Int64" : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // user: %38
  %38 = apply %37(%36) : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // users: %39, %40
  %39 = tuple_extract %38 : $(Builtin.Int64, Builtin.Int1), 0 // user: %42
  %40 = tuple_extract %38 : $(Builtin.Int64, Builtin.Int1), 1 // user: %41
  cond_fail %40 : $Builtin.Int1                   // id: %41
  %42 = struct $Int64 (%39 : $Builtin.Int64)      // user: %43
  %43 = struct_extract %42 : $Int64, #Int64.value // user: %45
  %44 = builtin_function_ref "truncOrBitCast_Int64_Word" : $@thin (Builtin.Int64) -> Builtin.Word // user: %45
  %45 = apply %44(%43) : $@thin (Builtin.Int64) -> Builtin.Word // user: %46
  %46 = struct $Int (%45 : $Builtin.Word)         // users: %47, %48
  debug_value %46 : $Int  // let v1               // id: %47
  return %46 : $Int                               // id: %48
}

// peephole: UInt16(Int32(x >> 1)) -> (x >> 1)
// CHECK-LABEL: sil @_TF4test36test_uint16_trunc_u_to_s_zext_lshr_1FVSs6UInt16S0_ : $@thin (UInt16) -> UInt16
// CHECK: builtin_function_ref "lshr_Int16"
// CHECK-NOT: builtin_function_ref "zext_Int16_Int32"
// CHECK-NOT: builtin_function_ref "s_to_u_checked_trunc_Int32_Int16"
// CHECK-NOT: tuple_extract
// CHECK: return
// test.test_uint16_trunc_u_to_s_zext_lshr_1 (Swift.UInt16) -> Swift.UInt16
sil @_TF4test36test_uint16_trunc_u_to_s_zext_lshr_1FVSs6UInt16S0_ : $@thin (UInt16) -> UInt16 {
bb0(%0 : $UInt16):
  debug_value %0 : $UInt16  // let x              // id: %1
  %2 = integer_literal $Builtin.Int16, 1          // user: %7
  br bb1                                          // id: %3

bb1:                                              // Preds: bb0
  br bb2                                          // id: %4

bb2:                                              // Preds: bb1
  %5 = builtin_function_ref "lshr_Int16" : $@thin (Builtin.Int16, Builtin.Int16) -> Builtin.Int16 // user: %7
  %6 = struct_extract %0 : $UInt16, #UInt16.value // user: %7
  %7 = apply %5(%6, %2) : $@thin (Builtin.Int16, Builtin.Int16) -> Builtin.Int16 // user: %8
  %8 = struct $UInt16 (%7 : $Builtin.Int16)       // user: %10
  br bb3                                          // id: %9

bb3:                                              // Preds: bb2
  %10 = struct_extract %8 : $UInt16, #UInt16.value // user: %12
  %11 = builtin_function_ref "zext_Int16_Int32" : $@thin (Builtin.Int16) -> Builtin.Int32 // user: %12
  %12 = apply %11(%10) : $@thin (Builtin.Int16) -> Builtin.Int32 // user: %13
  %13 = struct $Int32 (%12 : $Builtin.Int32)      // user: %14
  %14 = struct_extract %13 : $Int32, #Int32.value // user: %16
  %15 = builtin_function_ref "s_to_u_checked_trunc_Int32_Int16" : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // user: %16
  %16 = apply %15(%14) : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // users: %17, %18
  %17 = tuple_extract %16 : $(Builtin.Int16, Builtin.Int1), 0 // user: %20
  %18 = tuple_extract %16 : $(Builtin.Int16, Builtin.Int1), 1 // user: %19
  cond_fail %18 : $Builtin.Int1                   // id: %19
  %20 = struct $UInt16 (%17 : $Builtin.Int16)     // users: %21, %22
  debug_value %20 : $UInt16  // let v1            // id: %21
  return %20 : $UInt16                            // id: %22
}


// peephole: Int16(Int32(x >> 1)) -> (x >> 1)
// CHECK-LABEL: sil @_TF4test35test_int16_trunc_u_to_s_zext_lshr_1FVSs6UInt16VSs5Int16 : $@thin (UInt16) -> Int16
// CHECK: builtin_function_ref "lshr_Int16"
// CHECK-NOT: builtin_function_ref "zext_Int16_Int32"
// CHECK-NOT: builtin_function_ref "s_to_u_checked_trunc_Int32_Int16"
// CHECK-NOT: tuple_extract
// CHECK: return
// test.test_int16_trunc_u_to_s_zext_lshr_1 (Swift.UInt16) -> Swift.Int16
sil @_TF4test35test_int16_trunc_u_to_s_zext_lshr_1FVSs6UInt16VSs5Int16 : $@thin (UInt16) -> Int16 {
bb0(%0 : $UInt16):
  debug_value %0 : $UInt16  // let x              // id: %1
  %2 = integer_literal $Builtin.Int16, 1          // user: %7
  br bb1                                          // id: %3

bb1:                                              // Preds: bb0
  br bb2                                          // id: %4

bb2:                                              // Preds: bb1
  %5 = builtin_function_ref "lshr_Int16" : $@thin (Builtin.Int16, Builtin.Int16) -> Builtin.Int16 // user: %7
  %6 = struct_extract %0 : $UInt16, #UInt16.value // user: %7
  %7 = apply %5(%6, %2) : $@thin (Builtin.Int16, Builtin.Int16) -> Builtin.Int16 // user: %8
  %8 = struct $UInt16 (%7 : $Builtin.Int16)       // user: %10
  br bb3                                          // id: %9

bb3:                                              // Preds: bb2
  %10 = struct_extract %8 : $UInt16, #UInt16.value // user: %12
  %11 = builtin_function_ref "zext_Int16_Int32" : $@thin (Builtin.Int16) -> Builtin.Int32 // user: %12
  %12 = apply %11(%10) : $@thin (Builtin.Int16) -> Builtin.Int32 // user: %13
  %13 = struct $Int32 (%12 : $Builtin.Int32)      // user: %14
  %14 = struct_extract %13 : $Int32, #Int32.value // user: %16
  %15 = builtin_function_ref "s_to_s_checked_trunc_Int32_Int16" : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // user: %16
  %16 = apply %15(%14) : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // users: %17, %18
  %17 = tuple_extract %16 : $(Builtin.Int16, Builtin.Int1), 0 // user: %20
  %18 = tuple_extract %16 : $(Builtin.Int16, Builtin.Int1), 1 // user: %19
  cond_fail %18 : $Builtin.Int1                   // id: %19
  %20 = struct $Int16 (%17 : $Builtin.Int16)      // users: %21, %22
  debug_value %20 : $Int16  // let v1             // id: %21
  return %20 : $Int16                             // id: %22
}

// No peephole for UInt(UInt64(x)), because it is not known if top bit of x is set
// CHECK-LABEL: sil @_TF4test26test_trunc_s_to_u_zext_varFSiSu : $@thin (Int) -> UInt
// This should not trigger the optimization as it is not known if top bit of x is set
// CHECK: builtin_function_ref "zextOrBitCast_Word_Int64"
// CHECK: builtin_function_ref "s_to_u_checked_conversion_Int64"
// CHECK: builtin_function_ref "truncOrBitCast_Int64_Word"
// CHECK: return
// test.test_trunc_s_to_u_zext_var (Swift.Int) -> Swift.UInt
sil @_TF4test26test_trunc_s_to_u_zext_varFSiSu : $@thin (Int) -> UInt {
bb0(%0 : $Int):
  debug_value %0 : $Int  // let x                 // id: %1
  %2 = builtin_function_ref "zextOrBitCast_Word_Int64" : $@thin (Builtin.Word) -> Builtin.Int64 // user: %4
  %3 = struct_extract %0 : $Int, #Int.value       // user: %4
  %4 = apply %2(%3) : $@thin (Builtin.Word) -> Builtin.Int64 // user: %6
  %5 = builtin_function_ref "s_to_u_checked_conversion_Int64" : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // user: %6
  %6 = apply %5(%4) : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // users: %7, %8
  %7 = tuple_extract %6 : $(Builtin.Int64, Builtin.Int1), 0 // user: %10
  %8 = tuple_extract %6 : $(Builtin.Int64, Builtin.Int1), 1 // user: %9
  cond_fail %8 : $Builtin.Int1                    // id: %9
  %10 = struct $UInt64 (%7 : $Builtin.Int64)      // user: %11
  %11 = struct_extract %10 : $UInt64, #UInt64.value // user: %13
  %12 = builtin_function_ref "truncOrBitCast_Int64_Word" : $@thin (Builtin.Int64) -> Builtin.Word // user: %13
  %13 = apply %12(%11) : $@thin (Builtin.Int64) -> Builtin.Word // user: %14
  %14 = struct $UInt (%13 : $Builtin.Word)        // user: %15
  return %14 : $UInt                              // id: %15
}


// sizeof is known to return strictly positive values
// peephole: UInt(UInt64(sizeof(Int))) -> sizeof(Int)
// CHECK-LABEL: sil @_TF4test29test_trunc_s_to_u_zext_sizeofFT_Su : $@thin () -> UInt
// CHECK: builtin_function_ref "sizeof"
// CHECK-NOT: builtin_function_ref "zextOrBitCast_Word_Int64"
// CHECK-NOT: builtin_function_ref "s_to_u_checked_conversion_Int64"
// CHECK-NOT: builtin_function_ref "truncOrBitCast_Int64_Word"
// CHECK: return
// test.test_trunc_s_to_u_zext_sizeof () -> Swift.UInt
sil @_TF4test29test_trunc_s_to_u_zext_sizeofFT_Su : $@thin () -> UInt {
bb0:
  %0 = metatype $@thin Int.Type
  %1 = builtin_function_ref "sizeof" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word // user: %3
  %2 = metatype $@thick Int.Type                  // user: %3
  %3 = apply %1<(Int)>(%2) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word // user: %4
  %4 = struct $Int (%3 : $Builtin.Word)           // user: %6
  %5 = builtin_function_ref "zextOrBitCast_Word_Int64" : $@thin (Builtin.Word) -> Builtin.Int64 // user: %7
  %6 = struct_extract %4 : $Int, #Int.value       // user: %7
  %7 = apply %5(%6) : $@thin (Builtin.Word) -> Builtin.Int64 // user: %9
  %8 = builtin_function_ref "s_to_u_checked_conversion_Int64" : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // user: %9
  %9 = apply %8(%7) : $@thin (Builtin.Int64) -> (Builtin.Int64, Builtin.Int1) // users: %10, %11
  %10 = tuple_extract %9 : $(Builtin.Int64, Builtin.Int1), 0 // user: %13
  %11 = tuple_extract %9 : $(Builtin.Int64, Builtin.Int1), 1 // user: %12
  cond_fail %11 : $Builtin.Int1                   // id: %12
  %13 = struct $UInt64 (%10 : $Builtin.Int64)     // user: %14
  %14 = struct_extract %13 : $UInt64, #UInt64.value // user: %16
  %15 = builtin_function_ref "truncOrBitCast_Int64_Word" : $@thin (Builtin.Int64) -> Builtin.Word // user: %16
  %16 = apply %15(%14) : $@thin (Builtin.Int64) -> Builtin.Word // user: %17
  %17 = struct $UInt (%16 : $Builtin.Word)        // user: %18
  return %17 : $UInt                              // id: %18
}


// sizeof is known to return strictly positive values
// But Word->Int64 is not a safe conversion
// No peephole for UInt16(UInt32(sizeof(Int)))
// CHECK-LABEL: sil @_TF4test35test_int16_trunc_s_to_u_zext_sizeofFT_VSs6UInt16 : $@thin () -> UInt16
// CHECK: builtin_function_ref "zextOrBitCast_Word_Int64"
// CHECK: builtin_function_ref "s_to_u_checked_trunc_Int64_Int32"
// CHECK: builtin_function_ref "u_to_u_checked_trunc_Int32_Int16"
// CHECK: return
// test.test_int16_trunc_s_to_u_zext_sizeof () -> Swift.UInt16
sil @_TF4test35test_int16_trunc_s_to_u_zext_sizeofFT_VSs6UInt16 : $@thin () -> UInt16 {
bb0:
  %0 = metatype $@thin Int.Type
  %1 = builtin_function_ref "sizeof" : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word // user: %3
  %2 = metatype $@thick Int.Type                  // user: %3
  %3 = apply %1<(Int)>(%2) : $@thin <τ_0_0> (@thick τ_0_0.Type) -> Builtin.Word // user: %4
  %4 = struct $Int (%3 : $Builtin.Word)           // user: %6
  %5 = builtin_function_ref "zextOrBitCast_Word_Int64" : $@thin (Builtin.Word) -> Builtin.Int64 // user: %7
  %6 = struct_extract %4 : $Int, #Int.value       // user: %7
  %7 = apply %5(%6) : $@thin (Builtin.Word) -> Builtin.Int64 // user: %9
  %8 = builtin_function_ref "s_to_u_checked_trunc_Int64_Int32" : $@thin (Builtin.Int64) -> (Builtin.Int32, Builtin.Int1) // user: %9
  %9 = apply %8(%7) : $@thin (Builtin.Int64) -> (Builtin.Int32, Builtin.Int1) // users: %10, %11
  %10 = tuple_extract %9 : $(Builtin.Int32, Builtin.Int1), 0 // user: %13
  %11 = tuple_extract %9 : $(Builtin.Int32, Builtin.Int1), 1 // user: %12
  cond_fail %11 : $Builtin.Int1                   // id: %12
  %13 = struct $UInt32 (%10 : $Builtin.Int32)     // user: %14
  %14 = struct_extract %13 : $UInt32, #UInt32.value // user: %16
  %15 = builtin_function_ref "u_to_u_checked_trunc_Int32_Int16" : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // user: %16
  %16 = apply %15(%14) : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // users: %17, %18
  %17 = tuple_extract %16 : $(Builtin.Int16, Builtin.Int1), 0 // user: %20
  %18 = tuple_extract %16 : $(Builtin.Int16, Builtin.Int1), 1 // user: %19
  cond_fail %18 : $Builtin.Int1                   // id: %19
  %20 = struct $UInt16 (%17 : $Builtin.Int16)     // user: %21
  return %20 : $UInt16                            // id: %21
}


// peephole: UInt16(UInt32(Int16(x>>1))) -> x>>1
// CHECK-LABEL: sil @_TF4test34test_int16_trunc_s_to_u_zext_int16FVSs6UInt16S0_ : $@thin (UInt16) -> UInt16
// CHECK: builtin_function_ref "lshr_Int16"
// CHECK-NOT: builtin_function_ref "u_to_s_checked_conversion_Int16"
// CHECK-NOT: builtin_function_ref "s_to_u_checked_conversion_Int16"
// CHECK-NOT: builtin_function_ref "sext_Int16_Int32"
// CHECK-NOT: builtin_function_ref "u_to_u_checked_trunc_Int32_Int16"
// CHECK-NOT: tuple_extract
// CHECK: return
// test.test_int16_trunc_s_to_u_zext_int16 (Swift.UInt16) -> Swift.UInt16
sil @_TF4test34test_int16_trunc_s_to_u_zext_int16FVSs6UInt16S0_ : $@thin (UInt16) -> UInt16 {
bb0(%0 : $UInt16):
  debug_value %0 : $UInt16  // let x              // id: %1
  %2 = integer_literal $Builtin.Int16, 1          // user: %7
  br bb1                                          // id: %3

bb1:                                              // Preds: bb0
  br bb2                                          // id: %4

bb2:                                              // Preds: bb1
  %5 = builtin_function_ref "lshr_Int16" : $@thin (Builtin.Int16, Builtin.Int16) -> Builtin.Int16 // user: %7
  %6 = struct_extract %0 : $UInt16, #UInt16.value // user: %7
  %7 = apply %5(%6, %2) : $@thin (Builtin.Int16, Builtin.Int16) -> Builtin.Int16 // user: %8
  %8 = struct $UInt16 (%7 : $Builtin.Int16)       // user: %10
  br bb3                                          // id: %9

bb3:                                              // Preds: bb2
  %10 = struct_extract %8 : $UInt16, #UInt16.value // user: %12
  %11 = builtin_function_ref "u_to_s_checked_conversion_Int16" : $@thin (Builtin.Int16) -> (Builtin.Int16, Builtin.Int1) // user: %12
  %12 = apply %11(%10) : $@thin (Builtin.Int16) -> (Builtin.Int16, Builtin.Int1) // users: %13, %14
  %13 = tuple_extract %12 : $(Builtin.Int16, Builtin.Int1), 0 // user: %16
  %14 = tuple_extract %12 : $(Builtin.Int16, Builtin.Int1), 1 // user: %15
  cond_fail %14 : $Builtin.Int1                   // id: %15
  %16 = struct $Int16 (%13 : $Builtin.Int16)      // user: %17
  %17 = struct_extract %16 : $Int16, #Int16.value // user: %19
  %18 = builtin_function_ref "s_to_u_checked_conversion_Int16" : $@thin (Builtin.Int16) -> (Builtin.Int16, Builtin.Int1) // user: %19
  %19 = apply %18(%17) : $@thin (Builtin.Int16) -> (Builtin.Int16, Builtin.Int1) // users: %20, %21
  %20 = tuple_extract %19 : $(Builtin.Int16, Builtin.Int1), 0 // user: %24
  %21 = tuple_extract %19 : $(Builtin.Int16, Builtin.Int1), 1 // user: %22
  cond_fail %21 : $Builtin.Int1                   // id: %22
  %23 = builtin_function_ref "sext_Int16_Int32" : $@thin (Builtin.Int16) -> Builtin.Int32 // user: %24
  %24 = apply %23(%20) : $@thin (Builtin.Int16) -> Builtin.Int32 // user: %25
  %25 = struct $UInt32 (%24 : $Builtin.Int32)     // user: %26
  %26 = struct_extract %25 : $UInt32, #UInt32.value // user: %28
  %27 = builtin_function_ref "u_to_u_checked_trunc_Int32_Int16" : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // user: %28
  %28 = apply %27(%26) : $@thin (Builtin.Int32) -> (Builtin.Int16, Builtin.Int1) // users: %29, %30
  %29 = tuple_extract %28 : $(Builtin.Int16, Builtin.Int1), 0 // user: %32
  %30 = tuple_extract %28 : $(Builtin.Int16, Builtin.Int1), 1 // user: %31
  cond_fail %30 : $Builtin.Int1                   // id: %31
  %32 = struct $UInt16 (%29 : $Builtin.Int16)     // user: %33
  return %32 : $UInt16                            // id: %33
}

// peephole: Int8(x & 127) -> remove overflow check
// CHECK-LABEL: sil @_TF22peephole_trunc_and_ext32test_s_to_s_checked_trunc_of_andFVSs5Int32VSs4Int8 : $@thin (Int32) -> Int8
// CHECK: builtin_function_ref "and_Int32"
// CHECK: builtin_function_ref "s_to_s_checked_trunc_Int32_Int8"
// CHECK-NOT: cond_fail
// CHECK: return
// peephole_trunc_and_ext.test_s_to_s_checked_trunc_of_and (Swift.Int32) -> Swift.Int8
sil @_TF22peephole_trunc_and_ext32test_s_to_s_checked_trunc_of_andFVSs5Int32VSs4Int8 : $@thin (Int32) -> Int8 {
bb0(%0 : $Int32):
  debug_value %0 : $Int32  // let x               // id: %1
  %2 = integer_literal $Builtin.Int32, 127        // user: %5
  %3 = builtin_function_ref "and_Int32" : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %5
  %4 = struct_extract %0 : $Int32, #Int32.value   // user: %5
  %5 = apply %3(%4, %2) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %6
  %6 = struct $Int32 (%5 : $Builtin.Int32)        // user: %7
  %7 = struct_extract %6 : $Int32, #Int32.value   // user: %9
  %8 = builtin_function_ref "s_to_s_checked_trunc_Int32_Int8" : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // user: %9
  %9 = apply %8(%7) : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // users: %10, %11
  %10 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 0 // user: %13
  %11 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 1 // user: %12
  cond_fail %11 : $Builtin.Int1                   // id: %12
  %13 = struct $Int8 (%10 : $Builtin.Int8)        // user: %14
  return %13 : $Int8                              // id: %14
}

// peephole: UInt8(x & 255) -> remove overflow check
// CHECK-LABEL: sil @_TF22peephole_trunc_and_ext32test_s_to_u_checked_trunc_of_andFVSs5Int32VSs5UInt8 : $@thin (Int32) -> UInt8
// CHECK: builtin_function_ref "and_Int32"
// CHECK: builtin_function_ref "s_to_u_checked_trunc_Int32_Int8"
// CHECK-NOT: cond_fail
// CHECK: return
// peephole_trunc_and_ext.test_s_to_u_checked_trunc_of_and (Swift.Int32) -> Swift.UInt8
sil @_TF22peephole_trunc_and_ext32test_s_to_u_checked_trunc_of_andFVSs5Int32VSs5UInt8 : $@thin (Int32) -> UInt8 {
bb0(%0 : $Int32):
  debug_value %0 : $Int32  // let x               // id: %1
  %2 = integer_literal $Builtin.Int32, 255        // user: %5
  %3 = builtin_function_ref "and_Int32" : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %5
  %4 = struct_extract %0 : $Int32, #Int32.value   // user: %5
  %5 = apply %3(%4, %2) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %6
  %6 = struct $Int32 (%5 : $Builtin.Int32)        // user: %7
  %7 = struct_extract %6 : $Int32, #Int32.value   // user: %9
  %8 = builtin_function_ref "s_to_u_checked_trunc_Int32_Int8" : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // user: %9
  %9 = apply %8(%7) : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // users: %10, %11
  %10 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 0 // user: %13
  %11 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 1 // user: %12
  cond_fail %11 : $Builtin.Int1                   // id: %12
  %13 = struct $UInt8 (%10 : $Builtin.Int8)       // user: %14
  return %13 : $UInt8                             // id: %14
}

// peephole: UInt8(x & 255) -> remove overflow check
// CHECK-LABEL: sil @_TF22peephole_trunc_and_ext32test_u_to_u_checked_trunc_of_andFVSs6UInt32VSs5UInt8 : $@thin (UInt32) -> UInt8
// CHECK: builtin_function_ref "and_Int32"
// CHECK: builtin_function_ref "u_to_u_checked_trunc_Int32_Int8"
// CHECK-NOT: cond_fail
// CHECK: return
// peephole_trunc_and_ext.test_u_to_u_checked_trunc_of_and (Swift.UInt32) -> Swift.UInt8
sil @_TF22peephole_trunc_and_ext32test_u_to_u_checked_trunc_of_andFVSs6UInt32VSs5UInt8 : $@thin (UInt32) -> UInt8 {
bb0(%0 : $UInt32):
  debug_value %0 : $UInt32  // let x              // id: %1
  %2 = integer_literal $Builtin.Int32, 255        // user: %5
  %3 = builtin_function_ref "and_Int32" : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %5
  %4 = struct_extract %0 : $UInt32, #UInt32.value // user: %5
  %5 = apply %3(%4, %2) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %6
  %6 = struct $UInt32 (%5 : $Builtin.Int32)       // user: %7
  %7 = struct_extract %6 : $UInt32, #UInt32.value // user: %9
  %8 = builtin_function_ref "u_to_u_checked_trunc_Int32_Int8" : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // user: %9
  %9 = apply %8(%7) : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // users: %10, %11
  %10 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 0 // user: %13
  %11 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 1 // user: %12
  cond_fail %11 : $Builtin.Int1                   // id: %12
  %13 = struct $UInt8 (%10 : $Builtin.Int8)       // user: %14
  return %13 : $UInt8                             // id: %14
}

// peephole: Int8(x & 127) -> remove overflow check
// CHECK-LABEL: sil @_TF22peephole_trunc_and_ext32test_u_to_s_checked_trunc_of_andFVSs6UInt32VSs4Int8 : $@thin (UInt32) -> Int8
// CHECK: builtin_function_ref "and_Int32"
// CHECK: builtin_function_ref "u_to_s_checked_trunc_Int32_Int8"
// CHECK-NOT: cond_fail
// CHECK: return
// peephole_trunc_and_ext.test_u_to_s_checked_trunc_of_and (Swift.UInt32) -> Swift.Int8
sil @_TF22peephole_trunc_and_ext32test_u_to_s_checked_trunc_of_andFVSs6UInt32VSs4Int8 : $@thin (UInt32) -> Int8 {
bb0(%0 : $UInt32):
  debug_value %0 : $UInt32  // let x              // id: %1
  %2 = integer_literal $Builtin.Int32, 127        // user: %5
  %3 = builtin_function_ref "and_Int32" : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %5
  %4 = struct_extract %0 : $UInt32, #UInt32.value // user: %5
  %5 = apply %3(%4, %2) : $@thin (Builtin.Int32, Builtin.Int32) -> Builtin.Int32 // user: %6
  %6 = struct $UInt32 (%5 : $Builtin.Int32)       // user: %7
  %7 = struct_extract %6 : $UInt32, #UInt32.value // user: %9
  %8 = builtin_function_ref "u_to_s_checked_trunc_Int32_Int8" : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // user: %9
  %9 = apply %8(%7) : $@thin (Builtin.Int32) -> (Builtin.Int8, Builtin.Int1) // users: %10, %11
  %10 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 0 // user: %13
  %11 = tuple_extract %9 : $(Builtin.Int8, Builtin.Int1), 1 // user: %12
  cond_fail %11 : $Builtin.Int1                   // id: %12
  %13 = struct $Int8 (%10 : $Builtin.Int8)       // user: %14
  return %13 : $Int8                             // id: %14
}

// Swift._fatalErrorMessage (Swift.StaticString, Swift.StaticString, Swift.StaticString, Swift.UInt) -> ()
sil [noinline] @_TFSs18_fatalErrorMessageFTVSs12StaticStringS_S_Su_T_ : $@thin @noreturn (StaticString, StaticString, StaticString, UInt) -> ()
