// RUN: %sil-opt %s -predictable-memopt  | FileCheck %s

import Builtin
import swift


// CHECK-LABEL: sil @simple_reg_promotion
sil @simple_reg_promotion : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):                         // CHECK: bb0(%0 : $Int64):
  %1 = alloc_box $Int64
  store %0 to %1#1 : $*Int64
  %3 = alloc_box $Int64
  %4 = load %1#1 : $*Int64
  store %4 to %3#1 : $*Int64
  %6 = load %3#1 : $*Int64
  strong_release %3#0 : $Builtin.ObjectPointer
  strong_release %1#0 : $Builtin.ObjectPointer
  return %6 : $Int64

  // CHECK-NEXT: return %0 : $Int64
}


// CHECK-LABEL: sil @tuple_reg_promotion
sil @tuple_reg_promotion : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):                         // CHECK: bb0(%0 : $Int64):
  %1 = alloc_box $(Int64, Int64)
  
  %a = tuple_element_addr %1#1 : $*(Int64, Int64), 0
  %b = tuple_element_addr %1#1 : $*(Int64, Int64), 1
  store %0 to %a : $*Int64
  store %0 to %b : $*Int64

  %c = load %1#1 : $*(Int64, Int64)
  %d = tuple_extract %c : $(Int64, Int64), 0

  strong_release %1#0 : $Builtin.ObjectPointer

  return %d : $Int64

  // Verify that promotion has promoted the tuple load away, and we know that
  // %0 is being returned through scalar instructions in SSA form.
  // CHECK-NEXT: [[TUPLE:%[0-9]+]] = tuple ({{.*}} : $Int64, {{.*}} : $Int64)
  // CHECK-NEXT: [[TUPLE_ELT:%[0-9]+]] = tuple_extract [[TUPLE]] : $(Int64, Int64), 0

  // CHECK-NEXT: return [[TUPLE_ELT]] : $Int64
}


sil @takes_Int_inout : $@thin (@inout Int64) -> ()



// Verify that load promotion works properly with inout arguments.
//
// func used_by_inout(a : Int) -> (Int, Int) {
//  var t = a
//  takes_Int_inout(&a)
//  return (t,a)
//}
// CHECK-LABEL: sil @used_by_inout
sil @used_by_inout : $@thin (Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  // This alloc_stack can't be removed since it is used by a inout call.
  // CHECK: %1 = alloc_box $Int64
  %1 = alloc_box $Int64
  %2 = store %0 to %1#1 : $*Int64
  
  // This load should be eliminated.
  %3 = load %1#1 : $*Int64
  %5 = function_ref @takes_Int_inout : $@thin (@inout Int64) -> ()
  %6 = apply %5(%1#1) : $@thin (@inout Int64) -> ()
  
  // This load is needed in case the callee modifies the allocation.
  // CHECK: [[RES:%[0-9]+]] = load
  %7 = load %1#1 : $*Int64
  
  // This should use the incoming argument to the function.
  // CHECK: tuple ({{.*}} : $Int64, {{.*}} : $Int64)
  %8 = tuple (%3 : $Int64, %7 : $Int64)
  strong_release %1#0 : $Builtin.ObjectPointer
  %11 = return %8 : $(Int64, Int64)
}


struct AddressOnlyStruct {
  var a : protocol<>
  var b : Int
}

/// returns_generic_struct - This returns a struct by reference.
sil @returns_generic_struct : $@thin (@out AddressOnlyStruct) -> ()



sil @takes_closure : $@thin (@callee_owned () -> ()) -> ()
sil @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()


// CHECK-LABEL: sil @closure_test2
sil @closure_test2 : $@thin (Int64) -> Int64 {
bb0(%1 : $Int64):
  %0 = alloc_box $Int64
  store %1 to %0#1 : $*Int64  // CHECK: store

  %5 = function_ref @takes_closure : $@thin (@callee_owned () -> ()) -> ()
  %6 = function_ref @closure0 : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  %8 = partial_apply %6(%0#0, %0#1) : $@thin (@owned Builtin.ObjectPointer, @inout Int64) -> ()
  %9 = apply %5(%8) : $@thin (@callee_owned () -> ()) -> ()
  strong_release %0#0 : $Builtin.ObjectPointer

  store %1 to %0#1 : $*Int64 // CHECK: store

  // In an escape region, we should not promote loads.
  %r = load %0#1 : $*Int64 // CHECK: load
  return %r : $Int64
}



class SomeClass {}

sil @getSomeClass : $@thin () -> @owned SomeClass


// CHECK-LABEL: sil @assign_test_trivial
sil @assign_test_trivial : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_box $Int64

  store %0 to %1#1 : $*Int64
  store %0 to %1#1 : $*Int64
  store %0 to %1#1 : $*Int64

  %2 = load %1#1 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer

  // Verify that the load got forwarded from an assign.
  return %2 : $Int64                        // CHECK: return %0 : $Int64
}


struct ContainsObjectPointer {
  var x : Int 
  var y : Builtin.ObjectPointer
}

var int_global : Int


// CHECK-LABEL: sil @promote_alloc_stack
sil @promote_alloc_stack : $@thin (Int64) -> Builtin.Int64 {
bb0(%0 : $Int64):
  %5 = integer_literal $Builtin.Int64, 1
  // CHECK: [[IL:%[0-9]+]] = integer_literal

  %18 = struct $Int64 (%5 : $Builtin.Int64)
  %22 = alloc_stack $Int64

  // CHECK-NOT: alloc_stack

  store %18 to %22#1 : $*Int64
  %24 = struct_element_addr %22#1 : $*Int64, #value
  %25 = load %24 : $*Builtin.Int64
  dealloc_stack %22#0 : $*@local_storage Int64
  // CHECK-NEXT: return [[IL]]
  return %25 : $Builtin.Int64
}

// CHECK-LABEL: sil @copy_addr_to_load
sil @copy_addr_to_load : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):               // CHECK: bb0(%0 : $Int64):
  %1 = alloc_stack $Int64
  store %0 to %1#1 : $*Int64
  %2 = alloc_stack $Int64
  
  copy_addr %1#1 to [initialization] %2#1 : $*Int64

  %3 = load %2#1 : $*Int64

  dealloc_stack %2#0 : $*@local_storage Int64
  dealloc_stack %1#0 : $*@local_storage Int64
  // CHECK-NEXT: return %0
  return %3 : $Int64
}

// rdar://15170149
// CHECK-LABEL: sil @store_to_copyaddr
sil @store_to_copyaddr : $(Bool) -> Bool {
bb0(%0 : $Bool):  // CHECK: bb0(%0 :
  %1 = alloc_stack $Bool
  store %0 to %1#1 : $*Bool
  %3 = alloc_stack $Bool
  copy_addr %1#1 to [initialization] %3#1 : $*Bool
  %5 = load %3#1 : $*Bool
  copy_addr %3#1 to %1#1 : $*Bool
  %12 = load %1#1 : $*Bool
  dealloc_stack %3#0 : $*@local_storage Bool
  dealloc_stack %1#0 : $*@local_storage Bool
  return %12 : $Bool                              // CHECK-NEXT: return %0
}

// CHECK-LABEL: sil @cross_block_load_promotion
sil @cross_block_load_promotion : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_stack $Int64
  store %0 to %1#1 : $*Int64
  %11 = integer_literal $Builtin.Int1, 1
  cond_br %11, bb1, bb2

bb1:
  br bb5

bb2:
  br bb5

bb5:
  %15 = load %1#1 : $*Int64
  dealloc_stack %1#0 : $*@local_storage Int64
  return %15 : $Int64

// CHECK: return %0 : $Int64
}

struct XYStruct { var x, y : Int }
sil @init_xy_struct : $@thin () -> XYStruct


// CHECK-LABEL: sil @cross_block_load_promotion_struct
sil @cross_block_load_promotion_struct : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %2 : $Int64):
  %1 = alloc_stack $XYStruct
  
  %7 = function_ref @init_xy_struct : $@thin () -> XYStruct
  %9 = apply %7() : $@thin () -> XYStruct
  store %9 to %1#1 : $*XYStruct

  %11 = struct_element_addr %1#1 : $*XYStruct, #y
  store %0 to %11 : $*Int64

  %12 = integer_literal $Builtin.Int1, 1          // user: %3
  cond_br %12, bb1, bb2

bb1:                                              // Preds: bb3
  %13 = struct_element_addr %1#1 : $*XYStruct, #x
  store %2 to %13 : $*Int64
  br bb5

bb2:                                              // Preds: bb0
  br bb5

bb5:                                              // Preds: bb4
  %15 = load %11 : $*Int64
  dealloc_stack %1#0 : $*@local_storage XYStruct
  return %15 : $Int64

// CHECK: return %0 : $Int64
}

// CHECK-LABEL: sil @cross_block_load_promotion_struct2
sil @cross_block_load_promotion_struct2 : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %2 : $Int64):
  %1 = alloc_stack $XYStruct
  
  %7 = function_ref @init_xy_struct : $@thin () -> XYStruct
  %9 = apply %7() : $@thin () -> XYStruct
  store %9 to %1#1 : $*XYStruct

  %11 = struct_element_addr %1#1 : $*XYStruct, #x
  store %0 to %11 : $*Int64

  %12 = integer_literal $Builtin.Int1, 1          // user: %3
  cond_br %12, bb1, bb2

bb1:                                              // Preds: bb3
  %13 = struct_element_addr %1#1 : $*XYStruct, #x
  store %0 to %13 : $*Int64
  br bb5

bb2:                                              // Preds: bb0
  br bb5

bb5:                                              // Preds: bb4
  %15 = load %11 : $*Int64
  dealloc_stack %1#0 : $*@local_storage XYStruct
  return %15 : $Int64

// CHECK: return %0 : $Int64
}


// CHECK-LABEL: sil @destroy_addr
sil @destroy_addr : $@cc(method) @thin (@owned SomeClass) -> @owned SomeClass {
bb0(%0 : $SomeClass):
  %1 = alloc_stack $SomeClass
  %2 = tuple ()
  store %0 to %1#1 : $*SomeClass
  %7 = load %1#1 : $*SomeClass
  strong_retain %7 : $SomeClass
  strong_release %7 : $SomeClass
  %12 = load %1#1 : $*SomeClass                   // users: %16, %13
  strong_retain %12 : $SomeClass                  // id: %13
  destroy_addr %1#1 : $*SomeClass                 // id: %14
  dealloc_stack %1#0 : $*@local_storage SomeClass // id: %15
  return %12 : $SomeClass                         // id: %16
}


protocol P {}
class C : P {}

sil @use : $@thin (@in P) -> ()

// rdar://15492647
// CHECK-LABEL: sil @destroy_addr_removed
sil @destroy_addr_removed : $@thin () -> () {
bb0:
  %3 = alloc_stack $SomeClass
  %f = function_ref @getSomeClass : $@thin () -> @owned SomeClass
  %9 = apply %f() : $@thin () -> @owned SomeClass
  // CHECK: [[CVAL:%[0-9]+]] = apply

  assign %9 to %3#1 : $*SomeClass
  destroy_addr %3#1 : $*SomeClass
  dealloc_stack %3#0 : $*@local_storage SomeClass
  %15 = tuple ()
  return %15 : $()
// CHECK-NEXT: strong_release [[CVAL]]
}

// rdar://15887292 - PredictableMemoryOptimizations crashes on load from init_existential
// CHECK-LABEL: sil @init_existential_crash
sil @init_existential_crash : $() -> () {
  %99 = alloc_stack $LogicValue
  %100 = init_existential %99#1 : $*LogicValue, $*Bool
  %105 = integer_literal $Builtin.Int1, 0
  %106 = struct $Bool (%105 : $Builtin.Int1)
  store %106 to %100 : $*Bool
  %108 = struct_element_addr %100 : $*Bool, #value
  %109 = load %108 : $*Builtin.Int1
  dealloc_stack %99#0 : $*@local_storage LogicValue
  return undef : $()
}

