// RUN: %sil-opt %s -global-opt | FileCheck %s
//
// ginit.cold has a hammock with an initializer call on the slow path.
// ginit.loop has a loop containing an initializer call.
sil_stage canonical

let MyConst = 0

import Builtin
import Swift

// globalinit_token0
sil_global private @globalinit_token0 : $Builtin.Word

// globalinit_func0
sil private @globalinit_func0 : $@thin () -> () {
bb0:
  %0 = global_addr #MyConst : $*Int               // user: %3
  %1 = integer_literal $Builtin.Word, 0           // user: %2
  %2 = struct $Int (%1 : $Builtin.Word)           // user: %3
  store %2 to %0 : $*Int                          // id: %3
  %4 = tuple ()                                   // user: %5
  return %4 : $()                                 // id: %5
}

// ginit.MyConst.addressor : Swift.Int
sil [global_init] @_TF5ginita7MyConstSi : $@thin () -> Builtin.RawPointer {
bb0:
  %0 = builtin_function_ref "once" : $@thin (Builtin.RawPointer, @owned @callee_owned () -> ()) -> () // user: %5
  %1 = sil_global_addr @globalinit_token0 : $*Builtin.Word // user: %2
  %2 = address_to_pointer %1 : $*Builtin.Word to $Builtin.RawPointer // user: %5
  // function_ref globalinit_func0
  %3 = function_ref @globalinit_func0 : $@thin () -> () // user: %4
  %4 = thin_to_thick_function %3 : $@thin () -> () to $@callee_owned () -> () // user: %5
  %5 = apply %0(%2, %4) : $@thin (Builtin.RawPointer, @owned @callee_owned () -> ()) -> ()
  %6 = global_addr #MyConst : $*Int               // user: %7
  %7 = address_to_pointer %6 : $*Int to $Builtin.RawPointer // user: %8
  return %7 : $Builtin.RawPointer                 // id: %8
}

// Don't hoist this initializer call.
// ginit.cold (Swift.Int) -> Swift.Int
// CHECK-LABEL: sil @_TF5ginit4coldFSiSi
// CHECK-NOT: 5ginita7MyConst
// CHECK: bb1:
// CHECK: 5ginita7MyConst
// CHECK: {{^bb2}}
sil @_TF5ginit4coldFSiSi : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0           // users: %4, %5, %13
  %2 = builtin_function_ref "cmp_sgt_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %4
  %3 = struct_extract %0 : $Int, #Int.value       // user: %4
  %4 = apply %2(%3, %1) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %5
  cond_br %4, bb1, bb2(%1 : $Builtin.Word)        // id: %5

bb1:                                              // Preds: bb0
  // function_ref ginit.MyConst.addressor : Swift.Int
  %6 = function_ref @_TF5ginita7MyConstSi : $@thin () -> Builtin.RawPointer // user: %7
  %7 = apply %6() : $@thin () -> Builtin.RawPointer // user: %8
  %8 = pointer_to_address %7 : $Builtin.RawPointer to $*Int // user: %9
  %9 = struct_element_addr %8 : $*Int, #Int.value // user: %10
  %10 = load %9 : $*Builtin.Word                  // user: %13
  %11 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %13
  %12 = integer_literal $Builtin.Int1, -1         // user: %13
  %13 = apply %11(%1, %10, %12) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %14
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0 // user: %15
  br bb2(%14 : $Builtin.Word)                     // id: %15

bb2(%16 : $Builtin.Word):                         // Preds: bb0 bb1
  %17 = struct $Int (%16 : $Builtin.Word)         // user: %18
  return %17 : $Int                               // id: %18
}

// Do hoist this initializer call.
// ginit.loop (Swift.Int) -> Swift.Int
// CHECK-LABEL: sil @_TF5ginit4loopFSiSi
// CHECK: {{^bb0}}
// CHECK: 5ginita7MyConst
// CHECK: {{^bb1}}
// CHECK-NOT: 5ginita7MyConst
sil @_TF5ginit4loopFSiSi : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0           // user: %8
  %2 = integer_literal $Builtin.Word, 1           // users: %6, %8, %22
  %3 = struct_extract %0 : $Int, #Int.value       // user: %6
  %4 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // users: %6, %22, %37
  %5 = integer_literal $Builtin.Int1, -1          // users: %6, %22, %37
  %6 = apply %4(%3, %2, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %7
  %7 = tuple_extract %6 : $(Builtin.Word, Builtin.Int1), 0 // user: %13
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word)  // id: %8

bb1(%9 : $Builtin.Word, %10 : $Builtin.Word):     // Preds: bb0 bb5
  %11 = struct $Int (%10 : $Builtin.Word)         // user: %24
  %12 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %13
  %13 = apply %12(%10, %7) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %14
  cond_br %13, bb2, bb4                           // id: %14

bb2:                                              // Preds: bb1
  %15 = enum $Optional<Int>, #Optional.None!enumelt // user: %16
  br bb3(%10 : $Builtin.Word, %15 : $Optional<Int>) // id: %16

bb3(%17 : $Builtin.Word, %18 : $Optional<Int>):   // Preds: bb2 bb4
  %19 = alloc_stack $Optional<Int>                // users: %20, %26, %27, %40
  store %18 to %19#1 : $*Optional<Int>            // id: %20
  switch_enum %18 : $Optional<Int>, case #Optional.Some!enumelt.1: bb5, case #Optional.None!enumelt: bb6 // id: %21

bb4:                                              // Preds: bb1
  %22 = apply %4(%10, %2, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %23
  %23 = tuple_extract %22 : $(Builtin.Word, Builtin.Int1), 0 // user: %25
  %24 = enum $Optional<Int>, #Optional.Some!enumelt.1, %11 : $Int // user: %25
  br bb3(%23 : $Builtin.Word, %24 : $Optional<Int>) // id: %25

bb5:                                              // Preds: bb3
  %26 = unchecked_take_enum_data_addr %19#1 : $*Optional<Int>, #Optional.Some!enumelt.1
  dealloc_stack %19#0 : $*@local_storage Optional<Int> // id: %27
  %28 = alloc_stack $Optional<Int>                // users: %29, %30, %31
  store %18 to %28#1 : $*Optional<Int>            // id: %29
  %30 = unchecked_take_enum_data_addr %28#1 : $*Optional<Int>, #Optional.Some!enumelt.1
  dealloc_stack %28#0 : $*@local_storage Optional<Int> // id: %31
  // function_ref ginit.MyConst.addressor : Swift.Int
  %32 = function_ref @_TF5ginita7MyConstSi : $@thin () -> Builtin.RawPointer // user: %33
  %33 = apply %32() : $@thin () -> Builtin.RawPointer // user: %34
  %34 = pointer_to_address %33 : $Builtin.RawPointer to $*Int // user: %35
  %35 = struct_element_addr %34 : $*Int, #Int.value // user: %36
  %36 = load %35 : $*Builtin.Word                 // user: %37
  %37 = apply %4(%9, %36, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %38
  %38 = tuple_extract %37 : $(Builtin.Word, Builtin.Int1), 0 // user: %39
  br bb1(%38 : $Builtin.Word, %17 : $Builtin.Word) // id: %39

bb6:                                              // Preds: bb3
  dealloc_stack %19#0 : $*@local_storage Optional<Int> // id: %40
  %41 = struct $Int (%9 : $Builtin.Word)          // user: %42
  return %41 : $Int                               // id: %42
}

// libg.MyGlobal.addressor : Swift.Int
sil [global_init] @_TF4libga8MyGlobalSi : $@thin () -> Builtin.RawPointer

// Hoist this initializer call out of a loop, but not into the function entry.
// ginit.loop (Swift.Int) -> Swift.Int
// CHECK-LABEL: sil @_TF10ginitloops3runFSiSi
// CHECK: {{^bb2}}
// CHECK: function_ref @_TF4libga8MyGlobalSi
// CHECK-NEXT: apply
// CHECK: {{^bb6}}
// CHECK-NOT: addressor
// CHECK: pointer_to_address
// CHECK: {{br bb6}}
//
// ginitloops.run (Swift.Int) -> Swift.Int
sil @_TF10ginitloops3runFSiSi : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 1000        // user: %4
  %2 = builtin_function_ref "cmp_sgt_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %4
  %3 = struct_extract %0 : $Int, #Int.value       // users: %4, %16, %29
  %4 = apply %2(%3, %1) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %5
  cond_br %4, bb1, bb2                            // id: %5

bb1:                                              // Preds: bb0
  %6 = integer_literal $Builtin.Word, -1          // user: %7
  %7 = struct $Int (%6 : $Builtin.Word)           // user: %8
  br bb9(%7 : $Int)                               // id: %8

bb2:                                              // Preds: bb0
  %9 = integer_literal $Builtin.Word, 0           // user: %11
  %10 = integer_literal $Builtin.Word, 1          // users: %11, %22, %25, %34
  br bb3(%9 : $Builtin.Word, %10 : $Builtin.Word) // id: %11

bb3(%12 : $Builtin.Word, %13 : $Builtin.Word):    // Preds: bb2 bb7
  %14 = struct $Int (%13 : $Builtin.Word)         // user: %24
  %15 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // users: %16, %29
  %16 = apply %15(%13, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %17
  cond_br %16, bb4, bb5                           // id: %17

bb4:                                              // Preds: bb3
  %18 = struct $Int (%12 : $Builtin.Word)         // user: %19
  br bb9(%18 : $Int)                              // id: %19

bb5:                                              // Preds: bb3
  %20 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %22
  %21 = integer_literal $Builtin.Int1, -1         // user: %22
  %22 = apply %20(%13, %10, %21) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %23
  %23 = tuple_extract %22 : $(Builtin.Word, Builtin.Int1), 0 // user: %31
  %24 = enum $Optional<Int>, #Optional.Some!enumelt.1, %14 : $Int
  br bb6(%12 : $Builtin.Word, %10 : $Builtin.Word) // id: %25

bb6(%26 : $Builtin.Word, %27 : $Builtin.Word):    // Preds: bb5 bb8
  %28 = struct $Int (%27 : $Builtin.Word)         // user: %36
  %29 = apply %15(%27, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %30
  cond_br %29, bb7, bb8                           // id: %30

bb7:                                              // Preds: bb6
  br bb3(%26 : $Builtin.Word, %23 : $Builtin.Word) // id: %31

bb8:                                              // Preds: bb6
  %32 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %34
  %33 = integer_literal $Builtin.Int1, -1         // user: %34
  %34 = apply %32(%27, %10, %33) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %35
  %35 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 0 // user: %46
  %36 = enum $Optional<Int>, #Optional.Some!enumelt.1, %28 : $Int
  // function_ref libg.MyGlobal.addressor : Swift.Int
  %37 = function_ref @_TF4libga8MyGlobalSi : $@thin () -> Builtin.RawPointer // user: %38
  %38 = apply %37() : $@thin () -> Builtin.RawPointer // user: %39
  %39 = pointer_to_address %38 : $Builtin.RawPointer to $*Int // user: %40
  %40 = struct_element_addr %39 : $*Int, #Int.value // user: %41
  %41 = load %40 : $*Builtin.Word                 // user: %44
  %42 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %44
  %43 = integer_literal $Builtin.Int1, -1         // user: %44
  %44 = apply %42(%26, %41, %43) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %45
  %45 = tuple_extract %44 : $(Builtin.Word, Builtin.Int1), 0 // user: %46
  br bb6(%45 : $Builtin.Word, %35 : $Builtin.Word) // id: %46

bb9(%47 : $Int):                                  // Preds: bb1 bb4
  return %47 : $Int                               // id: %48
}


// Do NOT hoist this initializer out of a cold block.
// CHECK-LABEL: sil @_TF9ginitcold3runFSiSi
// CHECK-NOT: addressor
// CHECK: {{^bb3}}
// CHECK: cond_br
// CHECK: {{^bb4}}
// CHECK: function_ref @_TF4libga8MyGlobalSi
// CHECK-NEXT: apply
// CHECK: pointer_to_address
// CHECK: br
sil @_TF9ginitcold3runFSiSi : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0           // users: %4, %19
  %2 = integer_literal $Builtin.Word, 1           // users: %4, %14
  %3 = struct_extract %0 : $Int, #Int.value       // user: %8
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word)  // id: %4

bb1(%5 : $Builtin.Word, %6 : $Builtin.Word):      // Preds: bb0 bb5
  %7 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // users: %8, %19
  %8 = apply %7(%6, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %9
  cond_br %8, bb2, bb3                            // id: %9

bb2:                                              // Preds: bb1
  %10 = struct $Int (%5 : $Builtin.Word)          // user: %11
  return %10 : $Int                               // id: %11

bb3:                                              // Preds: bb1
  %12 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // users: %14, %29
  %13 = integer_literal $Builtin.Int1, -1         // users: %14, %29
  %14 = apply %12(%6, %2, %13) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %15
  %15 = tuple_extract %14 : $(Builtin.Word, Builtin.Int1), 0 // user: %33
  %16 = integer_literal $Builtin.Word, 10         // user: %18
  %17 = builtin_function_ref "srem_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %18
  %18 = apply %17(%5, %16) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Word // user: %19
  %19 = apply %7(%18, %1) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %22
  %20 = integer_literal $Builtin.Int1, 0          // user: %22
  %21 = builtin_function_ref "int_expect_Int1" : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %22
  %22 = apply %21(%19, %20) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %23
  cond_br %22, bb4, bb5(%5 : $Builtin.Word)       // id: %23

bb4:                                              // Preds: bb3
  // function_ref libg.MyGlobal.addressor : Swift.Int
  %24 = function_ref @_TF4libga8MyGlobalSi : $@thin () -> Builtin.RawPointer // user: %25
  %25 = apply %24() : $@thin () -> Builtin.RawPointer // user: %26
  %26 = pointer_to_address %25 : $Builtin.RawPointer to $*Int // user: %27
  %27 = struct_element_addr %26 : $*Int, #Int.value // user: %28
  %28 = load %27 : $*Builtin.Word                 // user: %29
  %29 = apply %12(%5, %28, %13) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %30
  %30 = tuple_extract %29 : $(Builtin.Word, Builtin.Int1), 0 // user: %31
  br bb5(%30 : $Builtin.Word)                     // id: %31

bb5(%32 : $Builtin.Word):                         // Preds: bb3 bb4
  br bb1(%32 : $Builtin.Word, %15 : $Builtin.Word) // id: %33
}
