// RUN: %sil-opt %s -allocbox-to-stack | FileCheck %s

import Builtin
import Swift


// CHECK-LABEL: sil @simple_promotion
sil @simple_promotion : $(Int) -> Int {
bb0(%0 : $Int):
  %1 = alloc_box $Int
  %2 = store %0 to %1#1 : $*Int
  %3 = load %1#1 : $*Int
  %4 = strong_release %1#0 : $Builtin.ObjectPointer
  %5 = return %3 : $Int

// CHECK: alloc_stack
// CHECK-NOT: alloc_box
// CHECK-NOT: strong_release
// CHECK: return
}

// CHECK-LABEL: sil @init_var
sil @init_var : $() -> Int {
bb0:
  %1 = alloc_box $Int
  %3 = load %1#1 : $*Int
  %4 = strong_release %1#0 : $Builtin.ObjectPointer
  %5 = return %3 : $Int

// CHECK: %0 = alloc_stack
// CHECK-NOT: alloc_box
// CHECK-NOT: strong_release
// CHECK-NOT: destroy_addr
// CHECK: dealloc_stack %0#0 : $*@local_storage Int
// CHECK: return
}

// CHECK-LABEL: sil @multi_strong_release
sil @multi_strong_release : $() -> Int {
bb0:
  %1 = alloc_box $Int
  %2 = mark_uninitialized [rootself] %1#1 : $*Int
  %3 = load %2 : $*Int
  %x = strong_retain %1#0 : $Builtin.ObjectPointer
  %y = strong_release %1#0 : $Builtin.ObjectPointer
  %b = br bb1
bb1:

  %4 = strong_release %1#0 : $Builtin.ObjectPointer
  %5 = return %3 : $Int

// CHECK: %0 = alloc_stack
// CHECK: bb1:
// CHECK: dealloc_stack %0#0 : $*@local_storage Int
// CHECK: return
}

struct TestStruct {
  var Elt : Int
}

// CHECK-LABEL: sil @struct_tuple_element_addr
sil @struct_tuple_element_addr : $(Int) -> Int {
bb1(%0 : $Int):
  %1 = alloc_box $TestStruct
  %a = alloc_box $(Int, Int)
  
  %2 = struct_element_addr %1#1 : $*TestStruct, #TestStruct.Elt
  %3 = store %0 to %2 : $*Int

  %b = tuple_element_addr %a#1 : $*(Int, Int), 0
  %c = store %0 to %b : $*Int

  %6 = struct_element_addr %1#1 : $*TestStruct, #TestStruct.Elt
  %7 = load %6 : $*Int
  %x = strong_release %a#0 : $Builtin.ObjectPointer
  %8 = strong_release %1#0 : $Builtin.ObjectPointer


  %9 = return %7 : $Int

// CHECK: %1 = alloc_stack $TestStruct
// CHECK: dealloc_stack %1
// CHECK: return
}




sil @callee : $@thin (@inout Int) -> ()

// CHECK-LABEL: sil @inout_nocapture
sil @inout_nocapture : $@thin () -> Int {
bb0:
  // CHECK: alloc_stack
  %1 = alloc_box $Int
  %6 = function_ref @callee : $@thin (@inout Int) -> ()
  %7 = apply %6(%1#1) : $@thin (@inout Int) -> ()
  %8 = load %1#1 : $*Int
  %9 = strong_release %1#0 : $Builtin.ObjectPointer
  %10 = address_to_pointer %1#1 : $*Int to $Builtin.RawPointer
  %11 = pointer_to_address %10 : $Builtin.RawPointer to $*Int
  %12 = load %11 : $*Int
  %13 = return %8 : $Int
  // CHECK: return
}


protocol P {
}

sil @returns_protocol : $@thin (@out P) -> ()

// CHECK-LABEL: sil @test_indirect_return
sil @test_indirect_return : $@thin () -> () {
bb0:
  // CHECK: alloc_stack
  %1 = function_ref @returns_protocol : $@thin (@out P) -> ()
  %2 = alloc_box $P
  %3 = apply %1(%2#1) : $@thin (@out P) -> ()
  %5 = strong_release %2#0 : $Builtin.ObjectPointer
  %0 = tuple ()
  %6 = return %0 : $()
  // CHECK: return
}

class SomeClass {}

// CHECK-LABEL: sil @class_promotion
sil @class_promotion : $(SomeClass) -> SomeClass {
bb0(%0 : $SomeClass):
  %1 = alloc_box $SomeClass
  %2 = store %0 to %1#1 : $*SomeClass
  %3 = load %1#1 : $*SomeClass
  %4 = strong_release %1#0 : $Builtin.ObjectPointer
  %5 = return %3 : $SomeClass

// CHECK: %1 = alloc_stack
// CHECK-NOT: alloc_box
// CHECK-NOT: strong_release
// CHECK: destroy_addr {{.*}} : $*SomeClass
// CHECK: return
}

protocol LogicValue {
  func getLogicValue() -> Bool
}

// CHECK-LABEL: @protocols
sil @protocols : $@thin (@in LogicValue, @thin Bool.Type) -> Bool {
bb0(%0 : $*LogicValue, %1 : $@thin Bool.Type):
  %2 = alloc_box $LogicValue
// CHECK:  %2 = alloc_stack $LogicValue
  copy_addr [take] %0 to [initialization] %2#1 : $*LogicValue
  %6 = project_existential %2#1 : $*LogicValue to $*@sil_self LogicValue
  %7 = protocol_method %2#1 : $*LogicValue, #LogicValue.getLogicValue!1 : $@cc(witness_method) @callee_owned (@inout @sil_self LogicValue) -> Bool
  %8 = apply %7(%6) : $@cc(witness_method) @callee_owned (@inout @sil_self LogicValue) -> Bool
  strong_release %2#0 : $Builtin.ObjectPointer
// CHECK:  destroy_addr %2#1 : $*LogicValue
// CHECK-NEXT:  dealloc_stack %2#0 : $*@local_storage LogicValue
// CHECK-NEXT:  return
  return %8 : $Bool
}


// Generics test, which is address-only.
class Generic<T> {}

// CHECK-LABEL: sil @dealloc_box
sil @dealloc_box : $@thin <T> () -> () {
bb0:  // CHECK-NEXT: bb0:
      // CHECK-NEXT: alloc_stack
  %1 = alloc_box $Generic<T>
  dealloc_box $Generic<T>, %1#0 : $Builtin.ObjectPointer

  %0 = tuple ()    // CHECK: tuple ()
  %6 = return %0 : $()
  // CHECK: return
}


enum SomeUnion {
  case x(Int)
  case y(SomeClass)
}



sil @_TO1t9SomeUnion1yfMS0_FCS_9SomeClassS0_ : $@thin (@owned SomeClass, @thin SomeUnion.Type) -> @owned SomeUnion 
sil @_TC1t9SomeClassCfMS0_FT_S0_ : $@thin (@thick SomeClass.Type) -> @owned SomeClass 

// CHECK-LABEL: sil @union_test
sil @union_test : $@thin () -> () {
bb0:
  %1 = alloc_box $SomeUnion
  %2 = function_ref @_TO1t9SomeUnion1yfMS0_FCS_9SomeClassS0_ : $@thin (@owned SomeClass, @thin SomeUnion.Type) -> @owned SomeUnion // user: %7
  %3 = metatype $@thin SomeUnion.Type
  %4 = function_ref @_TC1t9SomeClassCfMS0_FT_S0_ : $@thin (@thick SomeClass.Type) -> @owned SomeClass // user: %6
  %5 = metatype $@thick SomeClass.Type
  %6 = apply %4(%5) : $@thin (@thick SomeClass.Type) -> @owned SomeClass
  %7 = apply %2(%6, %3) : $@thin (@owned SomeClass, @thin SomeUnion.Type) -> @owned SomeUnion
  store %7 to %1#1 : $*SomeUnion
  strong_release %1#0 : $Builtin.ObjectPointer
  %10 = tuple ()
  return %10 : $()
  
// CHECK: alloc_stack
// CHECK:  [[T0:%.*]] = tuple ()
// CHECK-NEXT:  return [[T0]] : $()
}

// CHECK-LABEL: sil @multiple_release_test
sil @multiple_release_test : $@thin (Bool) -> Bool {
bb0(%0 : $Bool):
  %1 = alloc_box $Bool
  store %0 to %1#1 : $*Bool
  strong_retain %1#0 : $Builtin.ObjectPointer
  strong_retain %1#0 : $Builtin.ObjectPointer
  %5 = tuple ()
  %6 = load %1#1 : $*Bool
  strong_release %1#0 : $Builtin.ObjectPointer
  strong_release %1#0 : $Builtin.ObjectPointer
  strong_release %1#0 : $Builtin.ObjectPointer
  return %6 : $Bool

  // CHECK: alloc_stack $Bool
  // CHECK-NEXT: store
  // CHECK-NEXT: tuple ()
  // CHECK-NEXT: load
  // CHECK-NEXT: dealloc_stack
  // CHECK-NEXT: return
}

// Make sure that we can promote this box and dealloc_stack
// on each path.
//
// CHECK-LABEL: sil @box_reachable_from_release_test
// CHECK: bb1
// CHECK: alloc_stack
// CHECK: bb2:
// CHECK: dealloc_stack
// CHECK: bb3:
// CHECK: dealloc_stack
sil @box_reachable_from_release_test : $@thin () -> () {
bb0:
  br bb1

bb1:
  %1 = alloc_box $Bool
  cond_br undef, bb2, bb3

bb2:
  strong_release %1#0 : $Builtin.ObjectPointer
  br bb1

bb3:
  strong_release %1#0 : $Builtin.ObjectPointer
  %2 = tuple ()
  return %2 : $()
}



sil @useSomeClass : $@thin (@owned SomeClass) -> ()


// <rdar://problem/16382973> DI misses destroy_addr because allocbox_to_stack isn't preserving mark_uninitialized invariants
// When allocbox_to_stack promotes the box, it should rewrite the multiple
// strong_releases into destroy_addr/dealloc_stack pairs.  However, it needs to
// make sure to use the MUI result for the destroy addr.

// CHECK-LABEL: sil @test_mui
sil @test_mui : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  %2 = alloc_box $SomeClass
  // CHECK: [[STACK:%[0-9]+]] = alloc_stack
  %3 = mark_uninitialized [var] %2#1 : $*SomeClass
  // CHECK: [[MUI:%[0-9]+]] = mark_uninitialized
  cond_br %0, bb1, bb3

bb1:
  %7 = function_ref @_TC1t9SomeClassCfMS0_FT_S0_ : $@thin (@thick SomeClass.Type) -> @owned SomeClass // user: %6
  %8 = metatype $@thick SomeClass.Type
  %9 = apply %7(%8) : $@thin (@thick SomeClass.Type) -> @owned SomeClass

  assign %9 to %3 : $*SomeClass
  %11 = function_ref @useSomeClass : $@thin (@owned SomeClass) -> ()
  %12 = load %3 : $*SomeClass
  strong_retain %12 : $SomeClass
  %14 = apply %11(%12) : $@thin (@owned SomeClass) -> ()
  
  strong_release %2#0 : $Builtin.ObjectPointer
  // CHECK: destroy_addr [[MUI]]
  // CHECK-NEXT: dealloc_stack [[STACK]]#0
  br bb2

bb2:
  %17 = tuple ()
  return %17 : $()

bb3:
  strong_release %2#0 : $Builtin.ObjectPointer
  // CHECK: destroy_addr [[MUI]]
  // CHECK-NEXT: dealloc_stack [[STACK]]#0
  br bb2
}

// CHECK-LABEL: sil @_TF6struct5applyFT1fFT_Si_Si
// struct.apply (f : () -> Swift.Int) -> Swift.Int
sil @_TF6struct5applyFT1fFT_Si_Si : $@thin (@owned @callee_owned () -> Int) -> Int {
bb0(%0 : $@callee_owned () -> Int):
  debug_value %0 : $@callee_owned () -> Int  // let f // id: %1
  strong_retain %0 : $@callee_owned () -> Int     // id: %2
  %3 = apply %0() : $@callee_owned () -> Int      // user: %5
  strong_release %0 : $@callee_owned () -> Int    // id: %4
  return %3 : $Int                                // id: %5
}

// CHECK-LABEL: sil @_TF6struct6escapeFT1fFT_Si_FT_Si
// struct.escape (f : () -> Swift.Int) -> () -> Swift.Int
sil @_TF6struct6escapeFT1fFT_Si_FT_Si : $@thin (@owned @callee_owned () -> Int) -> @owned @callee_owned () -> Int {
bb0(%0 : $@callee_owned () -> Int):
  debug_value %0 : $@callee_owned () -> Int  // let f // id: %1
  return %0 : $@callee_owned () -> Int            // id: %2
}

// CHECK-LABEL: sil @_TF6struct8useStackFT1tSi_T_
// struct.useStack (t : Swift.Int) -> ()
sil @_TF6struct8useStackFT1tSi_T_ : $@thin (Int) -> () {
bb0(%0 : $Int):
  debug_value %0 : $Int  // let t                 // id: %1
  // CHECK: alloc_stack
  %2 = alloc_box $Int  // var s                   // users: %3, %6, %7, %7, %9
  store %0 to %2#1 : $*Int                        // id: %3
  // function_ref struct.apply (f : () -> Swift.Int) -> Swift.Int
  %4 = function_ref @_TF6struct5applyFT1fFT_Si_Si : $@thin (@owned @callee_owned () -> Int) -> Int // user: %8
  // CHECK: [[FUNC:%[a-zA-Z0-9]+]] = function_ref @_TFF6struct8useStackFT1tSi_T_U_FT_Si_specialized0
  // function_ref struct.(useStack (t : Swift.Int) -> ()).(closure #1)
  %5 = function_ref @_TFF6struct8useStackFT1tSi_T_U_FT_Si : $@thin (@owned Builtin.ObjectPointer, @inout Int) -> Int // user: %7
  strong_retain %2#0 : $Builtin.ObjectPointer     // id: %6
  // CHECK: [[PA:%[a-zA-Z0-9]+]] = partial_apply [[FUNC]]
  %7 = partial_apply %5(%2#0, %2#1) : $@thin (@owned Builtin.ObjectPointer, @inout Int) -> Int // user: %8
  %8 = apply %4(%7) : $@thin (@owned @callee_owned () -> Int) -> Int
  strong_release %2#0 : $Builtin.ObjectPointer    // id: %9
  %10 = tuple ()                                  // user: %11
  return %10 : $()                                // id: %11
}

// CHECK-LABEL: sil private @_TFF6struct8useStackFT1tSi_T_U_FT_Si_specialized0
// CHECK-LABEL: sil private @_TFF6struct8useStackFT1tSi_T_U_FT_Si
// struct.(useStack (t : Swift.Int) -> ()).(closure #1)
sil private @_TFF6struct8useStackFT1tSi_T_U_FT_Si : $@thin (@owned Builtin.ObjectPointer, @inout Int) -> Int {
bb0(%0 : $Builtin.ObjectPointer, %1 : $*Int):
  // function_ref Swift.++ @postfix <A : Swift._Incrementable>(x : @inout A) -> A
  %2 = function_ref @_TFSsoP2ppUSs14_Incrementable__FT1xRQ__Q_ : $@thin <τ_0_0 where τ_0_0 : _Incrementable> (@out τ_0_0, @inout τ_0_0) -> () // user: %4
  %3 = alloc_stack $Int                           // users: %4, %5, %6
  %4 = apply [transparent] %2<Int>(%3#1, %1) : $@thin <τ_0_0 where τ_0_0 : _Incrementable> (@out τ_0_0, @inout τ_0_0) -> ()
  %5 = load %3#1 : $*Int                          // user: %8
  dealloc_stack %3#0 : $*@local_storage Int       // id: %6
  strong_release %0 : $Builtin.ObjectPointer      // id: %7
  return %5 : $Int                                // id: %8
}

// Swift.++ @postfix <A : Swift._Incrementable>(x : @inout A) -> A
sil [transparent] @_TFSsoP2ppUSs14_Incrementable__FT1xRQ__Q_ : $@thin <τ_0_0 where τ_0_0 : _Incrementable> (@out τ_0_0, @inout τ_0_0) -> ()

// CHECK-LABEL: sil @_TF6struct6useBoxFT1tSi_T_
// struct.useBox (t : Swift.Int) -> ()
sil @_TF6struct6useBoxFT1tSi_T_ : $@thin (Int) -> () {
bb0(%0 : $Int):
  debug_value %0 : $Int  // let t                 // id: %1
  // CHECK: alloc_box
  %2 = alloc_box $Int  // var s                   // users: %3, %6, %7, %7, %10
  store %0 to %2#1 : $*Int                        // id: %3
  // function_ref struct.escape (f : () -> Swift.Int) -> () -> Swift.Int
  %4 = function_ref @_TF6struct6escapeFT1fFT_Si_FT_Si : $@thin (@owned @callee_owned () -> Int) -> @owned @callee_owned () -> Int // user: %8
  // function_ref struct.(useBox (t : Swift.Int) -> ()).(closure #1)
  %5 = function_ref @_TFF6struct6useBoxFT1tSi_T_U_FT_Si : $@thin (@owned Builtin.ObjectPointer, @inout Int) -> Int // user: %7
  strong_retain %2#0 : $Builtin.ObjectPointer     // id: %6
  %7 = partial_apply %5(%2#0, %2#1) : $@thin (@owned Builtin.ObjectPointer, @inout Int) -> Int // user: %8
  %8 = apply %4(%7) : $@thin (@owned @callee_owned () -> Int) -> @owned @callee_owned () -> Int // user: %9
  %9 = apply %8() : $@callee_owned () -> Int
  strong_release %2#0 : $Builtin.ObjectPointer    // id: %10
  %11 = tuple ()                                  // user: %12
  return %11 : $()                                // id: %12
}

// CHECK-LABEL: sil private @_TFF6struct6useBoxFT1tSi_T_U_FT_Si
// struct.(useBox (t : Swift.Int) -> ()).(closure #1)
sil private @_TFF6struct6useBoxFT1tSi_T_U_FT_Si : $@thin (@owned Builtin.ObjectPointer, @inout Int) -> Int {
bb0(%0 : $Builtin.ObjectPointer, %1 : $*Int):
  // function_ref Swift.++ @postfix <A : Swift._Incrementable>(x : @inout A) -> A
  %2 = function_ref @_TFSsoP2ppUSs14_Incrementable__FT1xRQ__Q_ : $@thin <τ_0_0 where τ_0_0 : _Incrementable> (@out τ_0_0, @inout τ_0_0) -> () // user: %4
  %3 = alloc_stack $Int                           // users: %4, %5, %6
  %4 = apply [transparent] %2<Int>(%3#1, %1) : $@thin <τ_0_0 where τ_0_0 : _Incrementable> (@out τ_0_0, @inout τ_0_0) -> ()
  %5 = load %3#1 : $*Int                          // user: %8
  dealloc_stack %3#0 : $*@local_storage Int       // id: %6
  strong_release %0 : $Builtin.ObjectPointer      // id: %7
  return %5 : $Int                                // id: %8
}
