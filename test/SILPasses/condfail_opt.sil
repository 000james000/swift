// RUN: %target-sil-opt %s -condfail-opt -verify | FileCheck %s

sil_stage canonical

import Builtin

// CHECK-LABEL: sil @test_condbr
// CHECK:      bb0(%0 : $Builtin.Int1):
// CHECK-NEXT:   cond_fail %0
// CHECK-NEXT:   br bb2
sil @test_condbr : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb2

bb1:
  %i1 = integer_literal $Builtin.Int1, -1
  cond_fail %i1 : $Builtin.Int1
  br bb2

bb2:
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @test_condbr_inverted
// CHECK:      bb0(%0 : $Builtin.Int1):
// CHECK-NEXT:   [[X:%[0-9]*]] = integer_literal $Builtin.Int1, -1
// CHECK-NEXT:   [[Y:%[0-9]*]] = builtin "xor_Int1"(%0 : $Builtin.Int1, [[X]] : $Builtin.Int1)
// CHECK-NEXT:   cond_fail [[Y]]
// CHECK-NEXT:   br bb2
sil @test_condbr_inverted : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb2, bb1

bb1:
  %i1 = integer_literal $Builtin.Int1, -1
  cond_fail %i1 : $Builtin.Int1
  br bb2

bb2:
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @test_condbr_2preds
// CHECK:      bb1:
// CHECK-NEXT:   cond_fail %0
// CHECK-NEXT:   br bb4
// CHECK:      bb2:
// CHECK-NEXT:   [[X:%[0-9]*]] = integer_literal $Builtin.Int1, -1
// CHECK-NEXT:   [[Y:%[0-9]*]] = builtin "xor_Int1"(%0 : $Builtin.Int1, [[X]] : $Builtin.Int1)
// CHECK-NEXT:   cond_fail [[Y]]
// CHECK-NEXT:   br bb4
sil @test_condbr_2preds : $@thin (Builtin.Int1, Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  cond_br %0, bb1, bb2

bb1:
  cond_br %0, bb3, bb4

bb2:
  cond_br %0, bb4, bb3

bb3:
  %i1 = integer_literal $Builtin.Int1, -1
  cond_fail %i1 : $Builtin.Int1
  br bb4

bb4:
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @negative_condbr_wrong_const
// CHECK:      bb0(%0 : $Builtin.Int1):
// CHECK-NEXT:   cond_br %0, bb1, bb2
sil @negative_condbr_wrong_const : $@thin (Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb2

bb1:
  %i1 = integer_literal $Builtin.Int1, 0
  cond_fail %i1 : $Builtin.Int1
  br bb2

bb2:
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @test_arg
// CHECK:      bb1:
// CHECK-NEXT:   [[X:%[0-9]*]] = integer_literal $Builtin.Int1, -1
// CHECK-NEXT:   cond_fail [[X]]
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   cond_fail %1
// CHECK-NEXT:   br bb3
// CHECK:      bb3({{.*}}):
// CHECK-NOT:    cond_fail
// CHECK:        return
sil @test_arg : $@thin (Builtin.Int1, Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  cond_br %0, bb2, bb1

bb1:
  %i1 = integer_literal $Builtin.Int1, -1
  br bb3(%i1 : $Builtin.Int1)

bb2:
  br bb3(%1 : $Builtin.Int1)

bb3(%a3 : $Builtin.Int1):
  cond_fail %a3 : $Builtin.Int1
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @test_arg_inverted
// CHECK:      bb1:
// CHECK-NEXT:   [[X:%[0-9]*]] = integer_literal $Builtin.Int1, -1
// CHECK-NEXT:   [[Y:%[0-9]*]] = builtin "xor_Int1"(%2 : $Builtin.Int1, [[X]] : $Builtin.Int1)
// CHECK-NEXT:   cond_fail [[Y]]
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   [[R:%[0-9]*]] = integer_literal $Builtin.Int1, -1
// CHECK-NEXT:   [[S:%[0-9]*]] = builtin "xor_Int1"(%1 : $Builtin.Int1, [[R]] : $Builtin.Int1)
// CHECK-NEXT:   cond_fail [[S]]
// CHECK-NEXT:   br bb3
// CHECK:      bb3({{.*}}):
// CHECK-NOT:    cond_fail
// CHECK:        return
sil @test_arg_inverted : $@thin (Builtin.Int1, Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  %2 = integer_literal $Builtin.Int1, -1
  cond_br %0, bb2, bb1

bb1:
  br bb3(%2 : $Builtin.Int1)

bb2:
  br bb3(%1 : $Builtin.Int1)

bb3(%a3 : $Builtin.Int1):
  %v1 = builtin "xor_Int1"(%a3 : $Builtin.Int1, %2 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %v1 : $Builtin.Int1
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @test_arg_two
// CHECK:      bb1:
// CHECK-NEXT:   [[X:%[0-9]*]] = integer_literal $Builtin.Int1, -1
// CHECK-NEXT:   cond_fail [[X]]
// CHECK-NEXT:   cond_fail [[X]]
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   cond_fail %1
// CHECK-NEXT:   cond_fail %1
// CHECK-NEXT:   br bb3
// CHECK:      bb3({{.*}}):
// CHECK-NOT:    cond_fail
// CHECK:        return
sil @test_arg_two : $@thin (Builtin.Int1, Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  cond_br %0, bb2, bb1

bb1:
  %i1 = integer_literal $Builtin.Int1, -1
  br bb3(%i1 : $Builtin.Int1, %i1 : $Builtin.Int1)

bb2:
  br bb3(%1 : $Builtin.Int1, %1 : $Builtin.Int1)

bb3(%a3 : $Builtin.Int1, %a4 : $Builtin.Int1):
  cond_fail %a3 : $Builtin.Int1
  cond_fail %a4 : $Builtin.Int1
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @negative_arg_no_const
// CHECK:      bb1:
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   br bb3
// CHECK:      bb3({{.*}}):
// CHECK-NEXT:   cond_fail
sil @negative_arg_no_const : $@thin (Builtin.Int1, Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  cond_br %0, bb2, bb1

bb1:
  br bb3(%1 : $Builtin.Int1)

bb2:
  br bb3(%1 : $Builtin.Int1)

bb3(%a3 : $Builtin.Int1):
  cond_fail %a3 : $Builtin.Int1
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @negative_arg_no_postdom
// CHECK:      bb1:
// CHECK-NEXT:   integer_literal
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   cond_br
// CHECK:      bb3({{.*}}):
// CHECK-NEXT:   cond_fail
sil @negative_arg_no_postdom : $@thin (Builtin.Int1, Builtin.Int1, Builtin.Int1) -> () {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1, %2 : $Builtin.Int1):
  cond_br %0, bb2, bb1

bb1:
  %i1 = integer_literal $Builtin.Int1, -1
  br bb3(%i1 : $Builtin.Int1)

bb2:
  cond_br %2, bb3(%1 : $Builtin.Int1), bb4

bb3(%a3 : $Builtin.Int1):
  cond_fail %a3 : $Builtin.Int1
  br bb4

bb4:
  %r = tuple ()
  return %r : $()
}

// CHECK-LABEL: sil @negative_arg_multiple_uses
// CHECK:      bb1:
// CHECK-NEXT:   integer_literal
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   br bb3
// CHECK:      bb3({{.*}}):
// CHECK-NEXT:   cond_fail
sil @negative_arg_multiple_uses : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  cond_br %0, bb2, bb1

bb1:
  %i1 = integer_literal $Builtin.Int1, -1
  br bb3(%i1 : $Builtin.Int1)

bb2:
  br bb3(%1 : $Builtin.Int1)

bb3(%a3 : $Builtin.Int1):
  cond_fail %a3 : $Builtin.Int1
  return %a3 : $Builtin.Int1
}

// CHECK-LABEL: sil @negative_arg_multiple_uses_inverted
// CHECK:      bb1:
// CHECK-NEXT:   br bb3
// CHECK:      bb2:
// CHECK-NEXT:   br bb3
// CHECK:      bb3({{.*}}):
// CHECK-NEXT:   builtin "xor_Int1"
// CHECK-NEXT:   cond_fail
// CHECK-NEXT:   return
sil @negative_arg_multiple_uses_inverted : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  %i1 = integer_literal $Builtin.Int1, -1
  cond_br %0, bb2, bb1

bb1:
  br bb3(%i1 : $Builtin.Int1)

bb2:
  br bb3(%1 : $Builtin.Int1)

bb3(%a3 : $Builtin.Int1):
  %v1 = builtin "xor_Int1"(%a3 : $Builtin.Int1, %i1 : $Builtin.Int1) : $Builtin.Int1
  cond_fail %v1 : $Builtin.Int1
  return %v1 : $Builtin.Int1
}

