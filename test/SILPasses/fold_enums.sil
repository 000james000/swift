// RUN: %target-swift-frontend -O -emit-sil %s | FileCheck %s

// Check that the optimizer can detect when an enum (e.g. Optional) is being deconstructed
// and then recreated in the same form. It should replace it with the original value in
// such cases.

sil_stage canonical

import Builtin
import Swift
import SwiftShims

public enum E {
  case C1(Int32)
  case C2(Int32)
  case C3(Int32)
}


// CHECK-LABEL: sil @_TF10fold_enums18recreate_optional1FGSqVSs5Int32_GSqS0__
// CHECK: bb0(%0 : $Optional<Int32>)
// CHECK-NOT: bb1
// CHECK: return %0 : $Optional<Int32> 
sil @_TF10fold_enums18recreate_optional1FGSqVSs5Int32_GSqS0__ : $@convention(thin) (Optional<Int32>) -> Optional<Int32> {
bb0(%0 : $Optional<Int32>):
  debug_value %0 : $Optional<Int32>  // let x     // id: %1
  switch_enum %0 : $Optional<Int32>, case #Optional.Some!enumelt.1: bb1, default bb2 // id: %2

bb1(%3 : $Int32):                                 // Preds: bb0
  debug_value %3 : $Int32  // let y               // id: %4
  %5 = enum $Optional<Int32>, #Optional.Some!enumelt.1, %3 : $Int32 // user: %6
  br bb3(%5 : $Optional<Int32>)                   // id: %6

bb2:                                              // Preds: bb0
  br bb3(%0 : $Optional<Int32>)                   // id: %7

bb3(%8 : $Optional<Int32>):                       // Preds: bb1 bb2
  return %8 : $Optional<Int32>                    // id: %9
}

// CHECK-LABEL: sil @_TF10fold_enums18recreate_optional2FGSqVSs5Int32_GSqS0__
// CHECK: bb0(%0 : $Optional<Int32>)
// CHECK-NOT: bb1
// CHECK: return %0 : $Optional<Int32> 
sil @_TF10fold_enums18recreate_optional2FGSqVSs5Int32_GSqS0__ : $@convention(thin) (Optional<Int32>) -> Optional<Int32> {
bb0(%0 : $Optional<Int32>):
  debug_value %0 : $Optional<Int32>  // let x     // id: %1
  switch_enum %0 : $Optional<Int32>, case #Optional.Some!enumelt.1: bb1, default bb2 // id: %2

bb1(%3 : $Int32):                                 // Preds: bb0
  debug_value %3 : $Int32  // let y               // id: %4
  %5 = enum $Optional<Int32>, #Optional.Some!enumelt.1, %3 : $Int32 // user: %6
  br bb3(%5 : $Optional<Int32>)                   // id: %6

bb2:                                              // Preds: bb0
  %7 = alloc_stack $Optional<Int32>               // users: %8, %10, %11
  inject_enum_addr %7#1 : $*Optional<Int32>, #Optional.None!enumelt // id: %8
  %9 = tuple ()
  %10 = load %7#1 : $*Optional<Int32>             // user: %12
  dealloc_stack %7#0 : $*@local_storage Optional<Int32> // id: %11
  br bb3(%10 : $Optional<Int32>)                  // id: %12

bb3(%13 : $Optional<Int32>):                      // Preds: bb1 bb2
  return %13 : $Optional<Int32>                   // id: %14
}


// CHECK-LABEL: sil @_TF10fold_enums13recreate_enumFOS_1ES0_
// CHECK: bb0(%0 : $E)
// CHECK-NOT: bb1
// CHECK: return %0 : $E 
sil @_TF10fold_enums13recreate_enumFOS_1ES0_ : $@convention(thin) (E) -> E {
bb0(%0 : $E):
  debug_value %0 : $E  // let e                   // id: %1
  switch_enum %0 : $E, case #E.C1!enumelt.1: bb1, case #E.C2!enumelt.1: bb2, case #E.C3!enumelt.1: bb3 // id: %2

bb1(%3 : $Int32):                                 // Preds: bb0
  debug_value %3 : $Int32  // let x               // id: %4
  %5 = enum $E, #E.C1!enumelt.1, %3 : $Int32      // user: %6
  br bb4(%5 : $E)                                 // id: %6

bb2(%7 : $Int32):                                 // Preds: bb0
  debug_value %7 : $Int32  // let x               // id: %8
  %9 = enum $E, #E.C2!enumelt.1, %7 : $Int32      // user: %10
  br bb4(%9 : $E)                                 // id: %10

bb3(%11 : $Int32):                                // Preds: bb0
  debug_value %11 : $Int32  // let x              // id: %12
  %13 = enum $E, #E.C3!enumelt.1, %11 : $Int32    // user: %14
  br bb4(%13 : $E)                                // id: %14

bb4(%15 : $E):                                    // Preds: bb1 bb2 bb3
  return %15 : $E                                 // id: %16
}

// CHECK-LABEL: sil @_TF10fold_enums26create_different_enum_caseFOS_1ES0_
// CHECK: bb0(%0 : $E)
// CHECK: switch_enum %0 : $E
// CHECK: bb1
// CHECK: bb2
// CHECK: bb3
// CHECK: return
sil @_TF10fold_enums26create_different_enum_caseFOS_1ES0_ : $@convention(thin) (E) -> E {
bb0(%0 : $E):
  debug_value %0 : $E  // let e                   // id: %1
  switch_enum %0 : $E, case #E.C1!enumelt.1: bb1, case #E.C2!enumelt.1: bb2, case #E.C3!enumelt.1: bb3 // id: %2

bb1(%3 : $Int32):                                 // Preds: bb0
  debug_value %3 : $Int32  // let x               // id: %4
  %5 = enum $E, #E.C2!enumelt.1, %3 : $Int32      // user: %6
  br bb4(%5 : $E)                                 // id: %6

bb2(%7 : $Int32):                                 // Preds: bb0
  debug_value %7 : $Int32  // let x               // id: %8
  %9 = enum $E, #E.C3!enumelt.1, %7 : $Int32      // user: %10
  br bb4(%9 : $E)                                 // id: %10

bb3(%11 : $Int32):                                // Preds: bb0
  debug_value %11 : $Int32  // let x              // id: %12
  %13 = enum $E, #E.C1!enumelt.1, %11 : $Int32    // user: %14
  br bb4(%13 : $E)                                // id: %14

bb4(%15 : $E):                                    // Preds: bb1 bb2 bb3
  return %15 : $E                                 // id: %16
}


