// RUN: %sil-opt %s -capture-promotion -verify | FileCheck %s

// Check to make sure that the process of promoting closure captures results in
// a correctly cloned and modified closure function body. This test
// intentionally only includes one promotable closure so that there is minimal
// ordering dependence in the checked output.

sil_stage raw

import Builtin
import swift

class Foo {
  func foo() -> Int
}

class Bar {
}

struct Baz {
  var bar: Bar
  var x: Int
}

sil @convert_from_integer_literal : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64
sil @foo_allocating_init : $@thin ((), Foo.metatype) -> Foo
sil @baz_init : $@thin ((), Baz.metatype) -> Baz
sil @dummy_func : $@thin (a: Int64, b: Int64, c: Int64) -> Int64

// CHECK-LABEL: sil @test_capture_promotion
sil @test_capture_promotion : $@thin () -> () -> Int64 {
bb0:
  %0 = tuple ()
  %1 = alloc_box $Foo
  %2 = function_ref @foo_allocating_init : $@thin ((), Foo.metatype) -> Foo
  %3 = metatype $Foo.metatype
  %4 = apply %2(%3) : $@thin ((), Foo.metatype) -> Foo
  store %4 to %1#1 : $*Foo
  %6 = alloc_box $Baz
  %7 = function_ref @baz_init : $@thin ((), Baz.metatype) -> Baz
  %8 = metatype $Baz.metatype
  %9 = apply %7(%8) : $@thin ((), Baz.metatype) -> Baz
  store %9 to %6#1 : $*Baz
  %11 = alloc_box $Int64
  %12 = function_ref @convert_from_integer_literal : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64
  %13 = metatype $Int64.metatype
  %14 = integer_literal $Builtin.Int64, 3
  %15 = apply [transparent] %12(%14, %13) : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64
  store %15 to %11#1 : $*Int64

// CHECK-NOT: function_ref @closure0 :
// CHECK: [[CLOSURE_PROMOTE:%.*]] = function_ref @closure0_promote
// CHECK-NOT: function_ref @closure0 :

// The three strong retains are removed

// The Foo variable is loaded from and retained, because it is a reference type
// CHECK-NEXT: [[LOADFOO:%.*]] = load {{.*}} : $*Foo
// CHECK-NEXT: strong_retain [[LOADFOO]] : $Foo

// The Baz variable is loaded and copy_value'd, because it is a non-trivial
// aggregate type
// CHECK-NEXT: [[LOADBAZ:%.*]] = load {{.*}} : $*Baz
// CHECK-NEXT: [[COPYBAZ:%.*]] = copy_value [[LOADBAZ:%.*]] : $Baz

// The Int64 variable is loaded only, because it is trivial
// CHECK-NEXT: [[LOADINT:%.*]] = load {{.*}} : $*Int64

// The partial apply has one value argument for each pair of arguments that was
// previously used to capture and pass the variable by reference
// CHECK-NEXT: {{.*}} = partial_apply [[CLOSURE_PROMOTE]]([[LOADFOO]], [[COPYBAZ]], [[LOADINT]])

  %17 = function_ref @closure0 : $@thin ((), (Builtin.ObjectPointer, @inout Foo, Builtin.ObjectPointer, @inout Baz, Builtin.ObjectPointer, @inout Int64)) -> Int64
  strong_retain %1#0 : $Builtin.ObjectPointer
  strong_retain %6#0 : $Builtin.ObjectPointer
  strong_retain %11#0 : $Builtin.ObjectPointer
  %21 = partial_apply %17(%1#0, %1#1, %6#0, %6#1, %11#0, %11#1) : $@thin ((), (Builtin.ObjectPointer, @inout Foo, Builtin.ObjectPointer, @inout Baz, Builtin.ObjectPointer, @inout Int64)) -> Int64

  strong_release %11#0 : $Builtin.ObjectPointer
  strong_release %6#0 : $Builtin.ObjectPointer
  strong_release %1#0 : $Builtin.ObjectPointer
  return %21 : $() -> Int64
}

sil internal @closure0 : $@thin ((), (Builtin.ObjectPointer, @inout Foo, Builtin.ObjectPointer, @inout Baz, Builtin.ObjectPointer, @inout Int64)) -> Int64 {
bb0(%0 : $Builtin.ObjectPointer, %1 : $*Foo, %2 : $Builtin.ObjectPointer, %3 : $*Baz, %4 : $Builtin.ObjectPointer, %5 : $*Int64):
  %6 = tuple ()
  // function_ref test14.plus (a : swift.Int64, b : swift.Int64, c : swift.Int64) -> swift.Int64
  %7 = function_ref @dummy_func : $@thin (a: Int64, b: Int64, c: Int64) -> Int64
  %8 = load %1 : $*Foo
  strong_retain %8 : $Foo
  %10 = class_method %8 : $Foo, #Foo.foo!1 : $@cc(method) @thin ((), Foo) -> Int64
  %11 = apply %10(%8) : $@cc(method) @thin ((), Foo) -> Int64
  %12 = struct_element_addr %3 : $*Baz, #x
  %13 = load %12 : $*Int64
  %14 = load %5 : $*Int64
  %15 = apply %7(%11, %13, %14) : $@thin (a: Int64, b: Int64, c: Int64) -> Int64
  strong_release %4 : $Builtin.ObjectPointer
  strong_release %2 : $Builtin.ObjectPointer
  strong_release %0 : $Builtin.ObjectPointer
  return %15 : $Int64
}

// The closure in this function is not promotable because it mutates its argument

// CHECK-LABEL: sil @test_unpromotable
sil @test_unpromotable : $@thin () -> () -> Int64 {
bb0:
  %0 = tuple ()
  %1 = alloc_box $Foo
  %2 = function_ref @foo_allocating_init : $@thin ((), Foo.metatype) -> Foo
  %3 = metatype $Foo.metatype
  %4 = apply %2(%3) : $@thin ((), Foo.metatype) -> Foo
  store %4 to %1#1 : $*Foo
  %17 = function_ref @closure1 : $@thin ((), (Builtin.ObjectPointer, @inout Foo)) -> Int64
  strong_retain %1#0 : $Builtin.ObjectPointer
  // CHECK: partial_apply {{%.*}}({{%.*}}#0, {{%.*}}#1)
  %21 = partial_apply %17(%1#0, %1#1) : $@thin ((), (Builtin.ObjectPointer, @inout Foo)) -> Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %21 : $() -> Int64
}

sil @mutate_foo : $@thin (@inout Foo) -> ()

sil internal @closure1 : $@thin ((), (Builtin.ObjectPointer, @inout Foo)) -> Int64 {
bb0(%0 : $Builtin.ObjectPointer, %1 : $*Foo):
  %6 = tuple ()
  // function_ref test14.plus (a : swift.Int64, b : swift.Int64, c : swift.Int64) -> swift.Int64
  %7 = function_ref @dummy_func : $@thin (a: Int64, b: Int64, c: Int64) -> Int64
  %8 = load %1 : $*Foo
  strong_retain %8 : $Foo
  %10 = class_method %8 : $Foo, #Foo.foo!1 : $@cc(method) @thin ((), Foo) -> Int64
  %11 = apply %10(%8) : $@cc(method) @thin ((), Foo) -> Int64
  %12 = function_ref @mutate_foo : $@thin (@inout Foo) -> ()
  %13 = apply %12(%1) : $@thin (@inout Foo) -> ()
  strong_release %0 : $Builtin.ObjectPointer
  return %11 : $Int64
}

// CHECK-LABEL: sil internal @closure0_promote0 : $@thin (Foo, Baz, Int64) -> Int64
// CHECK: [[DUMMY_FUNC:%.*]] = function_ref @dummy_func : $@thin (a: Int64, b: Int64, c: Int64) -> Int64

// The load of %1 is removed, and its uses replaced with the Foo argument
// CHECK-NEXT: strong_retain {{.*}} : $Foo
// CHECK-NEXT: [[METHOD_FOO:%.*]] = class_method {{.*}} : $Foo, #Foo.foo!1 : $@cc(method) @thin ((), Foo) -> Int64
// CHECK-NEXT: [[APPLY_FOO:%.*]] = apply [[METHOD_FOO]]({{.*}}) : $@cc(method) @thin ((), Foo) -> Int64

// The struct_element_addr of %3 followed by a load is replaced by a struct_extract of the Baz argument
// CHECK-NEXT: [[EXTRACT_BAZ_X:%.*]] = struct_extract {{.*}} : $Baz, #x

// CHECK-NEXT: [[RETVAL:%.*]] = apply [[DUMMY_FUNC]]([[APPLY_FOO]], [[EXTRACT_BAZ_X]], {{.*}}) : $@thin (a: Int64, b: Int64, c: Int64) -> Int64

// The release of %4 is removed because the Int64 type is trivial

// The release of %2 is replaced by a destroy_value of the Baz argument, since
// it is a non-trivial aggregate
// CHECK-NEXT: destroy_value {{.*}} : $Baz

// The release of %0 is replaced by a strong_release of the Foo argument, since
// is is a reference type
// CHECK-NEXT: strong_release {{.*}} : $Foo

// CHECK-NEXT: return [[RETVAL]] : $Int64
