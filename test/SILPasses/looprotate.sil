// RUN: %sil-opt -loop-rotate %s | FileCheck %s

sil_stage canonical

import Builtin
import Swift

// TODO: yikes! clean this up.
// CHECK-LABEL: looprotate
// CHECK: bb0(%0 : $Int):
// CHECK:  cond_br {{.*}}, bb4({{.*}} : $Builtin.Word), bb1

// CHECK:bb1:
// CHECK:  br bb2({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}}: $Int)

// CHECK: bb2({{.*}}: $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}} : $Int):
// CHECK:   br bb3({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word)

// CHECK: bb3({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word):
// CHECK:   cond_br %27, bb4({{.*}} : $Builtin.Word), bb2({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}} : $Int)

// CHECK: bb4({{.*}} : $Builtin.Word):
// CHECK:   %30 = struct $Int (%29 : $Builtin.Word)
// CHECK:   return %30 : $Int


sil @looprotate : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = integer_literal $Builtin.Word, 0
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word)

bb1(%4 : $Builtin.Word, %5 : $Builtin.Word):
  %6 = struct $Int (%5 : $Builtin.Word)
  %7 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  %8 = apply %7(%5, %1) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %8, bb3, bb2

bb2:
  %10 = integer_literal $Builtin.Word, 1
  %11 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %12 = integer_literal $Builtin.Int1, -1
  %13 = apply %11(%5, %10, %12) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0
  %15 = enum $Optional<Int>, #Optional.Some!enumelt.1, %6 : $Int
  %16 = unchecked_enum_data %15 : $Optional<Int>, #Optional.Some!enumelt.1
  %17 = struct_extract %16 : $Int, #Int.value
  %18 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %19 = integer_literal $Builtin.Int1, -1
  %20 = apply %18(%4, %17, %19) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Word, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Word, %14 : $Builtin.Word)

bb3:
  %23 = struct $Int (%4 : $Builtin.Word)
  return %23 : $Int
}


// This example illustrates the problem with using ValueUseIterators.
// As part of updating SSA form we will introduce a phi node argument to the
// branch to bb2. This means we change "cond_br %8, bb3(%4 : $Builtin.Word),
// bb2" invalidating any outstanding use iterator pointing to the use of "%4" in
// said branch.

// CHECK-LABEL: looprotate2
// CHECK: return
sil @looprotate2 : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = integer_literal $Builtin.Word, 0
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word)

bb1(%4 : $Builtin.Word, %5 : $Builtin.Word):
  %6 = struct $Int (%5 : $Builtin.Word)
  %7 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  %8 = apply %7(%5, %1) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %8, bb3(%4 : $Builtin.Word), bb2

bb2:
  %10 = integer_literal $Builtin.Word, 1
  %11 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %12 = integer_literal $Builtin.Int1, -1
  %13 = apply %11(%5, %10, %12) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0
  %15 = enum $Optional<Int>, #Optional.Some!enumelt.1, %6 : $Int
  %16 = unchecked_enum_data %15 : $Optional<Int>, #Optional.Some!enumelt.1
  %17 = struct_extract %16 : $Int, #Int.value
  %18 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %19 = integer_literal $Builtin.Int1, -1
  %20 = apply %18(%4, %17, %19) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Word, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Word, %14 : $Builtin.Word)

bb3 (%23 : $Builtin.Word) :
  %24 = struct $Int (%23 : $Builtin.Word)
  return %24 : $Int
}
