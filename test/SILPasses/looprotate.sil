// RUN: %target-sil-opt -loop-rotate %s | FileCheck %s

sil_stage canonical

import Builtin
import Swift

// CHECK-LABEL: looprotate
// CHECK: bb0(%0 : $Int, %1 : $Bar):
// CHECK:  class_method
// CHECK:  cond_br {{.*}}, bb4({{.*}} : $Builtin.Word), bb1

// CHECK:bb1:
// CHECK:  br bb2({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}}: $Int)

// CHECK: bb2({{.*}}: $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}} : $Int):
// CHECK:   br bb3({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}})

// CHECK: bb3({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}}):
// CHECK:   class_method
// CHECK:   cond_br {{%.*}}, bb4({{.*}} : $Builtin.Word), bb2({{.*}} : $Builtin.Word, {{.*}} : $Builtin.Word, {{.*}} : $Int)

// CHECK: bb4({{.*}} : $Builtin.Word):
// CHECK:   [[STRUCT:%.*]] = struct $Int ({{%.*}} : $Builtin.Word)
// CHECK:   return [[STRUCT]] : $Int

class Bar {
  func foo()
  @objc func foo_objc()
}

sil @_TFC4main3Bar3foofS0_FT_T_ : $@cc(method) @thin (@owned Bar) -> ()
sil @_TFC4main3Bar3foo_objcfS0_FT_T_ : $@cc(objc_method) @thin (Bar) -> ()

sil_vtable Bar {
  #Bar.foo!1: _TFC4main3Bar3foofS0_FT_T_
  #Bar.foo_objc!1: _TFC4main3Bar3foofS0_FT_T_
}

sil @looprotate : $@thin (Int, @owned Bar) -> Int {
bb0(%0 : $Int, %25: $Bar):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = integer_literal $Builtin.Word, 0
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word, %25: $Bar)

bb1(%4 : $Builtin.Word, %5 : $Builtin.Word, %26: $Bar):
  %24 = class_method %26 : $Bar, #Bar.foo!1 : Bar -> () -> () , $@cc(method) @thin (@owned Bar) -> () // user: %6
  %27 = apply %24(%25) : $@cc(method) @thin (@owned Bar) -> ()
  %6 = struct $Int (%5 : $Builtin.Word)
  %8 = builtin "cmp_eq_Word"(%5 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  cond_br %8, bb3, bb2

bb2:
  %10 = integer_literal $Builtin.Word, 1
  %12 = integer_literal $Builtin.Int1, -1
  %13 = builtin "sadd_with_overflow_Word"(%5 : $Builtin.Word, %10 : $Builtin.Word, %12 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0
  %15 = enum $Optional<Int>, #Optional.Some!enumelt.1, %6 : $Int
  %16 = unchecked_enum_data %15 : $Optional<Int>, #Optional.Some!enumelt.1
  %17 = struct_extract %16 : $Int, #Int.value
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Word"(%4 : $Builtin.Word, %17 : $Builtin.Word, %19 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Word, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Word, %14 : $Builtin.Word, %26: $Bar)

bb3:
  %23 = struct $Int (%4 : $Builtin.Word)
  return %23 : $Int
}

// This example illustrates the problem with using ValueUseIterators.
// As part of updating SSA form we will introduce a phi node argument to the
// branch to bb2. This means we change "cond_br %8, bb3(%4 : $Builtin.Word),
// bb2" invalidating any outstanding use iterator pointing to the use of "%4" in
// said branch.

// CHECK-LABEL: looprotate2
// CHECK: return
sil @looprotate2 : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = integer_literal $Builtin.Word, 0
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word)

bb1(%4 : $Builtin.Word, %5 : $Builtin.Word):
  %6 = struct $Int (%5 : $Builtin.Word)
  %8 = builtin "cmp_eq_Word"(%5 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  cond_br %8, bb3(%4 : $Builtin.Word), bb2

bb2:
  %10 = integer_literal $Builtin.Word, 1
  %12 = integer_literal $Builtin.Int1, -1
  %13 = builtin "sadd_with_overflow_Word"(%5 : $Builtin.Word, %10 : $Builtin.Word, %12 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0
  %15 = enum $Optional<Int>, #Optional.Some!enumelt.1, %6 : $Int
  %16 = unchecked_enum_data %15 : $Optional<Int>, #Optional.Some!enumelt.1
  %17 = struct_extract %16 : $Int, #Int.value
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Word"(%4 : $Builtin.Word, %17 : $Builtin.Word, %19 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Word, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Word, %14 : $Builtin.Word)

bb3 (%23 : $Builtin.Word) :
  %24 = struct $Int (%23 : $Builtin.Word)
  return %24 : $Int
}

// Don't assert on this loop. bb2 is bb1 loop's new header after rotation but
// also bb2 loop's header.

// CHECK-LABEL: @testnested
// CHECK: return
sil @testnested : $@thin () -> () {
bb0:
  br bb1(undef : $Builtin.Word, undef : $Builtin.Word) // id: %0

bb1(%1 : $Builtin.Word, %2 : $Builtin.Word):      // Preds: bb0 bb2
  %3 = integer_literal $Builtin.Int1, 0           // user: %4
  cond_br %3, bb2(%1 : $Builtin.Word, %2 : $Builtin.Word), bb10 // id: %4

bb2(%5 : $Builtin.Word, %6 : $Builtin.Word):      // Preds: bb1 bb8
  %7 = integer_literal $Builtin.Int1, -1          // user: %8
  cond_br %7, bb3, bb1(%5 : $Builtin.Word, %6 : $Builtin.Word) // id: %8

bb3:                                              // Preds: bb2
  %9 = integer_literal $Builtin.Word, 0           // user: %11
  %10 = integer_literal $Builtin.Word, 1          // users: %14, %23
  br bb4(%9 : $Builtin.Word)                      // id: %11

bb4(%12 : $Builtin.Word):                         // Preds: bb3 bb7
  %14 = builtin "cmp_eq_Word"(%12 : $Builtin.Word, %10 : $Builtin.Word) : $Builtin.Int1 // user: %15
  cond_br %14, bb5, bb9                           // id: %15

bb5:                                              // Preds: bb4
  %16 = enum $Optional<Int>, #Optional.None!enumelt // user: %17
  br bb6(%12 : $Builtin.Word, %16 : $Optional<Int>) // id: %17

bb6(%18 : $Builtin.Word, %19 : $Optional<Int>):   // Preds: bb5 bb9
  switch_enum %19 : $Optional<Int>, case #Optional.Some!enumelt.1: bb7, case #Optional.None!enumelt: bb8 // id: %20

bb7:                                              // Preds: bb6
  %21 = unchecked_enum_data %19 : $Optional<Int>, #Optional.Some!enumelt.1
  br bb4(%18 : $Builtin.Word)                     // id: %22

bb8:                                              // Preds: bb6
  br bb2(%18 : $Builtin.Word, %10 : $Builtin.Word) // id: %23

bb9:                                              // Preds: bb4
  %24 = struct $Int (%12 : $Builtin.Word)         // user: %32
  %25 = integer_literal $Builtin.Word, 1          // user: %28
  %27 = integer_literal $Builtin.Int1, -1         // user: %28
  %28 = builtin "sadd_with_overflow_Word"(%12 : $Builtin.Word, %25 : $Builtin.Word, %27 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1) // users: %29, %30
  %29 = tuple_extract %28 : $(Builtin.Word, Builtin.Int1), 0 // user: %33
  %30 = tuple_extract %28 : $(Builtin.Word, Builtin.Int1), 1 // user: %31
  cond_fail %30 : $Builtin.Int1                   // id: %31
  %32 = enum $Optional<Int>, #Optional.Some!enumelt.1, %24 : $Int // user: %33
  br bb6(%29 : $Builtin.Word, %32 : $Optional<Int>) // id: %33

bb10:                                             // Preds: bb1
  %34 = tuple ()                                  // user: %35
  return %34 : $()                                // id: %35
}

// CHECK-LABEL: dont_looprotate_objc
// CHECK: bb0{{.*}}:
// CHECK:  br bb1
// CHECK: bb1{{.*}}:
// CHECK:  cond_br {{.*}}, bb3, bb2
// CHECK: bb2:
// CHECK:   br bb1
// CHECK: bb3:
// CHECK:   return

sil @dont_looprotate_objc : $@thin (Int, @owned Bar) -> Int {
bb0(%0 : $Int, %25: $Bar):
  %100 = alloc_ref $Bar
  %1 = struct_extract %0 : $Int, #Int.value
  %2 = integer_literal $Builtin.Word, 0
  br bb1(%1 : $Builtin.Word, %2 : $Builtin.Word, %25: $Bar)

bb1(%4 : $Builtin.Word, %5 : $Builtin.Word, %26: $Bar):
  %101 = class_method [volatile] %100 : $Bar, #Bar.foo!1.foreign : Bar -> () -> () , $@cc(objc_method) @thin (Bar) -> ()
  %6 = struct $Int (%5 : $Builtin.Word)
  %8 = builtin "cmp_eq_Word"(%5 : $Builtin.Word, %1 : $Builtin.Word) : $Builtin.Int1
  cond_br %8, bb3, bb2

bb2:
  %102 = apply %101(%100) : $@cc(objc_method) @thin (Bar) -> ()
  %10 = integer_literal $Builtin.Word, 1
  %12 = integer_literal $Builtin.Int1, -1
  %13 = builtin "sadd_with_overflow_Word"(%5 : $Builtin.Word, %10 : $Builtin.Word, %12 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0
  %15 = enum $Optional<Int>, #Optional.Some!enumelt.1, %6 : $Int
  %16 = unchecked_enum_data %15 : $Optional<Int>, #Optional.Some!enumelt.1
  %17 = struct_extract %16 : $Int, #Int.value
  %19 = integer_literal $Builtin.Int1, -1
  %20 = builtin "sadd_with_overflow_Word"(%4 : $Builtin.Word, %17 : $Builtin.Word, %19 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %21 = tuple_extract %20 : $(Builtin.Word, Builtin.Int1), 0
  br bb1(%21 : $Builtin.Word, %14 : $Builtin.Word, %26: $Bar)

bb3:
  %23 = struct $Int (%4 : $Builtin.Word)
  return %23 : $Int
}

sil @readInt : $@thin (Int) -> () {
bb0(%a0 : $Int):
  %t1 = tuple ()
  return %t1 : $()
}

// Test the SSA Updater utility: replaceBBArgWithCast().
//
// CHECK-LABEL: struct_arg
// CHECK: bb0:
// CHECK:  cond_br
// CHECK: bb1:
// CHECK:  br bb2
// CHECK: bb2([[WORD:%[0-9]+]]
// CHECK:  [[STRUCT:%[0-9]+]] = struct $Int ([[WORD]]
// CHECK:  apply {{.*}}([[STRUCT]])
// CHECK:  br bb3
// CHECK: bb3
// CHECK:  cond_br
// CHECK: bb4:
// CHECK:  return
sil @struct_arg : $@thin () -> () {
bb0:
  %c0 = integer_literal $Builtin.Word, 0
  %c100 = integer_literal $Builtin.Word, 100
  br bb1(%c0 : $Builtin.Word)

bb1(%a0 : $Builtin.Word):
  %s0 = struct $Int (%a0 : $Builtin.Word)
  %z1 = builtin "cmp_eq_Word"(%a0 : $Builtin.Word, %c100 : $Builtin.Word) : $Builtin.Int1
  cond_br %z1, bb2, bb3

bb3:
  %c1 = integer_literal $Builtin.Word, 1
  %z2 = integer_literal $Builtin.Int1, 0
  %d1 = builtin "sadd_with_overflow_Word"(%a0 : $Builtin.Word, %c1 : $Builtin.Word, %z2 : $Builtin.Int1) : $(Builtin.Word, Builtin.Int1)
  %t1 = tuple_extract %d1 : $(Builtin.Word, Builtin.Int1), 0
  %f1 = function_ref @readInt : $@thin (Int) -> ()
  %l1 = apply %f1(%s0) : $@thin (Int) -> ()
  br bb1(%t1 : $Builtin.Word)

bb2:
  %t2 = tuple ()
  return %t2 : $()

}

// Test LoopRotate insertBackedgeBlock.
//
// CHECK-LABEL: insert_backedge_block
// PreLoop Check
// CHECK: bb0(%
// CHECK:   cond_br
// Loop Header
// CHECK: bb1:
// CHECK-NEXT: br bb2
// CHECK: bb2:
// CHECK:   cond_br %{{.*}}, bb3, bb6
// CHECK: bb3:
// CHECK:   apply
// CHECK:   br bb4(
// CHECK: bb4(%[[ARG:[0-9]*]]
// CHECK-NEXT: br bb5(%[[ARG]]
// CHECK: bb5(%
// CHECK-NEXT: cond_br %{{.*}}, bb7, bb2
// CHECK: bb6:
// CHECK:   apply
// CHECK:   br bb4(%
// CHECK: bb7
// CHECK:   return
sil @insert_backedge_block : $@thin (@owned @callee_owned () -> Builtin.Word) -> () {
bb0(%0 : $@callee_owned () -> Builtin.Word):
  %r0 = apply %0() : $@callee_owned () -> Builtin.Word
  br bb1(%r0: $Builtin.Word)

bb1(%a1 : $Builtin.Word):
  %z1 = integer_literal $Builtin.Int1, 0
  cond_br %z1, bb5, bb2

bb2:
  %z2 = integer_literal $Builtin.Int1, 0
  cond_br %z2, bb3, bb4

bb3:
  %r1 = apply %0() : $@callee_owned () -> Builtin.Word
  br bb1(%r1: $Builtin.Word)

bb4:
  %r2 = apply %0() : $@callee_owned () -> Builtin.Word
  br bb1(%r2: $Builtin.Word)

bb5:
  %r3 = tuple ()
  return %r3 : $()

}
