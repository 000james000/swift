// RUN: %sil-opt %s -simplify-cfg | FileCheck %s
// FIXME: Update for select_enum change.
// RUN: %sil-opt %s -simplify-cfg -sil-combine -simplify-cfg | not FileCheck %s --check-prefix=CHECK_WITH_COMBINE
import Builtin
import Swift

sil_stage canonical

// CHECK-LABEL: @test_dead_block
// CHECK-NEXT: bb0:
// CHECK-NEXT:   unreachable
// CHECK-NEXT: }
sil @test_dead_block : $() -> () {
bb0:
  unreachable

bb1:
  %4 = integer_literal $Builtin.Int64, 1
  br bb2

bb2:
  %5 = struct $Int64 (%4 : $Builtin.Int64)
  unreachable
}

// CHECK-LABEL: @test_single_pred_block
// CHECK: struct $Int64
// CHECK-NEXT: return
sil @test_single_pred_block : $@thin (Builtin.Int1) -> Int64 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb3

bb1:
  %4 = integer_literal $Builtin.Int64, 1
  br bb2(%4 : $Builtin.Int64)

bb3:
  %9 = integer_literal $Builtin.Int64, 2
  br bb2(%9 : $Builtin.Int64)

bb2(%6 : $Builtin.Int64):
  %7 = struct $Int64 (%6 : $Builtin.Int64)
  br bb4(%7 : $Int64)

bb4(%8 : $Int64):
  return %8 : $Int64
}

enum BoolLike { case true_, false_ }

// func testThread(a : BoolLike) -> Int {
//   if a { return 42 } else { return 17 } }
//
/// CHECK-LABEL: sil @testThread
sil @testThread : $@thin (@in BoolLike) -> Int64 {
bb0(%0 : $*BoolLike):
  // CHECK: switch_enum_addr %0 : $*BoolLike, case #BoolLike.true_!enumelt: bb1, case #BoolLike.false_!enumelt: bb2
  switch_enum_addr %0 : $*BoolLike, case #BoolLike.true_!enumelt: bb1, case #BoolLike.false_!enumelt: bb3 // id: %3

bb1:                                              // Preds: bb0
  %4 = integer_literal $Builtin.Int1, -1          // user: %5
  br bb2(%4 : $Builtin.Int1)                      // id: %5

bb2(%6 : $Builtin.Int1):                          // Preds: bb3 bb1
  br bb4                                          // id: %7

bb3:                                              // Preds: bb0
  %8 = integer_literal $Builtin.Int1, 0           // user: %9
  br bb2(%8 : $Builtin.Int1)                      // id: %9

bb4:                                              // Preds: bb2
  cond_br %6, bb5, bb6                            // id: %10

bb5:                                              // Preds: bb4
  %11 = metatype $@thin Int64.Type
  %12 = integer_literal $Builtin.Int64, 42        // user: %13
  %13 = struct $Int64 (%12 : $Builtin.Int64)      // user: %14
  br bb7(%13 : $Int64)                            // id: %14

bb6:                                              // Preds: bb4
  %15 = metatype $@thin Int64.Type
  %16 = integer_literal $Builtin.Int64, 17        // user: %17
  %17 = struct $Int64 (%16 : $Builtin.Int64)      // user: %18
  br bb7(%17 : $Int64)                            // id: %18

bb7(%19 : $Int64):                                // Preds: bb6 bb5
  return %19 : $Int64                             // id: %21
}

// func testThread2(a : Int) -> Int {
//   enum b = (a ? _true : _false)
//   if b == _true { return 42 } else { return 17 }
//
/// CHECK-LABEL: sil @testThread
sil @testThread2 : $@thin (Builtin.Int1) -> Int64 {
bb0(%0 : $Builtin.Int1):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  cond_br %0, bb1, bb2

bb1:                                              // Preds: bb0
/// CHECK: bb1:
/// CHECK: [[ENUM1:%.*]] = select_enum
/// CHECK: cond_br [[ENUM1]], bb3, bb4
  %4 = enum $BoolLike, #BoolLike.true_!enumelt          // user: %5
  br bb3(%4 : $BoolLike)                      // id: %5

bb2:                                              // Preds: bb0
/// CHECK: bb2:
/// CHECK: [[ENUM2:%.*]] = select_enum
/// CHECK: cond_br [[ENUM2]], bb3, bb4
  %8 = enum $BoolLike, #BoolLike.false_!enumelt           // user: %9
  br bb3(%8 : $BoolLike)                      // id: %9

bb3(%6 : $BoolLike):                          // Preds: bb3 bb1
/// CHECK: bb3:
  %100 = select_enum %6 : $BoolLike, case #BoolLike.true_!enumelt: %t, case #BoolLike.false_!enumelt: %f : $Builtin.Int1
  br bb4                                          // id: %7

bb4:                                              // Preds: bb2
  cond_br %100, bb5, bb6                            // id: %10

bb5:                                              // Preds: bb4
  %11 = metatype $@thin Int64.Type
  %12 = integer_literal $Builtin.Int64, 42        // user: %13
  %13 = struct $Int64 (%12 : $Builtin.Int64)      // user: %14
  br bb7(%13 : $Int64)                            // id: %14

bb6:                                              // Preds: bb4
  %15 = metatype $@thin Int64.Type
  %16 = integer_literal $Builtin.Int64, 17        // user: %17
  %17 = struct $Int64 (%16 : $Builtin.Int64)      // user: %18
  br bb7(%17 : $Int64)                            // id: %18

bb7(%19 : $Int64):                                // Preds: bb6 bb5
  return %19 : $Int64                             // id: %21
}

// func testThread3(a : Int) -> Int {
//   (enum b, val) = (a ? (_true, 16) : (_false, 17))
//   if b == true { return 42 } else { return v } }
//
/// CHECK-LABEL: sil @testThread3
sil @testThread3 : $@thin (Builtin.Int1) -> Int64 {
bb0(%0 : $Builtin.Int1):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  cond_br %0, bb1, bb2

bb1:                                              // Preds: bb0
/// CHECK: bb1:
/// CHECK: [[VAL1:%.*]] = integer_literal $Builtin.Int64, 16
/// CHECK: [[ENUM1:%.*]] = select_enum
/// CHECK: cond_br [[ENUM1]], bb3, bb4([[VAL1]] : $Builtin.Int64)
  %4 = enum $BoolLike, #BoolLike.true_!enumelt          // user: %5
  %40 = integer_literal $Builtin.Int64, 16
  br bb3(%4 : $BoolLike, %40 : $Builtin.Int64)                      // id: %5

bb2:                                              // Preds: bb0
/// CHECK: bb2:
/// CHECK: [[VAL2:%.*]] = integer_literal $Builtin.Int64, 17
/// CHECK: [[ENUM2:%.*]] = select_enum
/// CHECK: cond_br [[ENUM2]], bb3, bb4([[VAL2]] : $Builtin.Int64)
  %8 = enum $BoolLike, #BoolLike.false_!enumelt           // user: %9
  %80 = integer_literal $Builtin.Int64, 17
  br bb3(%8 : $BoolLike, %80 : $Builtin.Int64)                      // id: %9

bb3(%6 : $BoolLike, %60 : $Builtin.Int64):                          // Preds: bb3 bb1
  %100 = select_enum %6 : $BoolLike, case #BoolLike.true_!enumelt: %t, case #BoolLike.false_!enumelt: %f : $Builtin.Int1
  br bb4                                          // id: %7

bb4:                                              // Preds: bb2
  cond_br %100, bb5, bb6                            // id: %10

bb5:                                              // Preds: bb4
/// CHECK: bb3:
/// CHECK: %{{.*}} = integer_literal $Builtin.Int64, 42
/// CHECK: br bb5({{.*}})
  %11 = metatype $@thin Int64.Type
  %12 = integer_literal $Builtin.Int64, 42        // user: %13
  %13 = struct $Int64 (%12 : $Builtin.Int64)      // user: %14
  br bb7(%13 : $Int64)                            // id: %14

bb6:                                              // Preds: bb4
/// CHECK: bb4(%{{.*}} : $Builtin.Int64):
/// CHECK: br bb5({{.*}})
  %15 = metatype $@thin Int64.Type
  %17 = struct $Int64 (%60 : $Builtin.Int64)      // user: %18
  br bb7(%17 : $Int64)                            // id: %18

bb7(%19 : $Int64):                                // Preds: bb6 bb5
/// CHECK: bb5(%{{.*}} : $Int64):
/// CHECK: return
  return %19 : $Int64                             // id: %21
}



/// CHECK-LABEL: sil @testCondBrFold
/// CHECK-NEXT: bb0(
/// CHECK-NEXT: return %1 : $Int64
sil @testCondBrFold : $@thin (Int64, Int64) -> Int64 {
bb0(%0 : $Int64, %1 : $Int64):
  %8 = integer_literal $Builtin.Int1, 0
  cond_br %8, bb1, bb2
bb1:
  unreachable
bb2:
  return %1 : $Int64
}

/// CHECK-LABEL: sil @testSwitchEnumFold
/// CHECK-NEXT: bb0(
/// CHECK-NEXT: return %0 : $Int64
sil @testSwitchEnumFold : $@thin (Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = enum $BoolLike, #BoolLike.true_!enumelt
  switch_enum %1 : $BoolLike, case #BoolLike.true_!enumelt: bb2, case #BoolLike.false_!enumelt: bb1
bb1:
  unreachable
bb2:
  return %0 : $Int64
}

// CHECK-LABEL: @elim_trampoline
// CHECK: cond_br %0, bb1(%1 : $Int64), bb1(%2 : $Int64)
// CHECK: bb1
// CHECK-NEXT: return
sil @elim_trampoline : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%2 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb3(%4 : $Int64)

bb3(%5 : $Int64):
  return %5 : $Int64
}

// CHECK-LABEL: @elim_trampoline2
// CHECK-NOT: cond_br %0, bb1(%1 : $Int64), bb1(%1 : $Int64)
// CHECK: return
sil @elim_trampoline2 : $@thin (Builtin.Int1, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%1 : $Int64)

bb1(%2 : $Int64):
  br bb3(%2 : $Int64)

bb2(%3 : $Int64):
  br bb3(%3 : $Int64)

bb3(%4 : $Int64):
  return %4 : $Int64
}

// CHECK-LABEL: @elim_trampoline3
// CHECK: cond_br %0, bb1(%1 : $Int64), bb1(%2 : $Int64)
// CHECK: bb1
// CHECK-NEXT: return
sil @elim_trampoline3 : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%2 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb3(%4 : $Int64)

bb3(%5 : $Int64):
  br bb4(%5 : $Int64)

bb4(%6 : $Int64):
  return %6 : $Int64
}

// CHECK-LABEL: @elim_trampoline_loop
// Make sure we are not crashing on this one.
// CHECK: return
sil @elim_trampoline_loop : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%2 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb2(%4 : $Int64)

bb3(%5 : $Int64):
  br bb4(%5 : $Int64)

bb4(%6 : $Int64):
  return %6 : $Int64
}

// CHECK-LABEL: @elim_diamonds
// CHECK: bb0
// CHECK-NEXT: return %1
sil @elim_diamonds : $@thin (Builtin.Int1, Int64, Int64) -> Int64 {
bb0(%0 : $Builtin.Int1, %1 : $Int64, %2 : $Int64):
  cond_br %0, bb1(%1 : $Int64), bb2(%1 : $Int64)

bb1(%3 : $Int64):
  br bb3(%3 : $Int64)

bb2(%4 : $Int64):
  br bb3(%4 : $Int64)

bb3(%5 : $Int64):
  cond_br %0, bb4(%5 : $Int64), bb5(%5 : $Int64)

bb4(%6 : $Int64):
  br bb6(%6 : $Int64)

bb5(%7 : $Int64):
  br bb6(%7 : $Int64)

bb6(%8 : $Int64):
  return %8 : $Int64
}

// CHECK-LABEL: @infinite_loop
// CHECK: bb0
// CHECK-NEXT: br bb0
sil @infinite_loop : $@thin () -> () {
bb0:
  br bb0
}

import Builtin
import Swift

// CHECK-LABEL: @dead_loop
// CHECK-NOT: br
sil @dead_loop : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Int1, 0           // users: %1, %4
  %2 = integer_literal $Builtin.Int1, -1          // user: %11
  cond_br %0, bb1, bb3                            // id: %4

bb1:                                              // Preds: bb0
  %5 = integer_literal $Builtin.Word, 0           // users: %6, %7
  %6 = struct $Int (%5 : $Builtin.Word)
  br bb2(%5 : $Builtin.Word)                      // id: %7

bb2(%8 : $Builtin.Word):                          // Preds: bb1 bb2
  %9 = integer_literal $Builtin.Word, 1           // user: %11
  %10 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %11
  %11 = apply %10(%8, %9, %2) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // users: %12, %13
  %12 = tuple_extract %11 : $(Builtin.Word, Builtin.Int1), 0 // users: %15, %16
  %13 = tuple_extract %11 : $(Builtin.Word, Builtin.Int1), 1 // user: %14
  cond_fail %13 : $Builtin.Int1                   // id: %14
  %15 = struct $Int (%12 : $Builtin.Word)
  br bb2(%12 : $Builtin.Word)                     // id: %16

bb3:                                              // Preds: bb0
  %17 = tuple ()                                  // user: %18
  return %17 : $()                                // id: %18
}

// We should be able to compile this down to returning the parameter
// but we're not quite there yet.
// CHECK-LABEL: @nop
sil @nop : $@thin (Bool) -> Bool {
bb0(%0 : $Bool):
  %1 = struct_extract %0 : $Bool, #Bool.value
// CHECK: cond_br %1, [[TRUE:[a-zA-Z0-9]+]], [[FALSE:[a-zA-Z0-9]+]]
  cond_br %1, bb1, bb2

// CHECK: [[TRUE]]:
bb1:
  %3 = integer_literal $Builtin.Int1, 0
  %4 = struct $Bool (%3 : $Builtin.Int1)
// CHECK: br [[RETURN:[a-zA-Z0-9]+]]
  br bb3(%4 : $Bool)

// CHECK: [[FALSE]]:
bb2:
  %6 = integer_literal $Builtin.Int1, -1          // user: %7
  %7 = struct $Bool (%6 : $Builtin.Int1)          // user: %8
// CHECK: br [[RETURN]]
  br bb3(%7 : $Bool)                              // id: %8

// CHECK: [[RETURN]]
bb3(%9 : $Bool):                                  // Preds: bb1 bb2
// CHECK-NOT: struct_extract
  %10 = struct_extract %9 : $Bool, #Bool.value    // user: %11
// CHECK: return
  cond_br %10, bb4, bb5                           // id: %11

// CHECK-NOT: bb4
bb4:                                              // Preds: bb3
  %12 = integer_literal $Builtin.Int1, 0          // user: %13
  %13 = struct $Bool (%12 : $Builtin.Int1)        // user: %14
  br bb6(%13 : $Bool)                             // id: %14

// CHECK-NOT: bb5
bb5:                                              // Preds: bb3
  %15 = integer_literal $Builtin.Int1, -1         // user: %16
  %16 = struct $Bool (%15 : $Builtin.Int1)        // user: %17
  br bb6(%16 : $Bool)                             // id: %17

bb6(%18 : $Bool):                                 // Preds: bb4 bb5
  return %18 : $Bool                              // id: %19
}

class C {
  final var value: Int
  init(v: Int)
}

// CHECK-LABEL: @redundant_switch_enum
sil @redundant_switch_enum : $@thin (@owned Optional<C>) -> Int {
bb0(%0 : $Optional<C>):
  switch_enum %0 : $Optional<C>, case #Optional.Some!enumelt.1: bb1, case #Optional.None!enumelt: bb2

// CHECK: bb1:
bb1:
  %9 = integer_literal $Builtin.Int1, -1
  %10 = struct $Bool (%9 : $Builtin.Int1)
// CHECK:  br [[DEST:[a-zA-Z0-9]+]]
  br bb3(%10 : $Bool)

// CHECK: bb2:
bb2:
  %17 = integer_literal $Builtin.Int1, 0
  %18 = struct $Bool (%17 : $Builtin.Int1)
// CHECK: br [[DEST]]
  br bb3(%18 : $Bool)

// CHECK: [[DEST]]({{.*}}):
bb3(%12 : $Bool):
  %15 = struct_extract %12 : $Bool, #Bool.value
// CHECK-NOT: cond_br
// CHECK: return
  cond_br %15, bb4, bb7

// CHECK-NOT: bb4:
bb4:
  %21 = alloc_stack $Optional<C>
  store %0 to %21#1 : $*Optional<C>
// CHECK-NOT: switch_enum
  switch_enum %0 : $Optional<C>, case #Optional.Some!enumelt.1: bb5, case #Optional.None!enumelt: bb6

bb5:
  %25 = unchecked_take_enum_data_addr %21#1 : $*Optional<C>, #Optional.Some!enumelt.1
  %26 = load %25 : $*C
  dealloc_stack %21#0 : $*@local_storage Optional<C>
  %29 = ref_element_addr %26 : $C, #C.value
  %30 = load %29 : $*Int
  br bb8(%30 : $Int)

bb6:
  %33 = builtin_function_ref "int_trap" : $@thin @noreturn () -> ()
  %34 = apply %33() : $@thin @noreturn () -> ()
  unreachable

bb7:
  %36 = integer_literal $Builtin.Word, 0
  %37 = struct $Int (%36 : $Builtin.Word)
  br bb8(%37 : $Int)

bb8(%39 : $Int):
  release_value %0 : $Optional<C>
  return %39 : $Int
}

enum A {
  case B, C, D
}

// CHECK-LABEL: cannot_optimize_switch_enum
sil @cannot_optimize_switch_enum : $@thin (A) -> () {
// CHECK: bb0
bb0(%0 : $A):
// CHECK-NEXT: switch_enum %0 : $A, case #A.B!enumelt: bb1, default [[BB:bb[0-9a-zA-Z]+]]
  switch_enum %0 : $A, case #A.B!enumelt: bb1, default bb2

bb1:
  br bb5

// CHECK: [[BB]]
bb2:
// CHECK-NEXT: switch_enum %0
  switch_enum %0 : $A, case #A.C!enumelt: bb3, default bb4

bb3:
  br bb5

bb4:
  br bb5

bb5:
  %6 = tuple ()
  return %6 : $()
}

// CHECK-LABEL: @dominator_based_simplify_condbr
// CHECK:  integer_literal $Builtin.Int64, 1
// CHECK-NOT:  integer_literal $Builtin.Int64, 2
// CHECK-NOT:  integer_literal $Builtin.Int64, 3
// CHECK:  integer_literal $Builtin.Int64, 4
// CHECK: return
sil @dominator_based_simplify_condbr : $@thin (Builtin.Int1) -> Int64 {
bb0(%0 : $Builtin.Int1):
  cond_br %0, bb1, bb4

bb1:
  cond_br %0, bb2, bb3

bb2:
  %1 = integer_literal $Builtin.Int64, 1
  br bb7(%1 : $Builtin.Int64)

bb3:
  %2 = integer_literal $Builtin.Int64, 2
  br bb7(%2 : $Builtin.Int64)

bb4:
  cond_br %0, bb5, bb6

bb5:
  %3 = integer_literal $Builtin.Int64, 3
  br bb7(%3 : $Builtin.Int64)

bb6:
  %4 = integer_literal $Builtin.Int64, 4
  br bb7(%4 : $Builtin.Int64)

bb7(%6 : $Builtin.Int64):
  %7 = struct $Int64 (%6 : $Builtin.Int64)
  return %7 : $Int64
}

// CHECK-LABEL: simplify_loop_header
// CHECK-NOT: switch_enum
// CHECK: bb0
// CHECK:  br bb1
// CHECK: bb1
// CHECK:  cond_br {{.*}}, bb2, bb3
// CHECK: bb2:
// CHECK:  return
// CHECK: bb3:
// CHECK:  br bb1

sil @simplify_loop_header : $@thin () -> () {
bb0:
  %0 = integer_literal $Builtin.Word, 0
  %1 = integer_literal $Builtin.Word, 1000
  br bb1(%0 : $Builtin.Word)

bb1(%3 : $Builtin.Word):
  %4 = struct $Int (%3 : $Builtin.Word)
  %5 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  %6 = apply %5(%3, %1) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %6, bb2, bb3

bb2:
  %8 = enum $Optional<Int>, #Optional.None!enumelt
  br bb4(%3 : $Builtin.Word, %8 : $Optional<Int>)

bb3:
  %10 = integer_literal $Builtin.Word, 1
  %11 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %12 = integer_literal $Builtin.Int1, -1
  %13 = apply %11(%3, %10, %12) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %14 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 0
  %15 = tuple_extract %13 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %15 : $Builtin.Int1
  %17 = enum $Optional<Int>, #Optional.Some!enumelt.1, %4 : $Int
  br bb4(%14 : $Builtin.Word, %17 : $Optional<Int>)

bb4(%19 : $Builtin.Word, %20 : $Optional<Int>):
  switch_enum %20 : $Optional<Int>, case #Optional.Some!enumelt.1: bb5, case #Optional.None!enumelt: bb6

bb5:
  // This could be a use like we generate for a loop with an induction
  // variable use like in:
  //  for i in 1..10 { a[i] = i }
  %9 = unchecked_enum_data %20 : $Optional<Int>, #Optional.Some!enumelt.1
  br bb1(%19 : $Builtin.Word)

bb6:
  %23 = tuple ()
  return %23 : $()
}

class Base {
  @inline(never) func inner()
  func middle()
  func outer()
}

class Derived : Base {
  override func inner()
  @inline(never) final override func middle()
}

class Final : Derived {
}

sil @_TFC3ccb4Base5innerfS0_FT_T_ : $@cc(method) @thin (@owned Base) -> ()
sil @_TFC3ccb4Base6middlefS0_FT_T_ : $@cc(method) @thin (@owned Base) -> ()

// CHECK-LABEL: sil @redundant_checked_cast_br
sil @redundant_checked_cast_br : $@cc(method) @thin (@owned Base) -> () {
bb0(%0 : $Base):
// CHECK: [[METHOD:%.*]] = class_method %0 : $Base, #Base.middle!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
  %1 = class_method %0 : $Base, #Base.middle!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
// CHECK: checked_cast_br [exact] %0 : $Base to $Base, [[SUCCESS:bb[0-9]+]], [[FAIL:bb[0-9]+]]
  checked_cast_br [exact] %0 : $Base to $Base, bb2, bb7

// CHECK: bb1
bb1:
  %3 = tuple ()
  return %3 : $()

bb2(%5 : $Base):
// CHECK: [[SUCCESS]]
  %7 = class_method %0 : $Base, #Base.inner!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
// CHECK-NOT: checked_cast_br
  checked_cast_br [exact] %0 : $Base to $Base, bb3, bb5
// CHECK: [[INNER:%.*]] = function_ref @_TFC3ccb4Base5innerfS0_FT_T_ : $@cc(method) @thin (@owned Base) -> ()
// CHECK: apply [[INNER]]
// CHECK: br bb1

bb3(%9 : $Base):
// CHECK: [[FAIL]]
// CHECK-NOT: function-ref
// CHECK: apply [[METHOD]]

  %10 = function_ref @_TFC3ccb4Base5innerfS0_FT_T_ : $@cc(method) @thin (@owned Base) -> ()
  %11 = apply %10(%0) : $@cc(method) @thin (@owned Base) -> ()
  br bb4

bb4:
  %13 = tuple ()
  br bb6(%13 : $())

bb5:
  %15 = apply %7(%0) : $@cc(method) @thin (@owned Base) -> ()
  br bb4

bb6(%17 : $()):
  br bb1

bb7:
  %19 = apply %1(%0) : $@cc(method) @thin (@owned Base) -> ()
  br bb1
}


// CHECK-LABEL: sil @not_redundant_checked_cast_br
sil @not_redundant_checked_cast_br : $@cc(method) @thin (@owned Base) -> () {
bb0(%0 : $Base):
// CHECK: [[METHOD:%.*]] = class_method %0 : $Base, #Base.middle!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
  %1 = class_method %0 : $Base, #Base.middle!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
// CHECK: checked_cast_br [exact] %0 : $Base to $Base, [[SUCCESS:bb[0-9]+]], [[FAIL:bb[0-9]+]]
  checked_cast_br [exact] %0 : $Base to $Base, bb2, bb7

// CHECK-LABEL: bb1
bb1:
  %3 = tuple ()
  return %3 : $()

bb2(%5 : $Base):
// CHECK: [[SUCCESS]]
// CHECK: [[METHOD2:%.*]] = class_method %0 : $Base, #Base.inner!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
  %7 = class_method %0 : $Base, #Base.inner!1 : Base -> () -> () , $@cc(method) @thin (@owned Base) -> ()
// CHECK: checked_cast_br [exact] %0 : $Base to $Derived
  checked_cast_br [exact] %0 : $Base to $Derived, bb3, bb5

bb3(%9 : $Derived):
  %10 = function_ref @_TFC3ccb4Base5innerfS0_FT_T_ : $@cc(method) @thin (@owned Base) -> ()
  %11 = apply %10(%0) : $@cc(method) @thin (@owned Base) -> ()
  br bb4

bb4:
  %13 = tuple ()
  br bb6(%13 : $())

bb5:
  %15 = apply %7(%0) : $@cc(method) @thin (@owned Base) -> ()
  br bb4

bb6(%17 : $()):
  br bb1

bb7:
  %19 = apply %1(%0) : $@cc(method) @thin (@owned Base) -> ()
  br bb1
}

/// CHECK_WITH_COMBINE-LABEL: sil @select_enum_dominates_switch_enum : $@thin (Int) -> Int {
/// The select_enum dominates the switch_enum and knows exactly which element will be
/// selected.  So this test ensures we can remove the switch_enum
/// CHECK_WITH_COMBINE-NOT: switch_enum
/// CHECK_WITH_COMBINE: return
sil @select_enum_dominates_switch_enum : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0           // users: %5, %9, %9
  %2 = integer_literal $Builtin.Int1, -1          // users: %7, %37
  %3 = struct_extract %0 : $Int, #Int.value       // users: %5, %13
  %4 = builtin_function_ref "cmp_sle_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %5
  %5 = apply %4(%1, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %7
  %6 = builtin_function_ref "xor_Int1" : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %7
  %7 = apply %6(%5, %2) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %8
  cond_fail %7 : $Builtin.Int1                    // id: %8
  br bb1(%1 : $Builtin.Word, %1 : $Builtin.Word)  // id: %9

bb1(%10 : $Builtin.Word, %11 : $Builtin.Word):    // Preds: bb0 bb6
  %12 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %13
  %13 = apply %12(%11, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %14
  cond_br %13, bb2, bb4                           // id: %14

bb2:                                              // Preds: bb1
  %15 = enum $Optional<Int>, #Optional.None!enumelt // user: %16
  br bb3(%11 : $Builtin.Word, %15 : $Optional<Int>) // id: %16

bb3(%17 : $Builtin.Word, %18 : $Optional<Int>):   // Preds: bb2 bb4
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  %19 = select_enum %18 : $Optional<Int>, case #Optional.Some!enumelt.1: %t, case #Optional.None!enumelt: %f : $Builtin.Int1
  cond_br %19, bb5, bb8                           // id: %20

bb4:                                              // Preds: bb1
  %21 = integer_literal $Builtin.Word, 1          // user: %24
  %22 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %24
  %23 = integer_literal $Builtin.Int1, 0          // user: %24
  %24 = apply %22(%11, %21, %23) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %25
  %25 = tuple_extract %24 : $(Builtin.Word, Builtin.Int1), 0 // user: %28
  %26 = struct $Int (%11 : $Builtin.Word)         // user: %27
  %27 = enum $Optional<Int>, #Optional.Some!enumelt.1, %26 : $Int // user: %28
  br bb3(%25 : $Builtin.Word, %27 : $Optional<Int>) // id: %28

bb5:                                              // Preds: bb3
  switch_enum %18 : $Optional<Int>, case #Optional.Some!enumelt.1: bb6, case #Optional.None!enumelt: bb7 // id: %29

bb6:                                              // Preds: bb5
  %30 = unchecked_enum_data %18 : $Optional<Int>, #Optional.Some!enumelt.1 // user: %31
  %31 = struct_extract %30 : $Int, #Int.value     // user: %34
  %32 = builtin_function_ref "smul_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %34
  %33 = integer_literal $Builtin.Int1, 0          // user: %34
  %34 = apply %32(%10, %31, %33) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %35
  %35 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 0 // user: %36
  br bb1(%35 : $Builtin.Word, %17 : $Builtin.Word) // id: %36

bb7:                                              // Preds: bb5
  cond_fail %2 : $Builtin.Int1                    // id: %37
  unreachable                                     // id: %38

bb8:                                              // Preds: bb3
  %39 = struct $Int (%10 : $Builtin.Word)         // user: %40
  return %39 : $Int                               // id: %40
}

/// CHECK_WITH_COMBINE-LABEL: sil @select_enum_dominates_switch_enum2 : $@thin (Int) -> Int {
/// The select_enum dominates the switch_enum and knows exactly which element will be
/// selected.
/// In this case, the switch is reached when the select_enum is false.  Given that the switch
/// only has 2 elements, we know that the other element must be selected.
/// CHECK_WITH_COMBINE-NOT: switch_enum
/// CHECK_WITH_COMBINE: return
sil @select_enum_dominates_switch_enum2 : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0           // users: %5, %9, %9
  %2 = integer_literal $Builtin.Int1, -1          // users: %7, %37
  %3 = struct_extract %0 : $Int, #Int.value       // users: %5, %13
  %4 = builtin_function_ref "cmp_sle_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %5
  %5 = apply %4(%1, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %7
  %6 = builtin_function_ref "xor_Int1" : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %7
  %7 = apply %6(%5, %2) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1 // user: %8
  cond_fail %7 : $Builtin.Int1                    // id: %8
  br bb1(%1 : $Builtin.Word, %1 : $Builtin.Word)  // id: %9

bb1(%10 : $Builtin.Word, %11 : $Builtin.Word):    // Preds: bb0 bb6
  %12 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %13
  %13 = apply %12(%11, %3) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1 // user: %14
  cond_br %13, bb2, bb4                           // id: %14

bb2:                                              // Preds: bb1
  %15 = enum $Optional<Int>, #Optional.None!enumelt // user: %16
  br bb3(%11 : $Builtin.Word, %15 : $Optional<Int>) // id: %16

bb3(%17 : $Builtin.Word, %18 : $Optional<Int>):   // Preds: bb2 bb4
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  %19 = select_enum %18 : $Optional<Int>, case #Optional.Some!enumelt.1: %t, case #Optional.None!enumelt: %f : $Builtin.Int1
  cond_br %19, bb8, bb5                           // id: %20

bb4:                                              // Preds: bb1
  %21 = integer_literal $Builtin.Word, 1          // user: %24
  %22 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %24
  %23 = integer_literal $Builtin.Int1, 0          // user: %24
  %24 = apply %22(%11, %21, %23) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %25
  %25 = tuple_extract %24 : $(Builtin.Word, Builtin.Int1), 0 // user: %28
  %26 = struct $Int (%11 : $Builtin.Word)         // user: %27
  %27 = enum $Optional<Int>, #Optional.Some!enumelt.1, %26 : $Int // user: %28
  br bb3(%25 : $Builtin.Word, %27 : $Optional<Int>) // id: %28

bb5:                                              // Preds: bb3
  switch_enum %18 : $Optional<Int>, case #Optional.Some!enumelt.1: bb6, case #Optional.None!enumelt: bb7 // id: %29

bb6:                                              // Preds: bb5
  %30 = unchecked_enum_data %18 : $Optional<Int>, #Optional.Some!enumelt.1 // user: %31
  %31 = struct_extract %30 : $Int, #Int.value     // user: %34
  %32 = builtin_function_ref "smul_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %34
  %33 = integer_literal $Builtin.Int1, 0          // user: %34
  %34 = apply %32(%10, %31, %33) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1) // user: %35
  %35 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 0 // user: %36
  br bb1(%35 : $Builtin.Word, %17 : $Builtin.Word) // id: %36

bb7:                                              // Preds: bb5
  cond_fail %2 : $Builtin.Int1                    // id: %37
  unreachable                                     // id: %38

bb8:                                              // Preds: bb3
  %39 = struct $Int (%10 : $Builtin.Word)         // user: %40
  return %39 : $Int                               // id: %40
}

// CHECK-LABEL: @jumpthread_switch_enum
// CHECK-NOT: switch_enum
// CHECK: return

sil @jumpthread_switch_enum : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %1 = integer_literal $Builtin.Word, 0
  %2 = integer_literal $Builtin.Word, 1
  %3 = struct_extract %0 : $Int, #Int.value
  %4 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %5 = integer_literal $Builtin.Int1, -1
  %6 = apply %4(%3, %2, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %7 = tuple_extract %6 : $(Builtin.Word, Builtin.Int1), 0
  %8 = tuple_extract %6 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %8 : $Builtin.Int1
  %10 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  %11 = apply %10(%2, %7) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %11, bb8(%1 : $Builtin.Word), bb2

bb2:
  %14 = integer_literal $Builtin.Word, 2
  %15 = struct $Int (%2 : $Builtin.Word)
  %16 = enum $Optional<Int>, #Optional.Some!enumelt.1, %15 : $Int
  br bb3(%1 : $Builtin.Word, %14 : $Builtin.Word, %16 : $Optional<Int>)

bb3(%18 : $Builtin.Word, %19 : $Builtin.Word, %20 : $Optional<Int>):
  switch_enum %20 : $Optional<Int>, case #Optional.Some!enumelt.1: bb4, case #Optional.None!enumelt: bb5

bb4:
  %22 = unchecked_enum_data %20 : $Optional<Int>, #Optional.Some!enumelt.1
  %23 = struct_extract %22 : $Int, #Int.value
  %24 = apply %4(%18, %23, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Word, Builtin.Int1), 0
  %26 = tuple_extract %24 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %26 : $Builtin.Int1
  %28 = struct $Int (%19 : $Builtin.Word)
  %29 = apply %10(%19, %7) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %29, bb6, bb7

bb5:
  cond_fail %5 : $Builtin.Int1
  unreachable

bb6:
  br bb8(%25 : $Builtin.Word)

bb7:
  %34 = apply %4(%19, %2, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %35 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 0
  %36 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %36 : $Builtin.Int1
  %38 = enum $Optional<Int>, #Optional.Some!enumelt.1, %28 : $Int
  br bb3(%25 : $Builtin.Word, %35 : $Builtin.Word, %38 : $Optional<Int>)

bb8(%40 : $Builtin.Word):
  %41 = struct $Int (%40 : $Builtin.Word)
  return %41 : $Int
}


/// Don't jumpthread blocks that contain objc method instructions. We don't
/// support building phis with objc method values.

class Bar {
  init()
  @objc func foo()
}


// CHECK-LABEL: @dont_jumpthread_switch_enum
// CHECK: class_method
// CHECK: switch_enum
// CHECK: return

sil @dont_jumpthread_switch_enum : $@thin (Int) -> Int {
bb0(%0 : $Int):
  %100 = alloc_ref $Bar
  %1 = integer_literal $Builtin.Word, 0
  %2 = integer_literal $Builtin.Word, 1
  %3 = struct_extract %0 : $Int, #Int.value
  %4 = builtin_function_ref "sadd_with_overflow_Word" : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %5 = integer_literal $Builtin.Int1, -1
  %6 = apply %4(%3, %2, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %7 = tuple_extract %6 : $(Builtin.Word, Builtin.Int1), 0
  %8 = tuple_extract %6 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %8 : $Builtin.Int1
  %10 = builtin_function_ref "cmp_eq_Word" : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  %11 = apply %10(%2, %7) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %11, bb8(%1 : $Builtin.Word), bb2

bb2:
  %14 = integer_literal $Builtin.Word, 2
  %15 = struct $Int (%2 : $Builtin.Word)
  %16 = enum $Optional<Int>, #Optional.Some!enumelt.1, %15 : $Int
  br bb3(%1 : $Builtin.Word, %14 : $Builtin.Word, %16 : $Optional<Int>)

bb3(%18 : $Builtin.Word, %19 : $Builtin.Word, %20 : $Optional<Int>):
  %101 = class_method [volatile] %100 : $Bar, #Bar.foo!1.foreign : Bar -> () -> () , $@cc(objc_method) @thin (Bar) -> ()
  switch_enum %20 : $Optional<Int>, case #Optional.Some!enumelt.1: bb4, case #Optional.None!enumelt: bb5

bb4:
  %102 = apply %101(%100) : $@cc(objc_method) @thin (Bar) -> ()
  %22 = unchecked_enum_data %20 : $Optional<Int>, #Optional.Some!enumelt.1
  %23 = struct_extract %22 : $Int, #Int.value
  %24 = apply %4(%18, %23, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Word, Builtin.Int1), 0
  %26 = tuple_extract %24 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %26 : $Builtin.Int1
  %28 = struct $Int (%19 : $Builtin.Word)
  %29 = apply %10(%19, %7) : $@thin (Builtin.Word, Builtin.Word) -> Builtin.Int1
  cond_br %29, bb6, bb7

bb5:
  cond_fail %5 : $Builtin.Int1
  unreachable

bb6:
  br bb8(%25 : $Builtin.Word)

bb7:
  %34 = apply %4(%19, %2, %5) : $@thin (Builtin.Word, Builtin.Word, Builtin.Int1) -> (Builtin.Word, Builtin.Int1)
  %35 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 0
  %36 = tuple_extract %34 : $(Builtin.Word, Builtin.Int1), 1
  cond_fail %36 : $Builtin.Int1
  %38 = enum $Optional<Int>, #Optional.Some!enumelt.1, %28 : $Int
  br bb3(%25 : $Builtin.Word, %35 : $Builtin.Word, %38 : $Optional<Int>)

bb8(%40 : $Builtin.Word):
  %41 = struct $Int (%40 : $Builtin.Word)
  return %41 : $Int
}

enum OneCase {
  case First
}

enum TwoCase {
  case First
  case Second
}

enum ThreeCase {
  case First
  case Second
  case Third
}

sil @unknown : $@thin () -> ()
sil @int1_user : $@thin (Builtin.Int1) -> ()

// CHECK-LABEL: sil @select_enum_case_canonicalization : $@thin (OneCase, TwoCase, TwoCase, ThreeCase, ThreeCase, ThreeCase) -> () {
// CHECK: bb0([[ONE_1:%.*]] : $OneCase, [[TWO_1:%.*]] : $TwoCase, [[TWO_2:%.*]] : $TwoCase, [[THREE_1:%.*]] : $ThreeCase, [[THREE_2:%.*]] : $ThreeCase, [[THREE_3:%.*]] : $ThreeCase):
// CHECK: [[TAG1:%.*]] = select_enum [[ONE_1]] : $OneCase, case #OneCase.First!enumelt: [[TRUE:%[0-9]+]]
// CHECK: [[TAG2:%.*]] = select_enum [[TWO_1]] : $TwoCase, case #TwoCase.First!enumelt: [[TRUE:%[0-9]+]]
// CHECK: [[TAG3:%.*]] = select_enum [[TWO_2]] : $TwoCase, case #TwoCase.First!enumelt: [[TRUE:%[0-9]+]]
// CHECK: [[TAG3_OLD:%.*]] = select_enum [[TWO_2]] : $TwoCase, case #TwoCase.Second!enumelt: [[TRUE:%[0-9]+]]
// CHECK: [[TAG4:%.*]] = select_enum [[THREE_1]] : $ThreeCase, case #ThreeCase.First!enumelt: [[TRUE:%[0-9]+]]
// CHECK: [[TAG5:%.*]] = select_enum [[THREE_2]] : $ThreeCase, case #ThreeCase.Second!enumelt: [[TRUE:%[0-9]+]]
// CHECK: [[TAG6:%.*]] = select_enum [[THREE_3]] : $ThreeCase, case #ThreeCase.Third!enumelt: [[TRUE:%[0-9]+]]
// CHECK: cond_br [[TAG1]], bb1, bb6
// CHECK: cond_br [[TAG2]], bb2, bb3
// CHECK: [[INT1_USER_FUN:%.*]] = function_ref @int1_user : $@thin (Builtin.Int1) -> ()
// CHECK: apply [[INT1_USER_FUN]]([[TAG3_OLD]])
// CHECK: cond_br [[TAG3]], bb5, bb4
// CHECK: cond_br [[TAG4]], bb7, bb8
// CHECK: cond_br [[TAG5]], bb9, bb10
// CHECK: cond_br [[TAG6]], bb11, bb12
sil @select_enum_case_canonicalization : $@thin (OneCase, TwoCase, TwoCase, ThreeCase, ThreeCase, ThreeCase) -> () {
bb0(%0 : $OneCase, %1 : $TwoCase, %2 : $TwoCase, %3 : $ThreeCase, %4 : $ThreeCase, %5 : $ThreeCase):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  %6 = select_enum %0 : $OneCase, case #OneCase.First!enumelt: %t, default %f : $Builtin.Int1
  %7 = select_enum %1 : $TwoCase, case #TwoCase.First!enumelt: %t, default %f : $Builtin.Int1
  %8 = select_enum %2 : $TwoCase, case #TwoCase.Second!enumelt: %t, default %f : $Builtin.Int1
  %9 = select_enum %3 : $ThreeCase, case #ThreeCase.First!enumelt: %t, default %f : $Builtin.Int1
  %10 = select_enum %4 : $ThreeCase, case #ThreeCase.Second!enumelt: %t, default %f : $Builtin.Int1
  %11 = select_enum %5 : $ThreeCase, case #ThreeCase.Third!enumelt: %t, default %f : $Builtin.Int1
  %12 = function_ref @unknown : $@thin () -> ()
  cond_br %6, bb1a, bb1b

bb1a:
  apply %12() : $@thin () -> ()
  cond_br %7, bb2a, bb3a

bb2a:
  apply %12() : $@thin () -> ()
  %13 = function_ref @int1_user : $@thin (Builtin.Int1) -> ()
  apply %13(%8) : $@thin (Builtin.Int1) -> ()
  cond_br %8, bb4a, bb5a

bb3a:
  apply %12() : $@thin () -> ()
  br exit

bb4a:
  apply %12() : $@thin () -> ()
  br exit

bb5a:
  apply %12() : $@thin () -> ()
  br exit

bb1b:
  apply %12() : $@thin () -> ()
  cond_br %9, bb2b, bb3b

bb2b:
  apply %12() : $@thin () -> ()
  cond_br %10, bb4b, bb5b

bb3b:
  apply %12() : $@thin () -> ()
  cond_br %11, bb6b, bb7b

bb4b:
  apply %12() : $@thin () -> ()
  br exit

bb5b:
  apply %12() : $@thin () -> ()
  br exit

bb6b:
  apply %12() : $@thin () -> ()
  br exit

bb7b:
  apply %12() : $@thin () -> ()
  br exit

exit:
  apply %12() : $@thin () -> ()
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil @select_enum_dominance_simplification : $@thin (Optional<Int>) -> () {
// CHECK: bb1:
// CHECK: integer_literal $Builtin.Int32, 0
// CHECK-NEXT: br bb3
// CHECK: bb2:
// CHECK: integer_literal $Builtin.Int32, 2
// CHECK-NEXT: br bb3
// CHECK: bb3:
// CHECK-NEXT: tuple
// CHECK-NEXT: return
sil @select_enum_dominance_simplification : $@thin (Optional<Int>) -> () {
bb0(%0 : $Optional<Int>):
  %t = integer_literal $Builtin.Int1, 1
  %f = integer_literal $Builtin.Int1, 0
  %1 = select_enum %0 : $Optional<Int>, case #Optional.Some!enumelt.1: %t, case #Optional.None!enumelt: %f : $Builtin.Int1
  cond_br %1, bb1, bb2

bb1:
  %2 = select_enum %0 : $Optional<Int>, case #Optional.Some!enumelt.1: %t, case #Optional.None!enumelt: %f : $Builtin.Int1
  cond_br %2, bb3, bb4

bb2:
  %3 = select_enum %0 : $Optional<Int>, case #Optional.Some!enumelt.1: %f, case #Optional.None!enumelt: %t : $Builtin.Int1
  cond_br %3, bb5, bb6

bb3:
  %4 = integer_literal $Builtin.Int32, 0
  br bb7

bb4:
  %5 = integer_literal $Builtin.Int32, 1
  br bb7

bb5:
  %6 = integer_literal $Builtin.Int32, 2
  br bb7

bb6:
  %7 = integer_literal $Builtin.Int32, 3
  br bb7

bb7:
  %9999 = tuple()
  return %9999 : $()
}
