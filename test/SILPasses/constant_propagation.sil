// RUN: %sil-opt %s -constant-propagation | FileCheck %s
import Builtin

// Compute an expression using a chain of arithmetic with overflow instructions: 2 * (2 + 3) - 3
sil @fold_sadd_with_overflow : $[thin] () -> Builtin.Int64 {
bb0:
 %1 = builtin_function_ref #Builtin.int_sadd_with_overflow_Int64 : $[thin] (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %2 = builtin_function_ref #Builtin.int_smul_with_overflow_Int64 : $[thin] (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %3 = builtin_function_ref #Builtin.int_ssub_with_overflow_Int64 : $[thin] (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %0 = integer_literal $Builtin.Int64, 2 
 %110 = integer_literal $Builtin.Int64, 3        
 %18 = apply %1(%0, %110) : $[thin] (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %19 = tuple_extract %18 : $(Builtin.Int64, Builtin.Int1), 0
 %20 = apply %2(%0, %19) : $[thin] (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %21 = tuple_extract %20 : $(Builtin.Int64, Builtin.Int1), 0
 %22 = apply %3(%21, %110) : $[thin] (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %23 = tuple_extract %22 : $(Builtin.Int64, Builtin.Int1), 0
 return %23 : $Builtin.Int64
// CHECK-LABEL: sil @fold_sadd_with_overflow
// CHECK-NOT: builtin_function_ref #Builtin.int_sadd_with_overflow_Int64
// CHECK-NOT: builtin_function_ref #Builtin.int_smul_with_overflow_Int64
// CHECK-NOT: builtin_function_ref #Builtin.int_ssub_with_overflow_Int64
// CHECK-NOT: integer_literal $Builtin.Int64, 2
// CHECK-NOT: integer_literal $Builtin.Int64, 3
// CHECK-NOT: integer_literal $Builtin.Int64, 0
// CHECK-NOT: apply
// CHECK: [[RES:%.*]] = integer_literal $Builtin.Int64, 7
// CHECK-NEXT: return [[RES:%.*]] : $Builtin.Int64
}

