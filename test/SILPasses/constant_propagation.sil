// RUN: %sil-opt %s -constant-propagation | FileCheck %s
import Builtin
import swift

// Compute an expression using a chain of arithmetic with overflow instructions: 2 * (2 + 3) - 3
sil @fold_arithmetic_with_overflow : $@thin () -> Builtin.Int64 {
bb0:
 %1 = builtin_function_ref #Builtin.int_sadd_with_overflow_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %2 = builtin_function_ref #Builtin.int_smul_with_overflow_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %3 = builtin_function_ref #Builtin.int_ssub_with_overflow_Int64 : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %0 = integer_literal $Builtin.Int64, 2 
 %110 = integer_literal $Builtin.Int64, 3        
 %18 = apply %1(%0, %110) : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %19 = tuple_extract %18 : $(Builtin.Int64, Builtin.Int1), 0
 %20 = apply %2(%0, %19) : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %21 = tuple_extract %20 : $(Builtin.Int64, Builtin.Int1), 0
 %22 = apply %3(%21, %110) : $@thin (Builtin.Int64, Builtin.Int64) -> (Builtin.Int64, Builtin.Int1)
 %23 = tuple_extract %22 : $(Builtin.Int64, Builtin.Int1), 0
 return %23 : $Builtin.Int64

// CHECK-LABEL: sil @fold_arithmetic_with_overflow
// CHECK-NOT: builtin_function_ref #Builtin.int_sadd_with_overflow_Int64
// CHECK-NOT: builtin_function_ref #Builtin.int_smul_with_overflow_Int64
// CHECK-NOT: builtin_function_ref #Builtin.int_ssub_with_overflow_Int64
// CHECK-NOT: integer_literal $Builtin.Int64, 2
// CHECK-NOT: integer_literal $Builtin.Int64, 3
// CHECK-NOT: integer_literal $Builtin.Int64, 0
// CHECK-NOT: apply
// CHECK: [[RES:%.*]] = integer_literal $Builtin.Int64, 7
// CHECK-NEXT: return [[RES:%.*]] : $Builtin.Int64
}

// Fold casts. (This test assumes that DCE does not run, otherwise the unreachable blocks will get removed.)
sil @fold_trunc : $@thin () -> Builtin.Int64 {
bb0:
 %0 = integer_literal $Builtin.Int128, 22
 %1 = builtin_function_ref #Builtin.trunc_Int128_Int64 : $@thin Builtin.Int128 -> Builtin.Int64
 %2 = apply %1(%0) : $@thin Builtin.Int128 -> Builtin.Int64
 br bb4(%2 : $Builtin.Int64)

bb1:
 %3 = integer_literal $Builtin.Int8, 23
 %4 = builtin_function_ref #Builtin.sext_Int8_Int64 : $@thin Builtin.Int8 -> Builtin.Int64
 %5 = apply %4(%3) : $@thin Builtin.Int8 -> Builtin.Int64
 br bb4(%5 : $Builtin.Int64)

bb2:
 %6 = integer_literal $Builtin.Int8, 24
 %7 = builtin_function_ref #Builtin.zext_Int8_Int64 : $@thin Builtin.Int8 -> Builtin.Int64
 %8 = apply %7(%6) : $@thin Builtin.Int8 -> Builtin.Int64
 br bb4(%8 : $Builtin.Int64)

bb4(%100 : $Builtin.Int64):
 return %100 : $Builtin.Int64
// CHECK-LABEL: sil @fold_trunc
// CHECK-NOT: integer_literal $Builtin.Int128, 22
// CHECK: integer_literal $Builtin.Int64, 22
// CHECK-NOT: integer_literal $Builtin.Int8, 23
// CHECK: integer_literal $Builtin.Int64, 23
// CHECK-NOT: integer_literal $Builtin.Int8, 24
// CHECK: integer_literal $Builtin.Int64, 24
}

sil @test_tuple_extract_folding : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 5
  %1 = integer_literal $Builtin.Int1, 0
  %2 = tuple (%0 : $Builtin.Int64, %1 : $Builtin.Int1)
  %3 = tuple_extract %2 : $(Builtin.Int64, Builtin.Int1), 0
  return %3 : $Builtin.Int64
// CHECK-LABEL: sil @test_tuple_extract_folding
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 5
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

sil @test_struct_extract_folding_first : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 2
  %1 = struct $Int64 (%0 : $Builtin.Int64)
  %2 = struct_extract %1 : $Int64, #value
  return %2 : $Builtin.Int64
// CHECK-LABEL: sil @test_struct_extract_folding_first
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 2
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

struct TwoValueStruct {
  var a : Builtin.Int64
  var b : Builtin.Int64
}

sil @test_struct_extract_folding_second : $@thin () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 2
  %1 = integer_literal $Builtin.Int64, 20
  %2 = struct $TwoValueStruct (%0 : $Builtin.Int64, %1 : $Builtin.Int64)
  %3 = struct_extract %2 : $TwoValueStruct, #b
  return %3 : $Builtin.Int64
// CHECK-LABEL: sil @test_struct_extract_folding_second
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int64, 20
// CHECK-NEXT: return %0 : $Builtin.Int64
// CHECK-NEXT: }
}

sil @test_struct_extract_folding_third : $() -> Bool {
bb0:
  %0 = integer_literal $Builtin.Int64, 200
  %1 = enum $Bool, #Bool.true!enumelt
  %2 = tuple (%0 : $Builtin.Int64, %1 : $Bool)
  %3 = tuple_extract %2 : $(Builtin.Int64, Bool), 1
  return %3 : $Bool

// CHECK-LABEL: sil @test_struct_extract_folding_third
// CHECK: bb0:
// CHECK-NEXT: %0 = enum $Bool, #Bool.true!enumelt
// CHECK-NEXT: return %0 : $Bool
// CHECK-NEXT: }
}

sil @testChainingCCP : $@thin () -> Builtin.Int1 {
bb0:
  %1 = builtin_function_ref #Builtin.trunc_Int64_Int1 : $@thin Builtin.Int64 -> Builtin.Int1
  %2 = integer_literal $Builtin.Int64, 0
  %3 = struct $Int64 (%2 : $Builtin.Int64)
  %4 = struct_extract %3 : $Int64, #value
  %5 = apply %1(%4) : $@thin Builtin.Int64 -> Builtin.Int1
  return %5 : $Builtin.Int1

// CHECK-LABEL: sil @testChainingCCP
// CHECK: bb0:
// CHECK-NEXT: %0 = integer_literal $Builtin.Int1, 0
// CHECK-NEXT: return %0 : $Builtin.Int1
// CHECK-NEXT: }
}

