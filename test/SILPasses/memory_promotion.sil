// RUN: %sil-opt %s -memory-promotion -verify | FileCheck %s

import Builtin
import swift


// CHECK-LABEL: sil @simple_reg_promotion
sil @simple_reg_promotion : $[thin] (a : Int64) -> Int64 {
bb0(%0 : $Int64):                         // CHECK: bb0(%0 : $Int64):
  %1 = alloc_box $Int64                   // CHECK: alloc_box
  store %0 to %1#1 : $*Int64
  %3 = alloc_box $Int64                   // CHECK: alloc_box
  %4 = load %1#1 : $*Int64
  // CHECK-NEXT: struct $Int64
  // CHECK-NEXT: struct_extract
  store %4 to %3#1 : $*Int64         // CHECK-NEXT: store
  %6 = load %3#1 : $*Int64
  // CHECK-NEXT: struct $Int64
  strong_release %3#0 : $Builtin.ObjectPointer   // CHECK-NEXT: release
  strong_release %1#0 : $Builtin.ObjectPointer
  return %6 : $Int64

  // CHECK: return {{.*}} : $Int64
}


// CHECK-LABEL: sil @tuple_reg_promotion
sil @tuple_reg_promotion : $[thin] (a : Int64) -> Int64 {
bb0(%0 : $Int64):                         // CHECK: bb0(%0 : $Int64):
  %1 = alloc_box $(Int64, Int64)                   // CHECK: alloc_box
  
  %a = tuple_element_addr %1#1 : $*(Int64, Int64), 0
  %b = tuple_element_addr %1#1 : $*(Int64, Int64), 1
  store %0 to %a : $*Int64
  // CHECK: store %0 to
 //CHECK-NEXT: struct_extract %0
  store %0 to %b : $*Int64
  // CHECK-NEXT: store %0 to 

  %c = load %1#1 : $*(Int64, Int64)
  %d = tuple_extract %c : $(Int64, Int64), 0

  strong_release %1#0 : $Builtin.ObjectPointer

  return %d : $Int64

  // Verify that promotion has promoted the tuple load away, and we know that
  // %0 is being returned through scalar instructions in SSA form.
  // CHECK: [[TUPLE:%[0-9]+]] = tuple ({{.*}} : $Int64, {{.*}} : $Int64)
  // CHECK: [[TUPLE_ELT:%[0-9]+]] = tuple_extract [[TUPLE]] : $(Int64, Int64), 0

  // CHECK: return [[TUPLE_ELT]] : $Int64
}


// CHECK-LABEL: sil @use_before_init
sil @use_before_init : $[thin] () -> Int64 {
bb0:
  %1 = alloc_box $Int64                   // expected-note {{variable defined here}}
  %4 = load %1#1 : $*Int64                // expected-error {{variable '<unknown>' used before being initialized}}
  strong_release %1#0 : $Builtin.ObjectPointer
  %9 = return %4 : $Int64
}


sil @takes_Int_byref : $[thin] (a : [byref] Int64) -> ()

// CHECK-LABEL: @byref_uninit
sil @byref_uninit : $[thin] () -> () {
bb0:
  %1 = alloc_box $Int64                                   // expected-note {{variable defined here}}

  %5 = function_ref @takes_Int_byref : $[thin] (a : [byref] Int64) -> ()
  %6 = apply %5(%1#1) : $[thin] (a : [byref] Int64) -> () // expected-error {{variable '<unknown>' passed by reference before being initialized}}
  
  %0 = tuple ()
  strong_release %1#0 : $Builtin.ObjectPointer
  return %0 : $()
}




// This function shouldn't produce any diagnostics.
//
// func used_by_byref(a : Int) -> (Int, Int) {
//  var t = a
//  takes_Int_byref(&a)
//  return (t,a)
//}
// CHECK-LABEL: sil @used_by_byref
sil @used_by_byref : $[thin] (a : Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  // This alloc_stack can't be removed since it is used by a byref call.
  // CHECK: %1 = alloc_box $Int64
  %1 = alloc_box $Int64
  %2 = store %0 to %1#1 : $*Int64
  
  // This load should be eliminated.
  %3 = load %1#1 : $*Int64
  %5 = function_ref @takes_Int_byref : $[thin] (a : [byref] Int64) -> ()
  %6 = apply %5(%1#1) : $[thin] (a : [byref] Int64) -> ()
  
  // This load is needed in case the callee modifies the allocation.
  // CHECK: [[RES:%[0-9]+]] = load
  %7 = load %1#1 : $*Int64
  
  // This should use the incoming argument to the function.
  // CHECK: tuple ({{.*}} : $Int64, {{.*}} : $Int64)
  %8 = tuple (%3 : $Int64, %7 : $Int64)
  strong_release %1#0 : $Builtin.ObjectPointer
  %11 = return %8 : $(Int64, Int64)
}


struct GenericStruct<T> {
  var a : T
  var b : Int
}

/// returns_generic_struct - This returns a struct by reference.
sil @returns_generic_struct : $[thin] () -> GenericStruct<Int64>

// There should be no error in this function.
// CHECK-LABEL: sil @call_struct_return_function
sil @call_struct_return_function : $[thin] () -> Int64 {
bb0:
  %1 = alloc_box $GenericStruct<Int64>
  %2 = function_ref @returns_generic_struct : $[thin] () -> GenericStruct<Int64>
  %3 = apply %2(%1#1) : $[thin] () -> GenericStruct<Int64>
  %4 = struct_element_addr %1#1 : $*GenericStruct<Int64>, #b
  %5 = load %4 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer
  return %5 : $Int64
}


// CHECK-LABEL: sil @tuple_elements1
sil @tuple_elements1 : $[thin] (a : Int64) -> () {
bb0(%0 : $Int64):
  %3 = alloc_box $(Int64, Int64)     // expected-note 2 {{variable defined here}}
  %4 = tuple_element_addr %3#1 : $*(Int64, Int64), 0
  %5 = tuple_element_addr %3#1 : $*(Int64, Int64), 1
  %14 = function_ref @takes_Int_byref : $[thin] (a : [byref] Int64) -> ()
  %15 = tuple_element_addr %3#1 : $*(Int64, Int64), 1
  %16 = apply %14(%15) : $[thin] (a : [byref] Int64) -> ()  // expected-error {{variable '<unknown>.1' passed by reference before being initialized}}

  strong_release %3#0 : $Builtin.ObjectPointer   // expected-error {{variable '<unknown>.0' destroyed without being fully initialized on all paths}}
  %99 = tuple ()
  return %99 : $()
}

// CHECK-LABEL: sil @tuple_elements2
sil @tuple_elements2 : $[thin] (a : Int64) -> (Int64, Int64) {
bb0(%0 : $Int64):
  %3 = alloc_box $(Int64, Int64)     // expected-note {{variable defined here}}
  %18 = tuple_element_addr %3#1 : $*(Int64, Int64), 0
  store %0 to %18 : $*Int64
  %20 = load %3#1 : $*(Int64, Int64) // expected-error {{variable '<unknown>.1' used before being initialized}}
  %21 = tuple_extract %20 : $(Int64, Int64), 0
  %22 = tuple_extract %20 : $(Int64, Int64), 1
  %23 = tuple (%21 : $Int64, %22 : $Int64)
  strong_release %3#0 : $Builtin.ObjectPointer
  return %23 : $(Int64, Int64)
}

struct XYStruct { var x, y : Int }


// CHECK-LABEL: sil @copy_addr1
sil @copy_addr1 : $[thin] <T> (v : T) -> T {
bb0(%0 : $*T, %1 : $*T):
  %4 = alloc_box $T
  copy_addr [take] %1 to [initialization] %4#1 : $*T
  copy_addr %4#1 to [initialization] %0 : $*T
  strong_release %4#0 : $Builtin.ObjectPointer
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @copy_addr2
sil @copy_addr2 : $[thin] <T> (v : T) -> T {
bb0(%0 : $*T, %1 : $*T):
  %4 = alloc_box $T         // expected-note {{variable defined here}}
  copy_addr %4#1 to [initialization] %0 : $*T   // expected-error {{variable '<unknown>' used before being initialized}}
  strong_release %4#0 : $Builtin.ObjectPointer
  %9 = tuple ()
  return %9 : $()
}


sil @takes_closure : $[thin] (x : () -> ()) -> ()
sil @closure0 : $[thin] ((), (Builtin.ObjectPointer, [byref] Int64)) -> ()

// CHECK-LABEL: sil @closure_test
sil @closure_test : $[thin] () -> () {
bb0:
  %0 = alloc_box $Int64    // expected-note {{variable defined here}}

  %5 = function_ref @takes_closure : $[thin] (x : () -> ()) -> ()
  %6 = function_ref @closure0 : $[thin] ((), (Builtin.ObjectPointer, [byref] Int64)) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  %8 = partial_apply %6(%0#0, %0#1) : $[thin] ((), (Builtin.ObjectPointer, [byref] Int64)) -> ()  // expected-error {{variable '<unknown>' captured by a closure before being initialized}}
  %9 = apply %5(%8) : $[thin] (x : () -> ()) -> ()
  strong_release %0#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil @closure_test2
sil @closure_test2 : $[thin] (a : Int64) -> Int64 {
bb0(%1 : $Int64):
  %0 = alloc_box $Int64
  store %1 to %0#1 : $*Int64  // CHECK: store

  %5 = function_ref @takes_closure : $[thin] (x : () -> ()) -> ()
  %6 = function_ref @closure0 : $[thin] ((), (Builtin.ObjectPointer, [byref] Int64)) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  %8 = partial_apply %6(%0#0, %0#1) : $[thin] ((), (Builtin.ObjectPointer, [byref] Int64)) -> ()
  %9 = apply %5(%8) : $[thin] (x : () -> ()) -> ()
  strong_release %0#0 : $Builtin.ObjectPointer

  store %1 to %0#1 : $*Int64 // CHECK: store

  // In an escape region, we should not promote loads.
  %r = load %0#1 : $*Int64 // CHECK: load
  return %r : $Int64
}



class SomeClass {}

sil @getSomeClass : $[thin] ((), SomeClass.metatype) -> SomeClass


// CHECK-LABEL: sil @assign_test_trivial
sil @assign_test_trivial : $[thin] (a : Int64) -> Int64 {
bb0(%0 : $Int64):
  %1 = alloc_box $Int64

  // These assigns are a mix of init + store forms, but because Int is trivial,
  // they all turn into stores.
  assign %0 to %1#1 : $*Int64                      // CHECK: store %0 to %1#1
  assign %0 to %1#1 : $*Int64                      // CHECK: store %0 to %1#1
  // CHECK-NEXT: struct_extract
  assign %0 to %1#1 : $*Int64                      // CHECK: store %0 to %1#1
  // CHECK-NEXT: struct $Int64

  %2 = load %1#1 : $*Int64
  strong_release %1#0 : $Builtin.ObjectPointer            // CHECK-NEXT: strong_release %1#0

  // Verify that the load got forwarded from an assign.
  return %2 : $Int64                        // CHECK: return {{.*}} : $Int64
}

// CHECK-LABEL: sil @assign_test_nontrivial
sil @assign_test_nontrivial : $[thin] () -> () {
bb0:
  // Assignments of nontrivial types.  The first becomes an initialize (i.e.,
  // lone store), the second becomes an assignment (retain/release dance).

  %c = alloc_box $SomeClass
  %f = function_ref @getSomeClass : $[thin] ((), SomeClass.metatype) -> SomeClass
  %3 = metatype $SomeClass.metatype

  %4 = apply %f(%3) : $[thin] ((), SomeClass.metatype) -> SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  assign %4 to %c#1 : $*SomeClass
  // CHECK-NEXT: store [[C1]]

  %8 = apply %f(%3) : $[thin] ((), SomeClass.metatype) -> SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  assign %8 to %c#1 : $*SomeClass
  // CHECK-NEXT: store [[C2]]
  // CHECK-NEXT: release [[C1]]

  strong_release %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}


// CHECK-LABEL: sil @assign_test_addressonly
sil @assign_test_addressonly : $[thin] <T> (v : T) -> T {
bb0(%0 : $*T, %1 : $*T):
  %2 = alloc_box $T
  // CHECK: alloc_box

  // This should become an initialization of %4
  copy_addr %1 to %2#1 : $*T
  // CHECK-NEXT: copy_addr %1 to [initialization] %2#1 : $*T

  // This should stay an assignment of %4
  copy_addr [take] %1 to %2#1 : $*T
  // CHECK-NEXT: copy_addr [take] %1 to %2#1 : $*T
  
  // This is a load, and shouldn't be changed.
  copy_addr %2#1 to [initialization] %0 : $*T
  // CHECK-NEXT: copy_addr %2#1 to [initialization] %0 : $*T

  strong_release %2#0 : $Builtin.ObjectPointer
  // CHECK-NEXT: strong_release %2#0
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @assign_test_weak
sil @assign_test_weak : $[thin]() -> () {
bb0:
  // Assignments of weak pointer.  The first becomes an initialize, and the
  // second becomes an assignment.

  %c = alloc_box $[weak] SomeClass
  %f = function_ref @getSomeClass : $[thin] ((), SomeClass.metatype) -> SomeClass
  %3 = metatype $SomeClass.metatype

  %4 = apply %f(%3) : $[thin] ((), SomeClass.metatype) -> SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  // THis should become an initialization.
  store_weak %4 to %c#1 : $*[weak] SomeClass
  // CHECK-NEXT: store_weak [[C1]] to [initialization] %0#1

  strong_release %4 : $SomeClass
  // CHECK-NEXT: release [[C1]]

  %8 = apply %f(%3) : $[thin] ((), SomeClass.metatype) -> SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  store_weak %8 to %c#1 : $*[weak] SomeClass
  // CHECK-NEXT: store_weak [[C2]] to %0#1

  strong_release %8 : $SomeClass
  // CHECK-NEXT: release [[C2]]

  strong_release %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil @assign_test_unowned
sil @assign_test_unowned : $[thin]() -> () {
bb0:
  // Assignments of unowned pointer.  The first becomes an initialize, and the
  // second becomes an assignment.

  %c = alloc_box $[unowned] SomeClass
  // CHECK: [[BOX:%[0-9]+]] = alloc_box
  %f = function_ref @getSomeClass : $[thin] ((), SomeClass.metatype) -> SomeClass
  %3 = metatype $SomeClass.metatype

  %4 = apply %f(%3) : $[thin] ((), SomeClass.metatype) -> SomeClass
  // CHECK: [[C1:%[0-9]+]] = apply

  // This should become an initialization.
  %5 = ref_to_unowned %4 : $SomeClass to $[unowned] SomeClass
  unowned_retain %5 : $[unowned] SomeClass
  assign %5 to %c#1 : $*[unowned] SomeClass
  strong_release %4 : $SomeClass
  // CHECK-NEXT: [[C1u:%[0-9]+]] = ref_to_unowned [[C1]]
  // CHECK-NEXT: unowned_retain [[C1u]]
  // CHECK-NEXT: store [[C1u]] to [[BOX]]#1
  // CHECK-NEXT: strong_release [[C1]]

  %8 = apply %f(%3) : $[thin] ((), SomeClass.metatype) -> SomeClass
  // CHECK-NEXT: [[C2:%[0-9]+]] = apply

  %9 = ref_to_unowned %8 : $SomeClass to $[unowned] SomeClass
  unowned_retain %9 : $[unowned] SomeClass
  assign %9 to %c#1 : $*[unowned] SomeClass
  strong_release %8 : $SomeClass
  // CHECK-NEXT: [[C2u:%[0-9]+]] = ref_to_unowned [[C2]]
  // CHECK-NEXT: unowned_retain [[C2u]]
  // CHECK-NEXT: store [[C2u]] to [[BOX]]#1
  // CHECK-NEXT: unowned_release [[C1u]]
  // CHECK-NEXT: strong_release [[C2]]

  strong_release %c#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}



struct ContainsObjectPointer {
  var x : Int 
  var y : Builtin.ObjectPointer
}

sil @test_struct : $[thin] (value : [byref] ContainsObjectPointer) -> () {
bb0(%0 : $*ContainsObjectPointer):
  %b = alloc_box $ContainsObjectPointer
  %1 = load %0 : $*ContainsObjectPointer
  assign %1 to %b#1 : $*ContainsObjectPointer
  
  strong_release %b#0 : $Builtin.ObjectPointer
  %x = tuple ()
  return %x : $()
}

// CHECK-LABEL: sil @non_box_assign_trivial
// CHECK-NOT: load
// CHECK: store
// CHECK: return
sil @non_box_assign_trivial : $[thin] (lhs : [byref] Bool, rhs : Bool) -> () {
bb0(%0 : $*Bool, %1 : $Bool):
  assign %1 to %0 : $*Bool
  %9 = tuple ()
  return %9 : $()
}

// CHECK-LABEL: sil @non_box_assign
// CHECK: load
// CHECK: store
// CHECK: return
sil @non_box_assign : $[thin] (lhs : [byref] SomeClass, rhs : SomeClass) -> () {
bb0(%0 : $*SomeClass, %1 : $SomeClass):
  assign %1 to %0 : $*SomeClass
  %9 = tuple ()
  return %9 : $()
}

var int_global : Int


// CHECK-LABEL: sil @test_tlc
// CHECK-NOT: mark_uninitialized
// CHECK: return
sil @test_tlc : $() -> () {
  %0 = global_addr #int_global : $*Int64
  %1 = mark_uninitialized %0 : $*Int64

  %9 = tuple ()
  return %9 : $()
}
