sil_stage raw // CHECK: sil_stage raw

import Builtin
import swift
import Foundation

// Type references

// Some cyclic type references between SIL function bodies.
class Class1 { var a : Class2 }
class Class2 { var b : Class1 }

// Instructions

// CHECK-LABEL: sil deserialized @test1 : $@thin () -> ()
sil @test1 : $@thin () -> () {
bb0:                                  // CHECK: bb0:
  %0 = tuple ()                       // CHECK:   %0 = tuple ()
  br bb1                              // CHECK:   br bb1
bb1:
  %b = alloc_box $Int64
  %c = integer_literal $Builtin.Int64, 1
  // CHECK: alloc_array $String, %{{.*}} : $Builtin.Int64
  %d = alloc_array $String, %c : $Builtin.Int64
  return %0 : $()                     // CHECK:   return %0 : $()
}

// Forward referenced values.
// CHECK-LABEL: sil deserialized @test2 : $@thin (x: Int64) -> ()
sil @test2 : $@thin (x: Int64) -> () {
  // CHECK: bb1:
  // CHECK: %2 = tuple ()
  // CHECK: br bb2
  // CHECK: bb2:
  // FIXME: should be %2
  // CHECK: return %{{.*}} : $()
bb0(%0 : $Int64):
  br bb2
bb1:
  // Forward reference MRVs.
  store %0 to %6#1 : $*Int64
  strong_release %6#0 : $Builtin.ObjectPointer

  return %5 : $()
bb2:
  %5 = tuple ()
  %6 = alloc_box $Int64
  br bb1
}

// CHECK-LABEL: @named_tuple : $@thin () -> (x: Builtin.Int64, Builtin.Int64)
sil @named_tuple : $@thin () -> (x: Builtin.Int64, Builtin.Int64) {
  %0 = integer_literal $Builtin.Int64, 42
  // CHECK: integer_literal $Builtin.Int64, 42
  %9 = tuple $(x: Builtin.Int64, Builtin.Int64) (%0, %0)
  %10 = return %9 : $(x: Builtin.Int64, Builtin.Int64)
}

sil @return_int : $@thin (a: Int64) -> Int64 { // CHECK-LABEL: $@thin (a: Int64) -> Int64 {
bb0(%0 : $Int64):                          // CHECK: bb0(%0 : $Int64):
  // CHECK: alloc_stack $Int64
  // CHECK: store
  %1 = alloc_stack $Int64
  store %0 to %1#1 : $*Int64
  %3 = load %1#1 : $*Int64
  dealloc_stack %1#0 : $*@local_storage Int64
  return %3 : $Int64                       // CHECK: return {{.*}} : $Int64
}

// CHECK-LABEL: @call_fn_pointer : $@thin (a: () -> Int64) -> Int64 {
sil @call_fn_pointer : $@thin (a : () -> Int64) -> Int64 {
bb0(%0 : $() -> Int64):
  %1 = alloc_stack $() -> Int64
  store %0 to %1#1 : $*() -> Int64
  %3 = load %1#1 : $*() -> Int64
  strong_retain %3 : $() -> Int64
  // CHECK: strong_retain %{{.*}} : $() -> Int64
  %5 = apply %3() : $() -> Int64
  // CHECK: apply %{{.*}}() : $() -> Int64
  %6 = load %1#1 : $*() -> Int64
  strong_release %3 : $() -> Int64
  // CHECK: strong_release {{.*}} : $() -> Int64
  dealloc_stack %1#0 : $*@local_storage () -> Int64
  return %5 : $Int64                       // CHECK: return %{{.*}} : $Int64
}

sil @return_constant : $@thin () -> Int64 {  // CHECK-LABEL: @return_constant
bb0:                                         // CHECK: bb0:
  // CHECK: function_ref @_TSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64
  %1 = function_ref @_TSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64

  // CHECK: metatype $Int64.metatype
  %2 = metatype $Int64.metatype

  // CHECK: integer_literal $Builtin.Int64, 1
  %3 = integer_literal $Builtin.Int64, 1

  // CHECK: apply
  %4 = apply %1(%3, %2) : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64
  // CHECK: return
  %5 = return %4 : $Int64
}

sil @_TSi25convertFromIntegerLiteralfMSiFT3valBi64__Si : $@thin ((val: Builtin.Int64), Int64.metatype) -> Int64

// Parse SIL generated from the following swift program:
// def x(a : Bool) -> Int { if a { return 4 } else {return 5} }
sil @_TSb13getLogicValuefRSbFT_Bi1_ : $@cc(method) @thin ((), @inout Bool) -> Builtin.Int1
sil @_TSi33_convertFromBuiltinIntegerLiteralfMSiFT3valBi128__Si : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64



protocol P {
  def doIt()
}

// CHECK-LABEL: @existentials : $@thin (n: P) -> () {
sil @existentials : $@thin (n : P) -> () {
bb0(%0 : $*P):
  %1 = project_existential %0 : $*P to $*@sil_self P // CHECK: project_existential %0

  // CHECK: protocol_method {{.*}} : $*P, #P.doIt!1
  %2 = protocol_method %0 : $*P, #P.doIt!1 : $@cc(method) ((), @inout @sil_self P) -> ()
  // CHECK: apply
  %3 = apply %2(%1) : $@cc(method) ((), @inout @sil_self P) -> ()
  %4 = tuple ()                       // CHECK: tuple ()
  %5 = destroy_addr %0 : $*P          // CHECK: destroy_addr %0 : $*P
  %6 = return %4 : $()                // CHECK: return
}


class C {
  def doIt() {}
}

class D : C {
  def doIt() {
    super.doIt()
  }
}

// CHECK-LABEL: @classes : $@thin () -> () {
sil @classes : $@thin () -> () {
bb0:
  // CHECK: %0 = alloc_ref $C
  %C = alloc_ref $C
  // CHECK: ref_to_object_pointer %0 : $C to $Builtin.ObjectPointer
  %1 = ref_to_object_pointer %C : $C to $Builtin.ObjectPointer
  // CHECK: ref_to_object_pointer %0 : $C to $Builtin.ObjCPointer
  %O = ref_to_object_pointer %C : $C to $Builtin.ObjCPointer

  // CHECK: class_method {{.*}} : $C, #C.doIt!1
  %2 = class_method %C : $C, #C.doIt!1 : $@cc(method) @thin ((), C) -> ()

  // CHECK: alloc_ref $D
  %D = alloc_ref $D

  // CHECK: upcast {{.*}} : $D to $C
  %a = upcast %D : $D to $C

  // CHECK: unconditional_checked_cast downcast {{.*}} : $C to $D
  %5 = unconditional_checked_cast downcast %C : $C to $D
  %6 = tuple ()
  %7 = return %6 : $()
}

// Generated from:
// def archetype_member_ref<T:Runcible>(x:T) {
//   x.free_method()
//   var u = x.associated_method()
//   T.static_method()
// }

protocol Runcible {
  typealias U
  var free:Int
  var associated:U

  def free_method() -> Int
  def associated_method() -> U.metatype
  static def static_method()
}

//sil @_T4arch20archetype_member_refUS_8Runcible___FT1xQ__T_ : $@thin <T : Runcible> (x : T) -> () {
//bb0(%0 : $*T):
  //%1 = archetype_method $*T, #Runcible.free_method!1 : $@cc(method) ((), @inout T) -> Int64
  //%2 = apply %1(%0) : $@cc(method) ((), @inout T) -> Int64
  //%3 = alloc_stack $T.U.metatype
  //%4 = archetype_method $*T, #Runcible.associated_method!1 : $@cc(method) ((), @inout T) -> T.U.metatype
  //%5 = apply %4(%0) : $@cc(method) ((), @inout T) -> T.U.metatype
  //%6 = store %5 to %3#1 : $*T.U.metatype
  //%7 = metatype $T.metatype
  //%8 = archetype_method [volatile] $*T, #Runcible.static_method!1 : $((), T.metatype) -> ()
  //%9 = apply %8(%7) : $((), T.metatype) -> ()
  //%10 = dealloc_stack %3#0 : $*@local_storage T.U.metatype
  //%11 = tuple ()
  //%12 = destroy_addr %0 : $*T
  //%13 = return %11 : $()
//}

protocol Bendable { }

// CHECK-LABEL: $@thin (x: protocol<Bendable, Runcible>) -> Runcible
sil @_T4todo18erasure_from_protoFT1xPS_8RuncibleS_8Bendable__PS0__ : $@thin (x: protocol<Bendable, Runcible>) -> Runcible {
bb0(%0 : $*Runcible, %1 : $*protocol<Bendable, Runcible>):
  // CHECK: alloc_box
  %2 = alloc_box $protocol<Bendable, Runcible>
  // CHECK: copy_addr [take] {{.*}} to [initialization] {{.*}} : $*protocol<Bendable, Runcible>
  %3 = copy_addr [take] %1 to [initialization] %2#1 : $*protocol<Bendable, Runcible>
  // CHECK: alloc_stack
  %4 = alloc_stack $protocol<Bendable, Runcible>
  // CHECK: copy_addr {{.*}} to [initialization] {{.*}} : $*protocol<Bendable, Runcible>
  %5 = copy_addr %2#1 to [initialization] %4#1 : $*protocol<Bendable, Runcible>
  // CHECK: upcast_existential [take] {{.*}} : $*protocol<Bendable, Runcible> to {{.*}} : $*Runcible
  %6 = upcast_existential [take] %4#1 : $*protocol<Bendable, Runcible> to %0 : $*Runcible
  %7 = tuple ()
  // CHECK: destroy_addr
  %8 = destroy_addr %4#1 : $*protocol<Bendable, Runcible>
  // CHECK: dealloc_stack
  %9 = dealloc_stack %4#0 : $*@local_storage protocol<Bendable, Runcible>
  %10 = strong_release %2#0 : $Builtin.ObjectPointer
  // CHECK: return
  %11 = return %7 : $()
}

@class_protocol protocol ClassBound {
  def classBoundMethod()
}

// CHECK-LABEL: @_T4todo18class_bound_methodFT1xPS_10ClassBound__T_ : $@thin (x: ClassBound) -> ()
sil @_T4todo18class_bound_methodFT1xPS_10ClassBound__T_ : $@thin (x: ClassBound) -> () {
bb0(%0 : $ClassBound):
  %1 = alloc_box $ClassBound
  %2 = store %0 to %1#1 : $*ClassBound
  %3 = load %1#1 : $*ClassBound
  %4 = strong_retain %3 : $ClassBound              // CHECK: strong_retain
  // CHECK: project_existential_ref {{%.*}} : $ClassBound to $@sil_self ClassBound
  %5 = project_existential_ref %3 : $ClassBound to $@sil_self ClassBound
  // CHECK: protocol_method
  %6 = protocol_method %3 : $ClassBound, #ClassBound.classBoundMethod!1 : $@cc(method) @thin ((), @sil_self ClassBound) -> ()
  %7 = apply %6(%5) : $@cc(method) @thin ((), @sil_self ClassBound) -> ()
  %8 = tuple ()
  %9 = strong_release %1#0 : $Builtin.ObjectPointer
  %10 = return %8 : $()
}

struct Val {
}

//sil @_TV4todo3ValCfMS0_FT_S0_ : $@thin ((), Val.metatype) -> Val {
//bb0(%0 : $Val.metatype):
  //%1 = alloc_stack $Val
  //%2 = initialize_var [no_default_construct] %1#1 : $*Val
  //%3 = load %1#1 : $*Val
  //%4 = return %3 : $Val
//}

class Ref {
}
struct Aleph {
  var a:Ref
  var b:Val
}

// CHECK-LABEL: @_TV6struct5AlephCfMS0_FT1aCS_3Ref1bVS_3Val_S0_ : $@thin ((a: Ref, b: Val), Aleph.metatype) -> Aleph
sil @_TV6struct5AlephCfMS0_FT1aCS_3Ref1bVS_3Val_S0_ : $@thin ((a: Ref, b: Val), Aleph.metatype) -> Aleph {
bb0(%0 : $Ref, %1 : $Val, %2 : $Aleph.metatype):
  // CHECK: struct $Aleph ({{%.*}} : $Ref, {{%.*}} : $Val)
  %3 = struct $Aleph (%0 : $Ref, %1 : $Val)
  %4 = return %3 : $Aleph  // CHECK: return
}

// CHECK-LABEL: @_TV6struct5AlephCfMS0_FT_S0_ : $@thin ((), Aleph.metatype) -> Aleph
sil @_TV6struct5AlephCfMS0_FT_S0_ : $@thin ((), Aleph.metatype) -> Aleph {
bb0(%0 : $Aleph.metatype):
  %1 = tuple ()
  %2 = alloc_box $Aleph       // CHECK: alloc_box
  // CHECK: initialize_var [no_default_construct]
  %3 = initialize_var [no_default_construct] %2#1 : $*Aleph
  %4 = builtin_zero $Ref      // CHECK: builtin_zero $Ref
  // CHECK: struct_element_addr {{.*}} : $*Aleph, #a
  %5 = struct_element_addr %2#1 : $*Aleph, #a
  %6 = load %5 : $*Ref
  %7 = store %4 to %5 : $*Ref
  %8 = strong_release %6 : $Ref
  %14 = load %2#1 : $*Aleph
  // CHECK: struct_extract {{%.*}} : $Aleph, #a
  %15 = struct_extract %14 : $Aleph, #a
  %16 = strong_retain %15 : $Ref
  %17 = strong_release %2#0 : $Builtin.ObjectPointer
  %18 = return %14 : $Aleph
}

enum Beth {
  case EmptyCase
  case DataCase(Int)
}

// CHECK-LABEL: @test_union_empty_case : $@thin () -> Beth {
sil @test_union_empty_case : $@thin () -> Beth {
bb0:
  // CHECK: %0 = enum $Beth, #Beth.EmptyCase!enumelt
  %0 = enum $Beth, #Beth.EmptyCase!enumelt
  return %0 : $Beth
}

// CHECK-LABEL: @test_union_data_case : $@thin Int64 -> Beth {
sil @test_union_data_case : $@thin Int64 -> Beth {
bb0(%0 : $Int):
  // CHECK: %1 = enum $Beth, #Beth.DataCase!enumelt.1, %0 : $Int64
  %1 = enum $Beth, #Beth.DataCase!enumelt.1, %0 : $Int64
  return %1 : $Beth
}

protocol Q {}

enum Gimel {
  case EmptyCase
  case DataCase(Q)
}

// CHECK-LABEL: @test_union_addr_empty_case : $@thin () -> Gimel {
sil @test_union_addr_empty_case : $@thin () -> Gimel {
bb0(%0 : $*Gimel):
  // CHECK: inject_enum_addr {{%.*}} : $*Gimel, #Gimel.EmptyCase!enumelt
  inject_enum_addr %0 : $*Gimel, #Gimel.EmptyCase!enumelt
  %t = tuple ()
  return %t : $()
}

// CHECK-LABEL: @test_union_addr_data_case : $@thin Q -> Gimel {
sil @test_union_addr_data_case : $@thin (Q) -> Gimel {
bb0(%0 : $*Gimel, %1 : $*Q):
  // CHECK: {{%.*}} = enum_data_addr {{%.*}} : $*Gimel, #Gimel.DataCase!enumelt.1
  %p = enum_data_addr %0 : $*Gimel, #Gimel.DataCase!enumelt.1
  copy_addr [take] %1 to [initialization] %p : $*Q
  inject_enum_addr %0 : $*Gimel, #Gimel.DataCase!enumelt.1
  %t = tuple ()
  return %t : $()
}

sil @_T5tuple5floatFT1xSf_T_ : $@thin (x : Float32) -> ()
sil @_T5tuple5tupleFT_TSiSf_ : $@thin () -> (Int64, Float32)

// CHECK-LABEL: @_T5tuple13tuple_elementFT1xTSiSf__T_ : $@thin (x: (Int64, Float32)) -> ()
sil @_T5tuple13tuple_elementFT1xTSiSf__T_ : $@thin (x: (Int64, Float32)) -> () {
bb0(%0 : $Int64, %1 : $Float32):
  %2 = alloc_box $(Int64, Float32)
  %3 = tuple (%0 : $Int64, %1 : $Float32)
  %4 = store %3 to %2#1 : $*(Int64, Float32)
  // CHECK: tuple_element_addr {{%.*}}#{{.*}} : $*(Int64, Float32), 0
  %6 = tuple_element_addr %2#1 : $*(Int64, Float32), 0
  %7 = load %6 : $*Int64
  // CHECK: tuple_element_addr {{%.*}}#{{.*}} : $*(Int64, Float32), 1
  %10 = tuple_element_addr %2#1 : $*(Int64, Float32), 1
  %11 = load %10 : $*Float32
  // CHECK: function_ref
  %14 = function_ref @_T5tuple5tupleFT_TSiSf_ : $@thin () -> (Int64, Float32)
  // CHECK: apply
  %15 = apply %14() : $@thin () -> (Int64, Float32)
  // CHECK: function_ref
  %19 = function_ref @_T5tuple5floatFT1xSf_T_ : $@thin (x : Float32) -> ()
  // CHECK: tuple_extract {{%.*}} : $(Int64, Float32), 1
  %17 = tuple_extract %15 : $(Int64, Float32), 1
  // CHECK: apply
  %24 = apply %19(%17) : $@thin (x : Float32) -> ()
  %25 = tuple ()
  %26 = strong_release %2#0 : $Builtin.ObjectPointer
  %27 = return %25 : $()
}

class M {
  var member : Int
}

// CHECK-LABEL: @_TC3ref1C3foofS0_FT1xSi_T_ : $@cc(method) @thin ((x: Int64), M) -> ()
sil @_TC3ref1C3foofS0_FT1xSi_T_ : $@cc(method) @thin ((x: Int64), M) -> () {
bb0(%0 : $Int64, %1 : $M):
  %2 = alloc_box $Int64
  %3 = store %0 to %2#1 : $*Int64
  %4 = alloc_box $M
  %5 = store %1 to %4#1 : $*M
  %6 = load %2#1 : $*Int64
  %7 = load %4#1 : $*M
  %8 = strong_retain %7 : $M
  // CHECK: ref_element_addr {{%.*}} : $M, #member
  %9 = ref_element_addr %7 : $M, #member
  %10 = store %6 to %9 : $*Int64
  %11 = strong_release %7 : $M
  %12 = tuple ()
  %13 = strong_release %4#0 : $Builtin.ObjectPointer
  %14 = strong_release %2#0 : $Builtin.ObjectPointer
  %15 = return %12 : $()
}

class B { }
class E : B { }

// CHECK-LABEL: @_T4null3isaFT1bCS_1B_Sb : $@thin (b: B) -> Builtin.Int1
sil @_T4null3isaFT1bCS_1B_Sb : $@thin (b: B) -> Builtin.Int1 {
bb0(%0 : $B):
  %1 = alloc_box $B
  %2 = store %0 to %1#1 : $*B
  %3 = load %1#1 : $*B
  %4 = strong_retain %3 : $B
  checked_cast_br downcast %3 : $B to $E, yes, no     // CHECK: checked_cast_br downcast
yes(%5 : $E):
  %y = integer_literal $Builtin.Int1, 1
  br isa(%y : $Builtin.Int1)
no:
  %n = integer_literal $Builtin.Int1, 0
  br isa(%n : $Builtin.Int1)
isa(%6 : $Builtin.Int1):
  %7 = strong_release %3 : $B
  %8 = strong_release %1#0 : $Builtin.ObjectPointer
  %9 = return %6 : $Builtin.Int1
}

sil @_TSd31_convertFromBuiltinFloatLiteralfMSdFT5valueBf64__Sd : $@thin ((value: Builtin.FPIEEE64), Float64.metatype) -> Float64
sil @_TSS32_convertFromBuiltinStringLiteralfMSSFT5valueBp8byteSizeBi64_7isASCIIBi1__SS : $@thin ((value: Builtin.RawPointer, byteSize: Builtin.Int64, isASCII: Builtin.Int1), String.metatype) -> String

// CHECK-LABEL: @_T7literal8literalsFT_T_ : $@thin () -> ()
sil @_T7literal8literalsFT_T_ : $@thin () -> () {
bb0:
  %0 = tuple ()
  %1 = alloc_stack $Float64
  %2 = function_ref @_TSd31_convertFromBuiltinFloatLiteralfMSdFT5valueBf64__Sd : $@thin ((value: Builtin.FPIEEE64), Float64.metatype) -> Float64
  %3 = metatype $Float64.metatype
  // CHECK: float_literal $Builtin.FPIEEE64, 0x3FFAB4ACADAB4AAA
  %4 = float_literal $Builtin.FPIEEE64, 0x3FFAB4ACADAB4AAA
  %5 = apply %2(%4, %3) : $@thin ((value: Builtin.FPIEEE64), Float64.metatype) -> Float64
  %6 = store %5 to %1#1 : $*Float64
  %7 = alloc_stack $String
  %8 = function_ref @_TSS32_convertFromBuiltinStringLiteralfMSSFT5valueBp8byteSizeBi64_7isASCIIBi1__SS : $@thin ((value: Builtin.RawPointer, byteSize: Builtin.Int64, isASCII: Builtin.Int1), String.metatype) -> String
  %9 = metatype $String.metatype
  // CHECK: string_literal "foo"
  %10 = string_literal "foo"
  // CHECK-NOT: "bar""
  %11 = string_literal "bar"
  %15 = apply %8(%11#0, %11#1, %11#2, %9) : $@thin ((value: Builtin.RawPointer, byteSize: Builtin.Int64, isASCII: Builtin.Int1), String.metatype) -> String
  %16 = store %15 to %7#1 : $*String
  %17 = load %7#1 : $*String
  %18 = struct_extract %17 : $String, #str_value  // CHECK: struct_extract
  %19 = struct_extract %18 : $StringByteData, #owner // CHECK: struct_extract
  %20 = strong_release %19 : $Builtin.ObjectPointer
  %21 = dealloc_stack %7#0 : $*@local_storage String
  %22 = dealloc_stack %1#0 : $*@local_storage Float64
  %23 = tuple ()
  %24 = return %23 : $()
}

// CHECK-LABEL: @_T5index5gep64FT1pBp1iBi64__Bp : $@thin (p: Builtin.RawPointer, i: Builtin.Int64) -> Builtin.RawPointer {
sil @_T5index5gep64FT1pBp1iBi64__Bp : $@thin (p: Builtin.RawPointer, i: Builtin.Int64) -> Builtin.RawPointer {
bb0(%0 : $Builtin.RawPointer, %1 : $Builtin.Int64):
  %2 = alloc_box $Builtin.RawPointer
  %3 = alloc_box $Builtin.Int64
  %4 = store %0 to %2#1 : $*Builtin.RawPointer
  %5 = store %1 to %3#1 : $*Builtin.Int64
  // %6 = module #Builtin
  %7 = load %2#1 : $*Builtin.RawPointer
  %8 = load %3#1 : $*Builtin.Int64
  // CHECK: index_raw_pointer {{%.*}} : $Builtin.RawPointer, {{%.*}} : $Builtin.Int64
  %9 = index_raw_pointer %7 : $Builtin.RawPointer, %8 : $Builtin.Int64
  %10 = strong_release %3#0 : $Builtin.ObjectPointer
  %11 = strong_release %2#0 : $Builtin.ObjectPointer
  %12 = return %9 : $Builtin.RawPointer
}

var x : Int = 0
sil @global_callee : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64

// CHECK-LABEL: @global_code : $@thin () -> ()
sil internal @global_code : $@thin () -> () {
bb0:
  // CHECK: global_addr #x : $*Int64
  %0 = global_addr #x : $*Int64
  %1 = function_ref @global_callee : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %2 = metatype $Int64.metatype
  %3 = integer_literal $Builtin.Int128, 0 // CHECK: integer_literal $Builtin.Int128, 0
  %4 = apply %1(%3, %2) : $@thin ((val: Builtin.Int128), Int64.metatype) -> Int64
  %5 = store %4 to %0 : $*Int64
  %6 = tuple ()
  %7 = return %6 : $()
}

protocol SomeProtocol {
}
class SomeClass : SomeProtocol {
}
class SomeSubclass : SomeClass {}

// CHECK-LABEL: @test_class_metatype : $@thin (c: SomeClass, s: SomeSubclass) -> (SomeClass.metatype, SomeClass.metatype) {
sil @test_class_metatype : $@thin (c: SomeClass, s: SomeSubclass) -> (SomeClass.metatype, SomeClass.metatype) {
bb0(%0 : $SomeClass, %1 : $SomeSubclass):
  %2 = alloc_box $SomeClass
  %3 = alloc_box $SomeSubclass
  %4 = store %0 to %2#1 : $*SomeClass
  %5 = store %1 to %3#1 : $*SomeSubclass
  %7 = load %2#1 : $*SomeClass
  // CHECK: strong_retain %{{.*}} : $SomeClass
  %8 = strong_retain %7 : $SomeClass
  // CHECK: class_metatype $SomeClass.metatype, {{%.*}} : $SomeClass
  %9 = class_metatype $SomeClass.metatype, %7 : $SomeClass
  %11 = load %3#1 : $*SomeSubclass
  %12 = strong_retain %11 : $SomeSubclass
  // CHECK: class_metatype $SomeSubclass.metatype, {{%.*}} : $SomeSubclass
  %13 = class_metatype $SomeSubclass.metatype, %11 : $SomeSubclass
  // CHECK: upcast %{{.*}} : $SomeSubclass.metatype to $SomeClass.metatype
  %14 = upcast %13 : $SomeSubclass.metatype to $SomeClass.metatype
  // CHECK: tuple (%{{.*}} : $SomeClass.metatype, %{{.*}} : $SomeClass.metatype)
  %15 = tuple (%9 : $SomeClass.metatype, %14 : $SomeClass.metatype)
  %16 = strong_release %11 : $SomeSubclass
  %17 = strong_release %7 : $SomeClass
  %18 = strong_release %3#0 : $Builtin.ObjectPointer
  %19 = strong_release %2#0 : $Builtin.ObjectPointer
  %20 = return %15 : $(SomeClass.metatype, SomeClass.metatype)
}

// CHECK-LABEL: @test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype {
sil @test_protocol_metatype : $@thin (p: SomeProtocol) -> SomeProtocol.metatype {
bb0(%0 : $*SomeProtocol):
  %1 = alloc_box $SomeProtocol
  // CHECK: copy_addr [take] %0 to [initialization] %1#1 : $*SomeProtocol
  %2 = copy_addr [take] %0 to [initialization] %1#1 : $*SomeProtocol
  // CHECK: alloc_stack
  %4 = alloc_stack $SomeProtocol
  // CHECK: copy_addr %1#1 to [initialization] %{{.*}}#1 : $*SomeProtocol
  %5 = copy_addr %1#1 to [initialization] %4#1 : $*SomeProtocol
  // CHECK: protocol_metatype $SomeProtocol.metatype, {{%.*}} : $*SomeProtocol
  %6 = protocol_metatype $SomeProtocol.metatype, %4#1 : $*SomeProtocol
  %7 = destroy_addr %4#1 : $*SomeProtocol
  %8 = dealloc_stack %4#0 : $*@local_storage SomeProtocol
  %9 = strong_release %1#0 : $Builtin.ObjectPointer
  %10 = return %6 : $SomeProtocol.metatype
}

// CHECK-LABEL: sil deserialized @test_unreachable
sil @test_unreachable : $@thin () -> () {
bb0:
  unreachable
// CHECK: unreachable
}

// CHECK-LABEL: @test_unowned_retain : $@thin (p: SomeClass) -> () {
sil @test_unowned_retain : $@thin (p: SomeClass) -> () {
bb0(%0 : $SomeClass):
  %1 = ref_to_unowned %0 : $SomeClass to $@sil_unowned SomeClass
  // CHECK: ref_to_unowned %0 : $SomeClass to $@sil_unowned SomeClass
  %2 = unowned_retain %1 : $@sil_unowned SomeClass
  // CHECK: unowned_retain %1 : $@sil_unowned SomeClass
  %3 = unowned_release %1 : $@sil_unowned SomeClass
  // CHECK: unowned_release %1 : $@sil_unowned SomeClass
  %4 = unowned_to_ref %1 : $@sil_unowned SomeClass to $SomeClass
  // CHECK: unowned_to_ref %1 : $@sil_unowned SomeClass to $SomeClass
  %5 = tuple ()
  %6 = return %5 : $()
}

// CHECK-LABEL: sil deserialized @test_basic_block_arguments
sil @test_basic_block_arguments : $@thin (i: Builtin.Int1) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int1):
  // CHECK: cond_br
  cond_br %0, bb1, bb2
bb1:
  %2 = integer_literal $Builtin.Int64, 5
  br bb3(%2 : $Builtin.Int64)
  //CHECK: br bb3(%2 : $Builtin.Int64)
bb2:
  %4 = integer_literal $Builtin.Int64, 6
  br bb3(%4 : $Builtin.Int64)
  //CHECK: br bb3(%4 : $Builtin.Int64)
bb3(%6 : $Builtin.Int64):
  //CHECK: bb3(%6 : $Builtin.Int64)
  return %6 : $Builtin.Int64
}

// CHECK-LABEL: sil deserialized @test_cond_branch_basic_block_args
sil @test_cond_branch_basic_block_args : $@thin (i: Int64, b: Builtin.Int1) -> Int64 {
bb0(%0 : $Int64, %1 : $Builtin.Int1):
  cond_br %1, bb1(%0 : $Int64), bb2(%0 : $Int64)
  // CHECK: cond_br %1, bb1(%0 : $Int64), bb2(%0 : $Int64)
bb1(%3 : $Int64):
  br bb3 (%3 : $Int64)
bb2(%2 : $Int64):
  br bb3(%2 : $Int64)
bb3(%4 : $Int64):
  return %4 : $Int64
}

class Bas : NSObject {
  var strRealProp : String
}

// Generated from
// class Bas : NSObject {
//   var strRealProp : String
//   init() {
//     super.init()
//   }
// }
// CHECK-LABEL: sil deserialized @test_autorelease_return
sil @test_autorelease_return : $@cc(objc_method) @thin (Bas, ()) -> NSString {
bb0(%0 : $Bas):
  strong_retain %0 : $Bas
  %2 = ref_element_addr %0 : $Bas, #strRealProp
  %3 = load %2 : $*String
  strong_release %0 : $Bas
  %5 = struct_extract %3 : $String, #str_value
  %6 = struct_extract %5 : $StringByteData, #owner
  strong_retain %6 : $Builtin.ObjectPointer
  %8 = function_ref @swift_StringToNSString : $@thin (string: @inout String) -> NSString
  %9 = alloc_stack $String
  store %3 to %9#1 : $*String
  %11 = apply %8(%9#1) : $@thin (string: @inout String) -> NSString
  dealloc_stack %9#0 : $*@local_storage String
  %13 = struct_extract %3 : $String, #str_value
  %14 = struct_extract %13 : $StringByteData, #owner
  strong_release %14 : $Builtin.ObjectPointer
  // CHECK: autorelease_return %{{.*}} : $NSString
  autorelease_return %11 : $NSString
}
sil @swift_StringToNSString : $@thin (string: @inout String) -> NSString

// CHECK-LABEL: sil deserialized @test_super_method
sil @test_super_method : $@cc(method) @thin ((), Bas) -> Bas {
bb0(%0 : $Bas):
  %1 = tuple ()
  %2 = alloc_box $Bas
  store %0 to %2#1 : $*Bas
  %4 = function_ref @_TSSCfMSSFT_SS : $@thin ((), String.metatype) -> String
  %5 = metatype $String.metatype
  %6 = apply %4(%5) : $@thin ((), String.metatype) -> String
  %7 = load %2#1 : $*Bas
  strong_retain %7 : $Bas
  %9 = ref_element_addr %7 : $Bas, #strRealProp
  %10 = load %9 : $*String
  store %6 to %9 : $*String
  %12 = struct_extract %10 : $String, #str_value
  %13 = struct_extract %12 : $StringByteData, #owner
  strong_release %13 : $Builtin.ObjectPointer
  strong_release %7 : $Bas
  %16 = load %2#1 : $*Bas
  strong_retain %16 : $Bas
  %18 = upcast %16 : $Bas to $NSObject
  // CHECK: super_method [volatile] %{{.*}} : $Bas, #NSObject.init!initializer.1.foreign :
  %19 = super_method [volatile] %16 : $Bas, #NSObject.init!initializer.1.foreign : $@cc(objc_method) @thin ((), NSObject) -> NSObject
  %20 = apply %19(%18) : $@cc(objc_method) @thin ((), NSObject) -> NSObject
  // CHECK: strong_retain_autoreleased %{{.*}} : $NSObject
  strong_retain_autoreleased %20 : $NSObject
  %22 = unconditional_checked_cast downcast %20 : $NSObject to $Bas
  %23 = load %2#1 : $*Bas
  store %22 to %2#1 : $*Bas
  strong_release %23 : $Bas
  strong_release %16 : $Bas
  %27 = load %2#1 : $*Bas
  strong_retain %27 : $Bas
  strong_release %2#0 : $Builtin.ObjectPointer
  return %27 : $Bas
}
sil @_TSSCfMSSFT_SS : $@thin ((), String.metatype) -> String

// CHECK-LABEL: sil deserialized @test_builtin_func_ref
sil @test_builtin_func_ref : $@thin (x: Builtin.Int1, y: Builtin.Int1) -> Builtin.Int1 {
bb0(%0 : $Builtin.Int1, %1 : $Builtin.Int1):
  %2 = alloc_box $Builtin.Int1
  %3 = alloc_box $Builtin.Int1
  store %0 to %2#1 : $*Builtin.Int1
  store %1 to %3#1 : $*Builtin.Int1
  %6 = module #Builtin              // CHECK: module #Builtin
  // CHECK: builtin_function_ref #Builtin.cmp_eq_Int1 : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  %7 = builtin_function_ref #Builtin.cmp_eq_Int1 : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  %8 = load %2#1 : $*Builtin.Int1
  %9 = load %3#1 : $*Builtin.Int1
  %10 = apply %7(%8, %9) : $@thin (Builtin.Int1, Builtin.Int1) -> Builtin.Int1
  strong_release %3#0 : $Builtin.ObjectPointer
  strong_release %2#0 : $Builtin.ObjectPointer
  return %10 : $Builtin.Int1
}

// CHECK-LABEL: sil deserialized @test_dealloc_ref
sil @test_dealloc_ref : $@thin () -> () {
bb0:
  %0 = alloc_ref $Class1
  // CHECK: dealloc_ref %{{.*}} : $Class1
  dealloc_ref %0 : $Class1
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: sil deserialized @test_dealloc_box
sil @test_dealloc_box : $@thin () -> () {
bb0:
  %0 = alloc_box $Class1
  dealloc_box $Class1, %0#0 : $Builtin.ObjectPointer
  %2 = tuple ()
  return %2 : $()
}

// CHECK-LABEL: @closure_test
sil @takes_closure : $@thin (x : () -> ()) -> ()
sil @closure0 : $@thin ((), (Builtin.ObjectPointer, @inout Int64)) -> ()

sil @closure_test : $@thin () -> () {
bb0:
  %0 = alloc_box $Int64                           // users: %10, %8, %8, %7, %4

  %5 = function_ref @takes_closure : $@thin (x : () -> ()) -> ()
  %6 = function_ref @closure0 : $@thin ((), (Builtin.ObjectPointer, @inout Int64)) -> ()
  strong_retain %0#0 : $Builtin.ObjectPointer
  //%8 = partial_apply %6(%0#0, %0#1) : $@thin ((), (Builtin.ObjectPointer, @inout Int64)) -> ()
  //%9 = apply %5(%8) : $@thin (x : () -> ()) -> ()
  //strong_release %0#0 : $Builtin.ObjectPointer

  %11 = tuple ()
  return %11 : $()
}

@class_protocol protocol ClassP {}

enum MaybePair {
  case Neither
  case Left(Int)
}

sil @_T6switch1aFT_T_ : $@thin () -> ()
sil @_T6switch1bFT_T_ : $@thin () -> ()
sil @_T6switch1cFT_T_ : $@thin () -> ()

// CHECK-LABEL: sil deserialized @test_switch_union : $@thin (u: MaybePair) -> ()
sil @test_switch_union : $@thin (u: MaybePair) -> () {
bb0(%0 : $MaybePair):
  %1 = alloc_box $MaybePair
  store %0 to %1#1 : $*MaybePair
  %3 = load %1#1 : $*MaybePair
  %4 = tuple ()
  // CHECK: switch_enum %{{.*}} : $MaybePair, case #MaybePair.Neither!enumelt: bb{{.*}}, case #MaybePair.Left!enumelt.1: bb
  switch_enum %3 : $MaybePair, case #MaybePair.Neither!enumelt: bb1, case #MaybePair.Left!enumelt.1: bb3

bb1:
  br bb2

bb2:
  %7 = function_ref @_T6switch1aFT_T_ : $@thin () -> ()
  %8 = apply %7() : $@thin () -> ()
  br bb5                                                 // CHECK: br

bb3(%10 : $Int64):
  br bb4

bb4:
  %12 = function_ref @_T6switch1bFT_T_ : $@thin () -> ()
  %13 = apply %12() : $@thin () -> ()
  br bb5                                                  // CHECK: br

bb5:
  %15 = function_ref @_T6switch1cFT_T_ : $@thin () -> ()
  %16 = apply %15() : $@thin () -> ()
  strong_release %1#0 : $Builtin.ObjectPointer
  %18 = tuple ()
  return %18 : $()                                        // CHECK: return
}

enum MaybeAddressOnlyPair {
  case Neither
  case Left(Q)
}

// CHECK-LABEL: sil deserialized @test_switch_union_addr : $@thin (u: MaybeAddressOnlyPair) -> ()
sil @test_switch_union_addr : $@thin (u: MaybeAddressOnlyPair) -> () {
bb0(%0 : $*MaybeAddressOnlyPair):
  // CHECK: destructive_switch_enum_addr %{{.*}} : $*MaybeAddressOnlyPair, case #MaybeAddressOnlyPair.Neither!enumelt: bb{{.*}}, case #MaybeAddressOnlyPair.Left!enumelt.1: bb
  destructive_switch_enum_addr %0 : $*MaybeAddressOnlyPair, case #MaybeAddressOnlyPair.Neither!enumelt: bb1, case #MaybeAddressOnlyPair.Left!enumelt.1: bb2

bb1:
  br bb3

bb2(%q : $*Q):
  br bb3

bb3:
  %t = tuple ()
  return %t : $()
}

// CHECK-LABEL: sil deserialized @test_switch_int : $@thin (u: Builtin.Int64) -> ()
sil @test_switch_int : $@thin (u: Builtin.Int64) -> () {
bb0(%0 : $Builtin.Int64):
  // CHECK: switch_int %{{.*}} : $Builtin.Int64, case 1: bb1, case 2: bb2
  switch_int %0 : $Builtin.Int64, case 1: bb1, case 2: bb2

bb1:
  %7 = function_ref @_T6switch1aFT_T_ : $@thin () -> () // CHECK: function_ref
  %8 = apply %7() : $@thin () -> ()
  br bb3

bb2:
  %12 = function_ref @_T6switch1bFT_T_ : $@thin () -> () // CHECK: function_ref
  %13 = apply %12() : $@thin () -> ()
  br bb3

bb3:
  %18 = tuple ()
  return %18 : $()                                        // CHECK: return
}

class ConcreteClass : ClassP {
}
struct Spoon : Bendable {
}

// CHECK-LABEL: sil deserialized @test_init_existential : $@thin (x: Spoon) -> Bendable
sil @test_init_existential : $@thin (x : Spoon) -> Bendable {
bb0(%0 : $*Bendable, %1 : $Spoon):
  %2 = alloc_box $Spoon
  store %1 to %2#1 : $*Spoon
  // CHECK: init_existential %{{.*}} : $*Bendable, $*Spoon
  %4 = init_existential %0 : $*Bendable, $*Spoon
  // CHECK: deinit_existential %{{.*}} : $*Bendable
  deinit_existential %0 : $*Bendable
  %5 = load %2#1 : $*Spoon
  store %5 to %4 : $*Spoon
  strong_release %2#0 : $Builtin.ObjectPointer
  %8 = tuple ()
  return %8 : $()
}

// CHECK-LABEL: sil deserialized @test_existential_ref : $@thin (x: ConcreteClass) -> ClassP
sil @test_existential_ref : $@thin (x : ConcreteClass) -> ClassP {
bb0(%0 : $ConcreteClass):
  %1 = alloc_box $ConcreteClass
  store %0 to %1#1 : $*ConcreteClass
  %3 = load %1#1 : $*ConcreteClass
  strong_retain %3 : $ConcreteClass
  // CHECK: init_existential_ref %{{.*}} : $ConcreteClass, $ClassP
  %5 = init_existential_ref %3 : $ConcreteClass, $ClassP
  strong_release %1#0 : $Builtin.ObjectPointer
  return %5 : $ClassP
}

sil @test_assign : $@thin (x: Int64, y: @inout Int64) -> () {    // CHECK-LABEL: sil deserialized @test_assign
bb0(%0 : $Int64, %1 : $*Int64):
  assign %0 to %1 : $*Int64                   // CHECK: assign
  unreachable
}

// CHECK-LABEL: sil deserialized @test_transparent : $@thin () -> () {
sil @test_transparent : $@thin () -> () {
bb0:
  // CHECK: function_ref
  // CHECK: apply [transparent]
  %0 = function_ref @classes : $@thin () -> ()
  %1 = apply [transparent] %0() : $@thin () -> ()
  %2 = tuple ()
  %3 = return %2 : $()
}

sil @takes_unnamed_closure : $@thin (() -> Int64) -> () -> () -> Int64

sil @takes_int64_float32 : $@thin (Int64, Float32) -> ()

// CHECK-LABEL: sil deserialized @test_partial_apply : $@thin Float32 -> Int64 -> () {
sil @test_partial_apply : $@thin Float32 -> Int64 -> () {
bb0(%0 : $Float32):
  %1 = function_ref @takes_int64_float32 : $@thin (Int64, Float32) -> ()
  // CHECK: partial_apply %{{.*}}(%{{.*}}) : $@thin (Int64, Float32) -> ()
  %2 = partial_apply %1(%0) : $@thin (Int64, Float32) -> ()
  %3 = return %2 : $Int64 -> ()
}

class X {
  @objc def f() { }
}

// CHECK-LABEL: sil deserialized @test_dynamic_lookup_br : $@thin (obj: DynamicLookup) -> ()
sil @test_dynamic_lookup_br : $@thin (obj: DynamicLookup) -> () {
bb0(%0 : $DynamicLookup):
  %1 = alloc_box $DynamicLookup
  store %0 to %1#1 : $*DynamicLookup
  %3 = alloc_box $Optional<() -> ()>
  %4 = load %1#1 : $*DynamicLookup
  strong_retain %4 : $DynamicLookup
  // CHECK: project_existential_ref %{{.*}} : $DynamicLookup to $@sil_self DynamicLookup
  %6 = project_existential_ref %4 : $DynamicLookup to $@sil_self DynamicLookup
  %7 = ref_to_object_pointer %6 : $@sil_self DynamicLookup to $Builtin.ObjCPointer
  // CHECK: dynamic_method_br %{{.*}} : $Builtin.ObjCPointer, #X.f!1, bb{{.*}}, bb{{.*}}
  dynamic_method_br %7 : $Builtin.ObjCPointer, #X.f!1, bb1, bb2
bb1:
  br bb3

bb2:
  br bb3

bb3:
  %28 = tuple ()
  return %28 : $()
}

// CHECK-LABEL: sil deserialized @test_mark_fn_escape
sil @test_mark_fn_escape : $@thin () -> () {
  %b = alloc_box $Int64
  %c = alloc_box $Int64

  //mark_function_escape %b#1 : $*Int64
  //mark_function_escape %b#1 : $*Int64, %c#1 : $*Int64

  %28 = tuple ()
  return %28 : $()
}

// CHECK-LABEL: sil deserialized @test_copy_destroy_value
sil @test_copy_destroy_value : $@thin (v : Val) -> (Val) {
bb0(%0 : $Val):
  %1 = copy_value %0 : $Val
  destroy_value %0 : $Val
  return %1 : $Val
  // CHECK:      [[T1:%.*]] = copy_value [[T0:%.*]] : $Val
  // CHECK-NEXT: destroy_value [[T0]] : $Val
  // CHECK-NEXT: return [[T1]] : $Val
}

def serialize_all() {
}

// CHECK: sil deserialized @cond_fail_test : $@thin Builtin.Int1 -> () {
sil @cond_fail_test : $@thin Builtin.Int1 -> () {
entry(%0 : $Builtin.Int1):
  // CHECK: cond_fail %0 : $Builtin.Int1
  cond_fail %0 : $Builtin.Int1
  %1 = tuple ()
  return %1 : $()
}

// rdar://15351123
// CHECK-LABEL: @test_forward_ref
sil  @test_forward_ref : $@thin (lhs: UInt8, rhs: UInt8) -> UInt8

@fragile
class Foo {
  subscript (x: Int, y: Int) -> Int
  var x: Int
  var y: Int
}

// CHECK-LABEL: sil deserialized @_TC3tmp3Foo9subscriptFT1xSi1ySi_Sig : $@cc(method) @thin ((), (x: Int64, y: Int64), Foo) -> Int64 {
// CHECK_DECL-LABEL: sil deserialized @_TC3tmp3Foo9subscriptFT1xSi1ySi_Sig : $@cc(method) @thin ((), (x: Int64, y: Int64), Foo) -> Int64{{$}} 
sil @_TC3tmp3Foo9subscriptFT1xSi1ySi_Sig : $@cc(method) @thin ((), (x: Int64, y: Int64), Foo) -> Int64 {
bb0(%0 : $Int64, %1 : $Int64, %2 : $Foo):
  %3 = tuple ()
  %4 = alloc_stack $Int64  // var x               // users: %17, %6
  %5 = alloc_stack $Int64  // var y               // users: %16, %7
  store %0 to %4#1 : $*Int64
  store %1 to %5#1 : $*Int64
  %8 = alloc_stack $Foo  // var self              // users: %15, %14, %9
  store %2 to %8#1 : $*Foo
  %10 = metatype $Int64.metatype
  %11 = module #Builtin
  %12 = integer_literal $Builtin.Int64, 0         // user: %13
  %13 = struct $Int64 (%12 : $Builtin.Int64)      // user: %18
  destroy_addr %8#1 : $*Foo
  dealloc_stack %8#0 : $*@local_storage Foo
  dealloc_stack %5#0 : $*@local_storage Int64
  dealloc_stack %4#0 : $*@local_storage Int64
  return %13 : $Int64
}

// CHECK-LABEL: sil deserialized @_TC3tmp3Foo9subscriptFT1xSi1ySi_Sis : $@cc(method) @thin ((value: Int64), (x: Int64, y: Int64), Foo) -> () {
// CHECK_DECL-LABEL: sil deserialized @_TC3tmp3Foo9subscriptFT1xSi1ySi_Sis : $@cc(method) @thin ((value: Int64), (x: Int64, y: Int64), Foo) -> (){{$}}
sil @_TC3tmp3Foo9subscriptFT1xSi1ySi_Sis : $@cc(method) @thin ((value: Int64), (x: Int64, y: Int64), Foo) -> () {
bb0(%0 : $Int64, %1 : $Int64, %2 : $Int64, %3 : $Foo):
  %4 = alloc_stack $Int64  // var value           // users: %16, %5
  store %0 to %4#1 : $*Int64
  %6 = alloc_stack $Int64  // var x               // users: %15, %8
  %7 = alloc_stack $Int64  // var y               // users: %14, %9
  store %1 to %6#1 : $*Int64
  store %2 to %7#1 : $*Int64
  %10 = alloc_stack $Foo  // var self             // users: %13, %12, %11
  store %3 to %10#1 : $*Foo
  destroy_addr %10#1 : $*Foo
  dealloc_stack %10#0 : $*@local_storage Foo
  dealloc_stack %7#0 : $*@local_storage Int64
  dealloc_stack %6#0 : $*@local_storage Int64
  dealloc_stack %4#0 : $*@local_storage Int64
  %17 = tuple ()                                  // user: %18
  return %17 : $()
}

// CHECK-LABEL: sil_vtable Foo {
// CHECK: #Foo.subscript!getter.2: _TC3tmp3Foo9subscriptFT1xSi1ySi_Sig
// CHECK: #Foo.subscript!setter.2: _TC3tmp3Foo9subscriptFT1xSi1ySi_Sis
// CHECK: }
// CHECK_DECL-LABEL: sil_vtable Foo {
// CHECK_DECL: #Foo.subscript!getter.2: _TC3tmp3Foo9subscriptFT1xSi1ySi_Sig
// CHECK_DECL: #Foo.subscript!setter.2: _TC3tmp3Foo9subscriptFT1xSi1ySi_Sis
// CHECK_DECL: }
sil_vtable Foo {
  #Foo.subscript!getter.2: _TC3tmp3Foo9subscriptFT1xSi1ySi_Sig
  #Foo.subscript!setter.2: _TC3tmp3Foo9subscriptFT1xSi1ySi_Sis
}

sil @_T9def_basic13serialize_allFT_T_ : $@thin () -> () {
bb0:
  %2 = function_ref @test1 : $@thin () -> ()
  %4 = function_ref @test2 : $@thin (x: Int64) -> ()
  %6 = function_ref @named_tuple : $@thin () -> (x: Builtin.Int64, Builtin.Int64)
  %9 = function_ref @return_int : $@thin (a: Int64) -> Int64
  %11 = function_ref @call_fn_pointer : $@thin (a : () -> Int64) -> Int64
  %13 = function_ref @return_constant : $@thin () -> Int64
  %23 = function_ref @existentials : $@thin (n : P) -> ()
  %25 = function_ref @classes : $@thin () -> ()
  %27 = function_ref @_T4todo18erasure_from_protoFT1xPS_8RuncibleS_8Bendable__PS0__ : $@thin (x : protocol<Bendable, Runcible>) -> Runcible
  %29 = function_ref @_T4todo18class_bound_methodFT1xPS_10ClassBound__T_ : $@thin (x : ClassBound) -> ()
  %31 = function_ref @_TV6struct5AlephCfMS0_FT1aCS_3Ref1bVS_3Val_S0_ : $@thin ((a : Ref, b : Val), Aleph.metatype) -> Aleph
  %33 = function_ref @_TV6struct5AlephCfMS0_FT_S0_ : $@thin ((), Aleph.metatype) -> Aleph
  %35 = function_ref @test_union_empty_case : $@thin () -> Beth
  %37 = function_ref @test_union_data_case : $@thin Int64 -> Beth
  %39 = function_ref @test_union_addr_empty_case : $@thin () -> Gimel
  %41 = function_ref @test_union_addr_data_case : $@thin (Q) -> Gimel
  %43 = function_ref @_T5tuple5floatFT1xSf_T_ : $@thin (x : Float32) -> ()
  %45 = function_ref @_T5tuple5tupleFT_TSiSf_ : $@thin () -> (Int64, Float32)
  %47 = function_ref @_T5tuple13tuple_elementFT1xTSiSf__T_ : $@thin (x : (Int64, Float32)) -> ()
  %49 = function_ref @_TC3ref1C3foofS0_FT1xSi_T_ : $@cc(method) @thin ((x: Int64), M) -> ()
  %51 = function_ref @_T4null3isaFT1bCS_1B_Sb : $@thin (b : B) -> Builtin.Int1
  %53 = function_ref @_TSd31_convertFromBuiltinFloatLiteralfMSdFT5valueBf64__Sd : $@thin ((value: Builtin.FPIEEE64), Float64.metatype) -> Float64
  %55 = function_ref @_TSS32_convertFromBuiltinStringLiteralfMSSFT5valueBp8byteSizeBi64_7isASCIIBi1__SS : $@thin ((value: Builtin.RawPointer, byteSize: Builtin.Int64, isASCII: Builtin.Int1), String.metatype) -> String
  %57 = function_ref @_T7literal8literalsFT_T_ : $@thin () -> ()
  %59 = function_ref @_T5index5gep64FT1pBp1iBi64__Bp : $@thin (p: Builtin.RawPointer, i: Builtin.Int64) -> Builtin.RawPointer
  %60 = function_ref @global_code : $@thin () -> ()
  %63 = function_ref @test_class_metatype : $@thin (c : SomeClass, s : SomeSubclass) -> (SomeClass.metatype, SomeClass.metatype)
  %67 = function_ref @test_protocol_metatype : $@thin (p : SomeProtocol) -> SomeProtocol.metatype
  %69 = function_ref @test_unreachable : $@thin () -> ()
  %71 = function_ref @test_unowned_retain : $@thin (p : SomeClass) -> ()
  %73 = function_ref @test_basic_block_arguments : $@thin (i: Builtin.Int1) -> Builtin.Int64
  %75 = function_ref @test_cond_branch_basic_block_args : $@thin (i: Int64, b: Builtin.Int1) -> Int64

  %77 = function_ref @test_autorelease_return : $@cc(objc_method) @thin (Bas, ()) -> NSString
  %79 = function_ref @test_super_method : $@cc(method) @thin ((), Bas) -> Bas
  %81 = function_ref @test_builtin_func_ref : $@thin (x: Builtin.Int1, y: Builtin.Int1) -> Builtin.Int1
  %83 = function_ref @test_dealloc_ref : $@thin () -> ()
  %85 = function_ref @test_dealloc_box : $@thin () -> ()
  %87 = function_ref @closure_test : $@thin () -> ()
  %97 = function_ref @test_switch_union : $@thin (u: MaybePair) -> ()
  %99 = function_ref @test_switch_union_addr : $@thin (u: MaybeAddressOnlyPair) -> ()
  %101 = function_ref @test_switch_int : $@thin (u: Builtin.Int64) -> ()
  %103 = function_ref @test_init_existential : $@thin (x: Spoon) -> Bendable
  %105 = function_ref @test_existential_ref : $@thin (x: ConcreteClass) -> ClassP

  %107 = function_ref @test_assign : $@thin (x: Int64, y: @inout Int64) -> ()
  %109 = function_ref @test_transparent : $@thin () -> ()
  %111 = function_ref @test_partial_apply : $@thin Float32 -> Int64 -> ()
  %113 = function_ref @test_dynamic_lookup_br : $@thin (obj: DynamicLookup) -> ()
  %115 = function_ref @test_mark_fn_escape : $@thin () -> ()
  %117 = function_ref @test_copy_destroy_value : $@thin (v: Val) -> (Val)
  %118 = function_ref @cond_fail_test : $@thin Builtin.Int1 -> ()

  %120 = function_ref @test_forward_ref : $@thin (lhs: UInt8, rhs: UInt8) -> UInt8

  %119 = tuple ()
  return %119 : $()
}
