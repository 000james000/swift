// RUN: %swift -target x86_64-apple-darwin10 %s -emit-ir | FileCheck %s

// Make sure that we are able to lower unconditional_checked_cast
// addresses for the super_to_archetype case and the downcast case.

class C {}
class D : C {}

// CHECK-LABEL: define void @downcast_test(%C26unconditional_checked_cast1D** noalias sret, %C26unconditional_checked_cast1C** noalias) {
// CHECK: entry:
// CHECK-NEXT: [[INPUTPTR:%[0-9]+]] = load %C26unconditional_checked_cast1C** [[INPUTPTRPTR:%[0-9]+]], align 8
// CHECK-NEXT: [[I8INPUTPTR:%[0-9]+]] = bitcast %C26unconditional_checked_cast1C* [[INPUTPTR]] to i8*
// CHECK-NEXT: call i8* @swift_dynamicCastClassUnconditional(i8* [[I8INPUTPTR]], i8* bitcast (%swift.type* getelementptr inbounds (%swift.full_heapmetadata* bitcast ({ void (%C26unconditional_checked_cast1D*)*, i8**, i64, %swift.type*, %swift.opaque*, %swift.opaque*, i64, i32, i32, { i64, i8*, i32, i32, i8*, %swift.type** (%swift.type*)*, i32, i32 }*, %C26unconditional_checked_cast1D* (%C26unconditional_checked_cast1D*)* }* @_TMdC26unconditional_checked_cast1D to %swift.full_heapmetadata*), i32 0, i32 2) to i8*))
// CHECK-NEXT: bitcast
// CHECK-NEXT: [[DOWNCASTINPUTPTR:%[0-9]+]] = bitcast %C26unconditional_checked_cast1C** [[INPUTPTRPTR]] to %C26unconditional_checked_cast1D**
// CHECK-NEXT: [[DOWNCASTLOADINPUTPTR:%[0-9]+]] = load %C26unconditional_checked_cast1D** [[DOWNCASTINPUTPTR]], align 8
// CHECK-NEXT: store %C26unconditional_checked_cast1D* [[DOWNCASTLOADINPUTPTR]], %C26unconditional_checked_cast1D** {{%[0-9]+}}, align 8
// CHECK-NEXT: ret void

sil @downcast_test : $@thin (@out D, @inout C) -> () {
bb0(%0 : $*D, %1 : $*C):
  %2 = unconditional_checked_cast downcast %1 : $*C to $*D
  copy_addr [take] %2 to [initialization] %0 : $*D
  %33 = tuple()
  return %33 : $()
}
