// RUN: %target-swift-frontend -emit-ir %s | FileCheck %s

// REQUIRES: CPU=x86_64
// REQUIRES: objc_interop

import Builtin
import Swift

// CHECK: [[OBJCCLASS:%objc_class]] = type
// CHECK: [[OPAQUE:%swift.opaque]] = type opaque
// CHECK: [[TYPE:%swift.type]] = type
// CHECK: [[C_CLASS:%C5class1C]] = type
// CHECK: [[REF:%swift.refcounted]] = type
// CHECK: [[D_CLASS:%C5class1D]] = type
// CHECK: [[OBJCOBJ:%objc_object]] = type

class C {}
sil_vtable C {}

// <rdar://14812566>: include _Tt prefix here
//   CHECK: [[C_NAME:@.*]] = private unnamed_addr constant [13 x i8] c"_TtC5class1C\00"

//   CHECK: @_DATA__TtC5class1C = private constant {{.*}} {
// \ CHECK:   i32 128,
// \ CHECK:   i32 16,
// \ CHECK:   i32 16,
// \ CHECK:   i32 0,
// \ CHECK:   i8* null,
// \ CHECK:   i8* getelementptr inbounds ([13 x i8]* [[C_NAME]], i64 0, i64 0),
// \ CHECK:   i8* null,
// \ CHECK:   i8* null,
// \ CHECK:   i8* null,
// \ CHECK:   i8* null,
// \ CHECK:   i8* null
// \ CHECK: }

//   CHECK: @_TMdC5class1C = global { {{.*}} } {
// \ CHECK:   void ([[C_CLASS]]*)* @_TFC5class1CD,
// \ CHECK:   i8** @_TWVBo,
// \ CHECK:   i64 ptrtoint ([[OBJCCLASS]]* @_TMmC5class1C to i64),
// \ CHECK:   [[OBJCCLASS]]* @"OBJC_CLASS_$_SwiftObject",
// \ CHECK:   [[OPAQUE]]* @_objc_empty_cache,
// \ CHECK:   [[OPAQUE]]* {{(@_objc_empty_vtable|null)}},
// \ CHECK:   i64 add (i64 ptrtoint ({{.*}}* @_DATA__TtC5class1C to i64), i64 1)
// \ CHECK: }

//   CHECK: @_TMdC5class1D = global { {{.*}} } {
// \ CHECK:   void ([[D_CLASS]]*)* @_TFC5class1DD,
// \ CHECK:   i8** @_TWVBo,
// \ CHECK:   i64 ptrtoint ([[OBJCCLASS]]* @_TMmC5class1D to i64),
// \ CHECK:   [[OBJCCLASS]]* @"OBJC_CLASS_$_SwiftObject",
// \ CHECK:   [[OPAQUE]]* @_objc_empty_cache,
// \ CHECK:   [[OPAQUE]]* {{(@_objc_empty_vtable|null)}},
// \ CHECK:   i64 add (i64 ptrtoint ({{.*}}* @_DATA__TtC5class1D to i64), i64 1),
// \ CHECK:   i32 3,
// \ CHECK:   i32 0,
// \ CHECK:   i32 16,
// \ CHECK:   i16 7,
// \ CHECK:   i16 0,
// \ CHECK:   i32 104,
// \ CHECK:   i32 16,
// \ CHECK:   {{.*}}* @_TMnC5class1D,
// \ CHECK:   i32 (i16, i8, [[D_CLASS]]*)* @_TFC5class1D8multiplyfS0_fT1xBi8__FT1yBi16__Bi32_
// \ CHECK: }

// Destroying destructor
// CHECK: define [[REF]]* @_TFC5class1Cd([[C_CLASS]]*) {
// CHECK-NEXT: entry:
// CHECK-NEXT: [[OBJ_PTR:%[a-zA-Z0-9]+]] = bitcast [[C_CLASS]]* %0 to [[REF]]*
// CHECK-NEXT: ret [[REF]]* [[OBJ_PTR]]
sil @_TFC5class1Cd : $@cc(method) @thin (@owned C) -> @owned Builtin.NativeObject {
bb0(%0 : $C):
  %1 = unchecked_ref_cast %0 : $C to $Builtin.NativeObject // user: %2
  return %1 : $Builtin.NativeObject              // id: %2
}

// Deallocating destructor
// CHECK: define void @_TFC5class1CD([[C_CLASS]]*)
sil @_TFC5class1CD : $@cc(method) @thin (@owned C) -> () {
bb0(%0 : $C):
  // CHECK-NEXT: entry
  // CHECK-NEXT: [[SELF:%[a-zA-Z0-9]+]] = call [[REF]]* @_TFC5class1Cd([[C_CLASS]]* %0)
  // CHECK-NEXT: [[SELF_OBJ:%[a-zA-Z0-9]+]] = bitcast [[REF]]* [[SELF]] to [[C_CLASS]]*
  %1 = function_ref @_TFC5class1Cd : $@cc(method) @thin (@owned C) -> @owned Builtin.NativeObject // user: %2
  %2 = apply %1(%0) : $@cc(method) @thin (@owned C) -> @owned Builtin.NativeObject // user: %3
  %3 = unchecked_ref_cast %2 : $Builtin.NativeObject to $C // user: %4
  // CHECK-NEXT: [[SELF:%[a-zA-Z0-9]+]] = bitcast [[C_CLASS]]* [[SELF_OBJ]] to [[REF]]*
  // CHECK-NEXT: call void @swift_deallocClassInstance([[REF]]* [[SELF]], i64 16, i64 7)
  dealloc_ref %3 : $C                             // id: %4
  // CHECK-NEXT: ret void   
  %5 = tuple ()                                   // user: %6
  return %5 : $()                                 // id: %6
}

// CHECK: define [[REF]]* @unchecked_ref_cast_cast([[C_CLASS]]*)
// CHECK:   bitcast [[C_CLASS]]* {{%.*}} to [[REF]]*
sil @unchecked_ref_cast_cast : $@thin C -> Builtin.NativeObject {
entry(%c : $C):
  %r = unchecked_ref_cast %c : $C to $Builtin.NativeObject
  return %r : $Builtin.NativeObject
}

// CHECK: define [[OBJCOBJ]]* @ref_to_objc_pointer_cast([[C_CLASS]]*)
// CHECK:   bitcast [[C_CLASS]]* %0 to [[OBJCOBJ]]*
sil @ref_to_objc_pointer_cast : $@thin C -> Builtin.UnknownObject {
entry(%c : $C):
  %r = unchecked_ref_cast %c : $C to $Builtin.UnknownObject
  return %r : $Builtin.UnknownObject
}

// Part of rdar://16079147
// vtable tested above
class D {
  func multiply(#x : Builtin.Int8)(y : Builtin.Int16) -> Builtin.Int32
}

sil @_TFC5class1DD : $@cc(method) @thin (@owned D) -> () {
bb0(%0 : $D):
  %1 = tuple ()
  return %1 : $()
}

sil hidden @_TFC5class1D8multiplyfS0_fT1xBi8__FT1yBi16__Bi32_ : $@cc(method) @thin (Builtin.Int16, Builtin.Int8, @owned D) -> Builtin.Int32 {
bb0(%0 : $Builtin.Int16, %1 : $Builtin.Int8, %2 : $D):
  %3 = integer_literal $Builtin.Int32, 0
  return %3 : $Builtin.Int32
}

sil_vtable D {
  #D.multiply!2: _TFC5class1D8multiplyfS0_fT1xBi8__FT1yBi16__Bi32_
}

// CHECK-LABEL: define %C5class1C* @alloc_ref_dynamic(%swift.type*)
sil @alloc_ref_dynamic : $@thin (@thick C.Type) -> @owned C {
bb0(%0 : $@thick C.Type):
  // CHECK:   [[META_PTR:%[0-9]+]] = bitcast %swift.type* %0 to i8*
  // CHECK:   [[T0:%.*]] = getelementptr inbounds i8* [[META_PTR]], i32 48
  // CHECK:   [[T1:%.*]] = bitcast i8* [[T0]] to i32*
  // CHECK:   [[SIZE32:%.*]] = load i32* [[T1]], align 8
  // CHECK:   [[SIZE:%.*]] = zext i32 [[SIZE32]] to i64
  // CHECK:   [[T0:%.*]] = getelementptr inbounds i8* [[META_PTR]], i32 52
  // CHECK:   [[T1:%.*]] = bitcast i8* [[T0]] to i32*
  // CHECK:   [[ALIGN32:%.*]] = load i32* [[T1]], align 4
  // CHECK:   [[ALIGN:%.*]] = zext i32 [[ALIGN32]] to i64
  // CHECK:   [[RESULT:%[0-9]+]] = call noalias %swift.refcounted* @swift_allocObject(%swift.type* %0, i64 [[SIZE]], i64 [[ALIGN]])
  %1 = alloc_ref_dynamic %0 : $@thick C.Type, $C
  return %1 : $C
}

// CHECK-LABEL: define %C5class1C* @autorelease(%C5class1C*) {
// CHECK:         %1 = bitcast %C5class1C* %0 to %objc_object*
// CHECK:         call %objc_object* @objc_autorelease(%objc_object* %1)
// CHECK:         ret %C5class1C* %0
sil @autorelease : $@thin (@owned C) -> @autoreleased C {
entry(%c : $C):
  autorelease_value %c : $C
  return %c : $C
}

// CHECK-LABEL: define i64 @autorelease_optional(i64) {
// CHECK:         %1 = inttoptr i64 %0 to %objc_object*
// CHECK:         call %objc_object* @objc_autorelease(%objc_object* %1)
// CHECK:         ret i64 %0
sil @autorelease_optional : $@thin (@owned C?) -> @autoreleased C? {
entry(%c : $C?):
  autorelease_value %c : $C?
  return %c : $C?
}

// rdar://problem/19514920

class NonRequiredBase {}
class RequiredBase: NonRequiredBase {
  required override init()
}

sil public_external @init_NonRequiredBase : $@thin @cc(method) (@owned NonRequiredBase) -> @owned NonRequiredBase
sil public_external @alloc_RequiredBase : $@thin (@thick RequiredBase.Type) -> @owned RequiredBase
sil public_external @init_RequiredBase : $@thin @cc(method) (@owned RequiredBase) -> @owned RequiredBase

sil_vtable NonRequiredBase {
  #NonRequiredBase.init!initializer.1: init_NonRequiredBase
}

sil_vtable RequiredBase {
  #NonRequiredBase.init!initializer.1: init_RequiredBase
  #RequiredBase.init!allocator.1: alloc_RequiredBase
}

