// RUN: rm -rf %t/clang-module-cache
// RUN: %swift -enable-dynamic-value-type-layout -triple x86_64-apple-darwin10 -module-cache-path=%t/clang-module-cache -sdk=%S/Inputs -I=%S %s -emit-llvm | FileCheck %s

import Builtin
import swift
import gizmo

// CHECK: [[ROOTGENERIC:%C15generic_classes11RootGeneric]] = type <{ %swift.refcounted, %VSs5UInt8 }>
// CHECK: [[NONGENERICINHERITSGENERIC:%C15generic_classes25NonGenericInheritsGeneric]] = type <{ %swift.refcounted, %VSs5UInt8, [7 x i8], <{ %Si, %VSs5UInt8 }>, %VSs5UInt8, [6 x i8], %Si }>

// -- offset of RootGeneric<T>.x
// CHECK: @_TWvdC15generic_classes11RootGeneric1xVSs5UInt8 = global i64 16, align 8
// CHECK: @_TMPdC15generic_classes11RootGeneric = global { {{.*}} i64 } {
// --       field offset placeholders
// CHECK:   i64 0, i64 0, i64 0
// CHECK: }


// -- Check that offset vars are emitted for fixed-layout generics
//    <rdar://problem/15081049>
// CHECK: @_TWvdC15generic_classes22RootGenericFixedLayout1xVSs5UInt8 = global i64 16, align 8
// CHECK: @_TWvdC15generic_classes22RootGenericFixedLayout1yGSaQ__ = global i64 24, align 8
// CHECK: @_TWvdC15generic_classes22RootGenericFixedLayout1zVSs5UInt8 = global i64 48, align 8

// CHECK: @_TMdC15generic_classes14RootNonGeneric

// -- NonGenericInheritsGeneric instantiates its generic base class, giving
//    fixed offsets for its own ivars
// -- offset of NonGenericInheritsGeneric.w
// CHECK: @_TWvdC15generic_classes25NonGenericInheritsGeneric1wSi = global i64 40, align 8
// CHECK: [[NONGENERICINHERITSGENERIC_W_NAME:@.*]] = private unnamed_addr constant [2 x i8] c"w\00"
// -- ivars for NonGenericInheritsGeneric
// CHECK: @_IVARS_NonGenericInheritsGeneric = private constant { {{.*}} }] } {
// --       entsize
// CHECK:   i32 32,
// --       count
// CHECK:   i32 1,
// CHECK:   [{
// --       NonGenericInheritsGeneric.w
// --         offset ptr
// CHECK:     i64* @_TWvdC15generic_classes25NonGenericInheritsGeneric1wSi,
// --         name
// CHECK:     i8* getelementptr inbounds ([2 x i8]* [[NONGENERICINHERITSGENERIC_W_NAME]], i64 0, i64 0),
// --         type encoding (FIXME)
// CHECK:     i8* null,
// --         align
// CHECK:     i32 8,
// --         size
// CHECK:     i32 8
// CHECK:   }]
// CHECK: }
// -- rodata for NonGenericInheritsGeneric
// CHECK: @_DATA_NonGenericInheritsGeneric = private constant { {{.*}}* } {
// --       flags (128 = compiled by ARC)
// CHECK:   i32 128,
// --       instanceStart
// CHECK:   i32 40,
// --       instanceSize
// CHECK:   i32 48,
// CHECK: }
// CHECK: @_TMdC15generic_classes25NonGenericInheritsGeneric


// CHECK: @_TMPdC15generic_classes22GenericInheritsGeneric
// CHECK: @_TMPdC15generic_classes25GenericInheritsNonGeneric
// CHECK: @_TMPdCSo19GenericInheritsObjC
// CHECK: @_TMPdCSo20GenericInheritsObjC2

class RootGeneric<T> {
  var x : UInt8

  // Test that declaration order doesn't cause the field offset vector to end
  // up interleaved with the vtable.
  func foo()

  var y : T

  func bar()

  var z : UInt8

  func bas()
}

class RootGenericFixedLayout<T> {
  var x : UInt8
  var y : T[]
  var z : UInt8
}

class RootNonGeneric {
  var x : UInt8
  var y : Int
  var z : UInt8
}

class NonGenericInheritsGeneric : RootGeneric<(Int, UInt8)> {
  var w : Int
}

class GenericInheritsGeneric<A, B> : RootGeneric<A> {
  var w : B
}

class GenericInheritsNonGeneric<C> : RootNonGeneric {
  var w : UInt8
}

class GenericInheritsObjC<D> : Gizmo {
  var x : D
}

class GenericInheritsObjC2<E> : Gizmo {
  var x : UInt8
  var y : E
  var z : UInt8
}

// RootGeneric.x has fixed layout
// CHECK: define i8 @RootGeneric_concrete_fragile_dependent_member_access_x
// CHECK:   getelementptr inbounds [[ROOTGENERIC]]* %0, i32 0, i32 1
sil @RootGeneric_concrete_fragile_dependent_member_access_x : $<F> RootGeneric<F> -> UInt8 {
entry(%c : $RootGeneric<F>):
  %p = ref_element_addr %c : $RootGeneric<F>, #x
  %x = load %p : $*UInt8
  return %x : $UInt8
}

// RootGeneric.y has dependent layout; load the offset from the metadata
// CHECK: define void @RootGeneric_concrete_fragile_dependent_member_access_y
// CHECK:   [[TYPE_METADATA_ARRAY:%.*]] = bitcast %swift.type* {{%.*}} to i8***
// CHECK:   [[Y_OFFSET_ADDR:%.*]] = getelementptr inbounds i8*** [[TYPE_METADATA_ARRAY]], i64 10
// CHECK:   [[Y_OFFSET_PTR:%.*]] = load i8*** [[Y_OFFSET_ADDR]], align 8
// CHECK:   [[Y_OFFSET:%.*]] = ptrtoint i8** [[Y_OFFSET_PTR]] to i64
// CHECK:   [[CLASS_BYTE_ARRAY:%.*]] = bitcast [[ROOTGENERIC]]* {{%.*}} to i8*
// CHECK:   [[Y_ADDR:%.*]] = getelementptr inbounds i8* [[CLASS_BYTE_ARRAY]], i64 [[Y_OFFSET]]
// CHECK:   bitcast i8* [[Y_ADDR]] to %swift.opaque*
sil @RootGeneric_concrete_fragile_dependent_member_access_y : $<F> RootGeneric<F> -> F {
entry(%z : $*F, %c : $RootGeneric<F>):
  %p = ref_element_addr %c : $RootGeneric<F>, #y
  copy_addr %p to [initialization] %z : $*F
  %t = tuple ()
  return %t : $()
}

// RootGeneric.y has dependent layout; load the offset from the metadata
// CHECK: define i8 @RootGeneric_concrete_fragile_dependent_member_access_z
// CHECK:   [[TYPE_METADATA_ARRAY:%.*]] = bitcast %swift.type* {{%.*}} to i8***
// CHECK:   [[Z_OFFSET_ADDR:%.*]] = getelementptr inbounds i8*** [[TYPE_METADATA_ARRAY]], i64 11
// CHECK:   [[Z_OFFSET_PTR:%.*]] = load i8*** [[Z_OFFSET_ADDR]], align 8
// CHECK:   [[Z_OFFSET:%.*]] = ptrtoint i8** [[Z_OFFSET_PTR]] to i64
// CHECK:   [[CLASS_BYTE_ARRAY:%.*]] = bitcast [[ROOTGENERIC]]* {{%.*}} to i8*
// CHECK:   [[Z_ADDR:%.*]] = getelementptr inbounds i8* [[CLASS_BYTE_ARRAY]], i64 [[Z_OFFSET]]
// CHECK:   bitcast i8* [[Z_ADDR]] to %VSs5UInt8*
sil @RootGeneric_concrete_fragile_dependent_member_access_z : $<F> RootGeneric<F> -> UInt8 {
entry(%c : $RootGeneric<F>):
  %p = ref_element_addr %c : $RootGeneric<F>, #z
  %z = load %p : $*UInt8
  return %z : $UInt8
}

/* TODO: Instantiate types for fragile generic instances so we can do
 * fixed-layout access
sil @RootGeneric_concrete_fragile_fixed_member_access : $RootGeneric<Int32> -> (UInt8, Int32, UInt8) {
entry(%c : $RootGeneric<Int32>):
  %p = ref_element_addr %c : $RootGeneric<Int32>, #x
  %x = load %p : $*UInt8
  %q = ref_element_addr %c : $RootGeneric<Int32>, #y
  %y = load %q : $*Int32
  %r = ref_element_addr %c : $RootGeneric<Int32>, #z
  %z = load %r : $*UInt8
  %t = tuple (%x : $UInt8, %y : $Int32, %z : $UInt8)
  return %t : $(UInt8, Int32, UInt8)
}
 */

// CHECK: define i64 @NonGenericInheritsGeneric_fragile_fixed_member_access([[NONGENERICINHERITSGENERIC]]*) {
// CHECK:   %1 = getelementptr inbounds [[NONGENERICINHERITSGENERIC]]* %0, i32 0, i32 6
// CHECK:   %.value = getelementptr inbounds %Si* %1, i32 0, i32 0
// CHECK:   %2 = load i64* %.value, align 8
// CHECK:   ret i64 %2
// CHECK: }
sil @NonGenericInheritsGeneric_fragile_fixed_member_access : $NonGenericInheritsGeneric -> Int {
entry(%c : $NonGenericInheritsGeneric):
  %p = ref_element_addr %c : $NonGenericInheritsGeneric, #w
  %w = load %p : $*Int
  return %w : $Int
}

sil @top_level_code : $[thin] () -> () {
entry:
  %v = tuple ()
  return %v : $()
}
