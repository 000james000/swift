// RUN: %swift -triple x86_64-apple-darwin10 %s -emit-llvm | FileCheck %s

import Builtin

// -- Singleton union. The representation is just the singleton payload.
// CHECK: %O5union9Singleton = type { { i64, i64 } }

// -- No-payload unions. The representation is just an enum tag.
// CHECK: %O5union10NoPayloads = type { i2 }
// CHECK: %O5union11NoPayloads2 = type { i3 }

// -- Single-payload union, no extra inhabitants in the payload type. The
//    representation adds a tag bit to distinguish payload from enum tag:
//      case x(i64): X0 X1 X2 ... X63 | 0, where X0...X63 are the payload bits
//      case y:      0  0  0  ... 0   | 1
//      case z:      1  0  0  ... 0   | 1
// CHECK: %O5union17SinglePayloadNoXI = type { i64, i1 }
// CHECK: %O5union18SinglePayloadNoXI2 = type { i64, i1 }

// -- Single-payload union, spare bits. The representation uses a tag bit
//    out of the payload to distinguish payload from enum tag:
//      case x(i3): X0 X1 X2 0 0 0 0 0
//      case y:     0  0  0  1 0 0 0 0
//      case z:     1  0  0  1 0 0 0 0
// CHECK: %O5union21SinglePayloadSpareBit = type { i64 }

// -- Multi-payload union, no spare bits. The representation adds tag bits
//    to discriminate payloads. No-payload cases all share a tag.
//      case x(i8): X0 X1 X2 ... X7 X8 | 0 0
//      case y(i7): Y0 Y1 Y2 ... Y7 0  | 1 0
//      case z(i2): Z0 Z1 0  ... 0  0  | 0 1
//      case a:     0  0  0  ... 0  0  | 1 1
//      case b:     1  0  0  ... 0  0  | 1 1
//      case c:     0  1  0  ... 0  0  | 1 1
// CHECK: %O5union23MultiPayloadNoSpareBits = type { i64, i2 }

// -- Multi-payload union, one spare bit. The representation uses spare bits
//    common to all payloads to partially discriminate payloads, with added
//    tag bits to cover the gap. No-payload cases all share a tag.
//      case x(i7): X0 X1 X2 X3 X4 X5 X6 0 | 0
//      case y(i1): Y  0  0  0  0  0  0  1 | 0
//      case z(i5): Z0 Z1 Z2 Z3 Z4 0  0  0 | 1
//      case a:     0  0  0  0  0  0  0  1 | 1
//      case b:     1  0  0  0  0  0  0  1 | 1
//      case c:     0  1  0  0  0  0  0  1 | 1
// CHECK: %O5union23MultiPayloadOneSpareBit = type { i64, i1 }

// -- Multi-payload union, two spare bits. Same as above, except we have enough
//    spare bits not to require any added tag bits.
//      case x(i6): X0 X1 X2 X3 X4 X5 0  0
//      case y(i1): Y  0  0  0  0  0  1  0
//      case z(i5): Z0 Z1 Z2 Z3 Z4 0  0  1
//      case a:     0  0  0  0  0  0  1  1
//      case b:     1  0  0  0  0  0  1  1
//      case c:     0  1  0  0  0  0  1  1
// CHECK: %O5union24MultiPayloadTwoSpareBits = type { i64 }


// -- switch_union lowering --

union Singleton {
  case val(Builtin.Int64, Builtin.Int64)
}

// CHECK: define void @singleton_switch(i64, i64) {
sil @singleton_switch : $(Singleton) -> () {
// CHECK: entry:
entry(%u : $Singleton):
// CHECK:   br label %[[DEST:[0-9]+]]
  switch_union %u : $Singleton, case #Singleton.val!unionelt.1: dest

// CHECK: ; <label>:[[DEST]]
dest:
// CHECK:   ret void
  %x = tuple ()
  return %x : $()
}

// CHECK: define void @singleton_switch_arg(i64, i64) {
sil @singleton_switch_arg : $(Singleton) -> () {
// CHECK: entry:
entry(%u : $Singleton):
// CHECK:   br label %[[PREDEST:[0-9]+]]
  switch_union %u : $Singleton, case #Singleton.val!unionelt.1: dest

// CHECK: ; <label>:[[PREDEST]]
// CHECK:   br label %[[DEST:[0-9]+]]
// CHECK: ; <label>:[[DEST]]
dest(%u2 : $(Builtin.Int64, Builtin.Int64)):
// CHECK:   {{%.*}} = phi i64 [ %0, %[[PREDEST]] ]
// CHECK:   {{%.*}} = phi i64 [ %1, %[[PREDEST]] ]
// CHECK:   ret void
  %x = tuple ()
  return %x : $()
}


union NoPayloads {
  case x
  case y
  case z
}

sil @a : $[thin] () -> ()
sil @b : $[thin] () -> ()
sil @c : $[thin] () -> ()
sil @d : $[thin] () -> ()
sil @e : $[thin] () -> ()
sil @f : $[thin] () -> ()


// CHECK: define void @no_payload_switch(i2) {
sil @no_payload_switch : $[thin] (NoPayloads) -> () {
// CHECK: entry:
entry(%u : $NoPayloads):
// CHECK:   switch i2 %0, label %[[DFLT:[0-9]+]] [
// CHECK:     i2 0, label %[[X_DEST:[0-9]+]]
// CHECK:     i2 1, label %[[Y_DEST:[0-9]+]]
// CHECK:     i2 -2, label %[[Z_DEST:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[DFLT]]
// CHECK:   unreachable
  switch_union %u : $NoPayloads, case #NoPayloads.x!unionelt: x_dest, case #NoPayloads.y!unionelt: y_dest, case #NoPayloads.z!unionelt: z_dest

// CHECK: ; <label>:[[X_DEST]]
x_dest:
// CHECK:   call void @a()
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
// CHECK:   br label %[[END:[0-9]+]]
  br end
// CHECK: ; <label>:[[Y_DEST]]
y_dest:
// CHECK:   call void @b()
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end
// CHECK: ; <label>:[[Z_DEST]]
z_dest:
// CHECK:   call void @c()
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end

// CHECK: ; <label>:[[END]]
end:
// CHECK:   ret void
  %x = tuple ()
  return %x : $()
}


union NoPayloads2 {
  case a
  case e
  case i
  case o
  case u
  case y
}

// CHECK: define void @no_payload_switch_2(i3) {
sil @no_payload_switch_2 : $[thin] (NoPayloads2) -> () {
// CHECK: entry:
entry(%u : $NoPayloads2):
// CHECK:   switch i3 %0, label %[[DEFAULT_DEST:[0-9]+]] [
// CHECK:     i3 -4, label %[[U_DEST:[0-9]+]]
// CHECK:   ]
  switch_union %u : $NoPayloads2, case #NoPayloads2.u!unionelt: u_dest, default default_dest

// CHECK: ; <label>:[[U_DEST]]
u_dest:
// CHECK:   call void @a()
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
// CHECK:   br label %[[END:[0-9]+]]
  br end

// CHECK: ; <label>:[[DEFAULT_DEST]]
default_dest:
// CHECK:   call void @b()
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end

// CHECK: ; <label>:[[END]]
end:
// CHECK:   ret void
  %x = tuple ()
  return %x : $()
}


union SinglePayloadNoXI {
  case x(Builtin.Int64)
  case y
}

union SinglePayloadNoXI2 {
  case x(Builtin.Int64)
  case y
  case z
}

// CHECK: define void @single_payload_no_xi_switch(i64, i1) {
sil @single_payload_no_xi_switch : $[thin] (SinglePayloadNoXI2) -> () {
// CHECK: entry:
entry(%u : $SinglePayloadNoXI2):
// CHECK:   switch i1 %1, label %[[DFLT:[0-9]+]] [
// CHECK:     i1 false, label %[[X_DEST:[0-9]+]]
// CHECK:     i1 true, label %[[TAGS:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[TAGS]]
// CHECK:   switch i64 %0, label %[[DFLT]] [
// CHECK:     i64 0, label %[[Y_DEST:[0-9]+]]
// CHECK:     i64 1, label %[[Z_DEST:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[DFLT]]
// CHECK:   unreachable
  switch_union %u : $SinglePayloadNoXI2, case #SinglePayloadNoXI2.x!unionelt.1: x_dest, case #SinglePayloadNoXI2.y!unionelt: y_dest, case #SinglePayloadNoXI2.z!unionelt: z_dest

// CHECK: ; <label>:[[X_DEST]]
// CHECK:   call void @a()
// CHECK:   br label %[[END:[0-9]+]]
x_dest:
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[Y_DEST]]
// CHECK:   call void @b()
// CHECK:   br label %[[END]]
y_dest:
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[Z_DEST]]
// CHECK:   call void @c()
// CHECK:   br label %[[END]]
z_dest:
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[END]]
// CHECK:   ret void
end:
  %x = tuple ()
  return %x : $()
}

// CHECK: define void @single_payload_no_xi_switch_arg(i64, i1) {
sil @single_payload_no_xi_switch_arg : $[thin] (SinglePayloadNoXI2) -> () {
// CHECK: entry:
entry(%u : $SinglePayloadNoXI2):
// CHECK:   switch i1 %1, label %[[DFLT:[0-9]+]] [
// CHECK:     i1 false, label %[[X_PREDEST:[0-9]+]]
// CHECK:     i1 true, label %[[TAGS:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[TAGS]]
// CHECK:   switch i64 %0, label %[[DFLT]] [
// CHECK:     i64 0, label %[[Y_DEST:[0-9]+]]
// CHECK:     i64 1, label %[[Z_DEST:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[DFLT]]
// CHECK:   unreachable
  switch_union %u : $SinglePayloadNoXI2, case #SinglePayloadNoXI2.x!unionelt.1: x_dest, case #SinglePayloadNoXI2.y!unionelt: y_dest, case #SinglePayloadNoXI2.z!unionelt: z_dest

// CHECK: ; <label>:[[X_PREDEST]]
// CHECK:   br label %[[X_DEST:[0-9]+]]
// CHECK: ; <label>:[[X_DEST]]
// CHECK:   {{%.*}} = phi i64 [ %0, %[[X_PREDEST]] ]
x_dest(%u2 : $Builtin.Int64):
// CHECK:   call void @a()
// CHECK:   br label %[[END:[0-9]+]]
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[Y_DEST]]
y_dest:
// CHECK:   call void @b()
// CHECK:   br label %[[END]]
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[Z_DEST]]
z_dest:
// CHECK:   call void @c()
// CHECK:   br label %[[END]]
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[END]]
// CHECK:   ret void
end:
  %x = tuple ()
  return %x : $()
}


// -- Test unpacking aggregates.

union AggregateSinglePayload {
  case x(Builtin.Int21, Builtin.Int64)
  case y
  case z
}

// CHECK: define void @aggregate_single_payload_unpack(i128, i1) {
sil @aggregate_single_payload_unpack : $[thin] (AggregateSinglePayload) -> () {
entry(%u : $AggregateSinglePayload):
  switch_union %u : $AggregateSinglePayload, case #AggregateSinglePayload.x!unionelt.1: x_dest, default end

// CHECK:   {{%.*}} = trunc i128 %0 to i21
// CHECK:   [[SHIFT_1:%.*]] = lshr i128 %0, 64
// CHECK:   {{%.*}} = trunc i128 [[SHIFT_1]] to i64
x_dest(%v : $(Builtin.Int21, Builtin.Int64)):
  br end

end:
  %x = tuple ()
  return %x : $()
}

struct CharLike { var value : Builtin.Int21 }
struct IntLike { var value : Builtin.Int64 }
struct RangeLike { var from, to : Builtin.Int64 }

union AggregateSinglePayload2 {
  case x(CharLike, IntLike, RangeLike)
  case y
  case z
}

// CHECK: define void @aggregate_single_payload_unpack_2(i256, i1) {
sil @aggregate_single_payload_unpack_2 : $[thin] (AggregateSinglePayload2) -> () {
entry(%u : $AggregateSinglePayload2):
  switch_union %u : $AggregateSinglePayload2, case #AggregateSinglePayload2.x!unionelt.1: x_dest, default end

// CHECK:   {{%.*}} = trunc i256 %0 to i21
// CHECK:   [[SHIFT_1:%.*]] = lshr i256 %0, 64
// CHECK:   {{%.*}} = trunc i256 [[SHIFT_1]] to i64
// CHECK:   [[SHIFT_2_FROM:%.*]] = lshr i256 %0, 128
// CHECK:   {{%.*}} = trunc i256 [[SHIFT_2_FROM]] to i64
// CHECK:   [[SHIFT_2_TO:%.*]] = lshr i256 %0, 192
// CHECK:   {{%.*}} = trunc i256 [[SHIFT_2_TO]] to i64
x_dest(%v : $(CharLike, IntLike, RangeLike)):
  br end

end:
  %x = tuple ()
  return %x : $()
}



union SinglePayloadSpareBit {
  case x(Builtin.Int63)
  case y
  case z
}

// CHECK: define void @single_payload_spare_bit_switch(i64) {
sil @single_payload_spare_bit_switch : $[thin] (SinglePayloadSpareBit) -> () {
// CHECK: entry:
entry(%u : $SinglePayloadSpareBit):
// CHECK:  switch i64 %0, label %[[X_DEST:[0-9]+]] [
// --           0x8000_0000_0000_0000
// CHECK:    i64 -9223372036854775808, label %[[Y_DEST:[0-9]+]]
// --           0x8000_0000_0000_0001
// CHECK:    i64 -9223372036854775807, label %[[Z_DEST:[0-9]+]]
// CHECK:  ]
  switch_union %u : $SinglePayloadSpareBit, case #SinglePayloadSpareBit.x!unionelt.1: x_dest, case #SinglePayloadSpareBit.y!unionelt: y_dest, case #SinglePayloadSpareBit.z!unionelt: z_dest

// CHECK: ; <label>:[[X_DEST]]
x_dest:
// CHECK:   call void @a()
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
// CHECK:   br label %[[END:[0-9]+]]
  br end

// CHECK: ; <label>:[[Y_DEST]]
y_dest:
// CHECK:   call void @b()
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end

// CHECK: ; <label>:[[Z_DEST]]
z_dest:
// CHECK:   call void @c()
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end

// CHECK: ; <label>:[[END]]
end:
// CHECK:   ret void
  %x = tuple ()
  return %x : $()
}

// CHECK: define void @single_payload_spare_bit_switch_arg(i64) {
sil @single_payload_spare_bit_switch_arg : $[thin] (SinglePayloadSpareBit) -> () {
// CHECK: entry:
entry(%u : $SinglePayloadSpareBit):
// CHECK:  switch i64 %0, label %[[X_PREDEST:[0-9]+]] [
// --           0x8000_0000_0000_0000
// CHECK:    i64 -9223372036854775808, label %[[Y_DEST:[0-9]+]]
// --           0x8000_0000_0000_0001
// CHECK:    i64 -9223372036854775807, label %[[Z_DEST:[0-9]+]]
// CHECK:  ]
  switch_union %u : $SinglePayloadSpareBit, case #SinglePayloadSpareBit.x!unionelt.1: x_dest, case #SinglePayloadSpareBit.y!unionelt: y_dest, case #SinglePayloadSpareBit.z!unionelt: z_dest

// CHECK: ; <label>:[[X_PREDEST]]
// CHECK:   [[TRUNC_PAYLOAD:%.*]] = trunc i64 %0 to i63
// CHECK:   br label %[[X_DEST:[0-9]+]]
// CHECK: ; <label>:[[X_DEST]]
// CHECK:   {{%.*}} = phi i63 [ [[TRUNC_PAYLOAD]], %[[X_PREDEST]] ]
x_dest(%u2 : $Builtin.Int63):
// CHECK:   call void @a()
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
// CHECK:   br label %[[END:[0-9]+]]
  br end

// CHECK: ; <label>:[[Y_DEST]]
y_dest:
// CHECK:   call void @b()
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end

// CHECK: ; <label>:[[Z_DEST]]
z_dest:
// CHECK:   call void @c()
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
// CHECK:   br label %[[END]]
  br end

// CHECK: ; <label>:[[END]]
end:
// CHECK:   ret void
  %x = tuple ()
  return %x : $()
}


union MultiPayloadNoSpareBits {
  case x(Builtin.Int64)
  case y(Builtin.Int32)
  case z(Builtin.Int63)
  case a
  case b
  case c
}

// CHECK: define void @multi_payload_no_spare_bits_switch(i64, i2) {
sil @multi_payload_no_spare_bits_switch : $(MultiPayloadNoSpareBits) -> () {
entry(%u : $MultiPayloadNoSpareBits):
// CHECK:   switch i2 %1, label %[[UNREACHABLE:[0-9]+]] [
// CHECK:     i2 0, label %[[X_DEST:[0-9]+]]
// CHECK:     i2 1, label %[[Y_DEST:[0-9]+]]
// CHECK:     i2 -2, label %[[Z_DEST:[0-9]+]]
// CHECK:     i2 -1, label %[[EMPTY:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[EMPTY]]
// CHECK:   switch i64 %0, label %[[UNREACHABLE]] [
// CHECK:     i64 0, label %[[A_DEST:[0-9]+]]
// CHECK:     i64 1, label %[[B_DEST:[0-9]+]]
// CHECK:     i64 2, label %[[C_DEST:[0-9]+]]
// CHECK:   ]
// CHECK: ; <label>:[[UNREACHABLE]]
// CHECK:   unreachable
  switch_union %u : $MultiPayloadNoSpareBits, case #MultiPayloadNoSpareBits.x!unionelt.1: x_dest, case #MultiPayloadNoSpareBits.y!unionelt.1: y_dest, case #MultiPayloadNoSpareBits.z!unionelt.1: z_dest, case #MultiPayloadNoSpareBits.a!unionelt: a_dest, case #MultiPayloadNoSpareBits.b!unionelt: b_dest, case #MultiPayloadNoSpareBits.c!unionelt: c_dest

// CHECK: ; <label>:[[X_DEST]]
x_dest:
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[Y_DEST]]
y_dest:
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[Z_DEST]]
z_dest:
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[A_DEST]]
a_dest:
  %d = function_ref @d : $[thin] () -> ()
  apply %d() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[B_DEST]]
b_dest:
  %e = function_ref @e : $[thin] () -> ()
  apply %e() : $[thin] () -> ()
  br end

// CHECK: ; <label>:[[C_DEST]]
c_dest:
  %f = function_ref @f : $[thin] () -> ()
  apply %f() : $[thin] () -> ()
  br end

end:
  %x = tuple ()
  return %x : $()
}


union MultiPayloadOneSpareBit {
  case x(Builtin.Int62)
  case y(Builtin.Int63)
  case z(Builtin.Int61)
  case a
  case b
  case c
}

sil @multi_payload_one_spare_bit_switch : $(MultiPayloadOneSpareBit) -> () {
entry(%u : $MultiPayloadOneSpareBit):
  switch_union %u : $MultiPayloadOneSpareBit, case #MultiPayloadOneSpareBit.x!unionelt.1: x_dest, case #MultiPayloadOneSpareBit.y!unionelt.1: y_dest, case #MultiPayloadOneSpareBit.z!unionelt.1: z_dest, case #MultiPayloadOneSpareBit.a!unionelt: a_dest, case #MultiPayloadOneSpareBit.b!unionelt: b_dest, case #MultiPayloadOneSpareBit.c!unionelt: c_dest

x_dest:
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
  br end

y_dest:
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
  br end

z_dest:
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
  br end

a_dest:
  %d = function_ref @d : $[thin] () -> ()
  apply %d() : $[thin] () -> ()
  br end

b_dest:
  %e = function_ref @e : $[thin] () -> ()
  apply %e() : $[thin] () -> ()
  br end

c_dest:
  %f = function_ref @f : $[thin] () -> ()
  apply %f() : $[thin] () -> ()
  br end

end:
  %x = tuple ()
  return %x : $()
}


union MultiPayloadTwoSpareBits {
  case x(Builtin.Int62)
  case y(Builtin.Int60)
  case z(Builtin.Int61)
  case a
  case b
  case c
}

sil @multi_payload_two_spare_bits_switch : $(MultiPayloadTwoSpareBits) -> () {
entry(%u : $MultiPayloadTwoSpareBits):
  switch_union %u : $MultiPayloadTwoSpareBits, case #MultiPayloadTwoSpareBits.x!unionelt.1: x_dest, case #MultiPayloadTwoSpareBits.y!unionelt.1: y_dest, case #MultiPayloadTwoSpareBits.z!unionelt.1: z_dest, case #MultiPayloadTwoSpareBits.a!unionelt: a_dest, case #MultiPayloadTwoSpareBits.b!unionelt: b_dest, case #MultiPayloadTwoSpareBits.c!unionelt: c_dest

x_dest:
  %a = function_ref @a : $[thin] () -> ()
  apply %a() : $[thin] () -> ()
  br end

y_dest:
  %b = function_ref @b : $[thin] () -> ()
  apply %b() : $[thin] () -> ()
  br end

z_dest:
  %c = function_ref @c : $[thin] () -> ()
  apply %c() : $[thin] () -> ()
  br end

a_dest:
  %d = function_ref @d : $[thin] () -> ()
  apply %d() : $[thin] () -> ()
  br end

b_dest:
  %e = function_ref @e : $[thin] () -> ()
  apply %e() : $[thin] () -> ()
  br end

c_dest:
  %f = function_ref @f : $[thin] () -> ()
  apply %f() : $[thin] () -> ()
  br end

end:
  %x = tuple ()
  return %x : $()
}




// -- injection functions for unions --

// CHECK: define { i64, i64 } @_TO5union9Singleton3valfMS0_FTBi64_Bi64__S0_(i64, i64) {
// CHECK: entry:
// CHECK:   [[A:%.*]] = insertvalue { i64, i64 } undef, i64 %0, 0
// CHECK:   [[B:%.*]] = insertvalue { i64, i64 } [[A]], i64 %1, 1
// CHECK:   ret { i64, i64 } [[B]]
// CHECK: }


// CHECK: define i2 @_TO5union10NoPayloads1xFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i2 0
// CHECK: }

// CHECK: define i2 @_TO5union10NoPayloads1yFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i2 1
// CHECK: }

// CHECK: define i2 @_TO5union10NoPayloads1zFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i2 -2
// CHECK: }


// CHECK: define i3 @_TO5union11NoPayloads21aFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i3 0
// CHECK: }

// CHECK: define i3 @_TO5union11NoPayloads21eFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i3 1
// CHECK: }

// CHECK: define i3 @_TO5union11NoPayloads21iFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i3 2
// CHECK: }

// CHECK: define i3 @_TO5union11NoPayloads21oFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i3 3
// CHECK: }

// CHECK: define i3 @_TO5union11NoPayloads21uFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i3 -4
// CHECK: }

// CHECK: define i3 @_TO5union11NoPayloads21yFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret i3 -3
// CHECK: }


// CHECK: define { i64, i1 } @_TO5union17SinglePayloadNoXI1xfMS0_FBi64_S0_(i64) {
// CHECK: entry:
// CHECK:   [[A:%.*]] = insertvalue { i64, i1 } undef, i64 %0, 0
// CHECK:   [[B:%.*]] = insertvalue { i64, i1 } [[A]], i1 false, 1
// CHECK:   ret { i64, i1 } [[B]]
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union17SinglePayloadNoXI1yFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i64, i1 } { i64 0, i1 true }
// CHECK: }


// CHECK: define { i64, i1 } @_TO5union18SinglePayloadNoXI21xfMS0_FBi64_S0_(i64) {
// CHECK: entry:
// CHECK:   [[A:%.*]] = insertvalue { i64, i1 } undef, i64 %0, 0
// CHECK:   [[B:%.*]] = insertvalue { i64, i1 } [[A]], i1 false, 1
// CHECK:   ret { i64, i1 } [[B]]
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union18SinglePayloadNoXI21yFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i64, i1 } { i64 0, i1 true }
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union18SinglePayloadNoXI21zFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i64, i1 } { i64 1, i1 true }
// CHECK: }


// CHECK: define { i128, i1 } @_TO5union22AggregateSinglePayload1xfMS0_FTBi21_Bi64__S0_(i21, i64) {
// CHECK: entry:
// CHECK:   [[ZEXT_0:%.*]] = zext i21 %0 to i128
// CHECK:   [[ZEXT_1:%.*]] = zext i64 %1 to i128
// CHECK:   [[SHIFT_1:%.*]] = shl i128 [[ZEXT_1]], 64
// CHECK:   [[PAYLOAD:%.*]] = or i128 [[ZEXT_0]], [[SHIFT_1]]
// CHECK:   [[RES_0:%.*]] = insertvalue { i128, i1 } undef, i128 [[PAYLOAD]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i128, i1 } [[RES_0]], i1 false, 1
// CHECK:   ret { i128, i1 } [[RES]]
// CHECK: }

// CHECK: define { i128, i1 } @_TO5union22AggregateSinglePayload1yFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i128, i1 } { i128 0, i1 true }
// CHECK: }

// CHECK: define { i128, i1 } @_TO5union22AggregateSinglePayload1zFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i128, i1 } { i128 1, i1 true }
// CHECK: }


// CHECK: define { i256, i1 } @_TO5union23AggregateSinglePayload21xfMS0_FTVS_8CharLikeVS_7IntLikeVS_9RangeLike_S0_(i21, i64, i64, i64) {
// CHECK: entry:
// CHECK:   [[ZEXT_0:%.*]] = zext i21 %0 to i256
// CHECK:   [[ZEXT_1:%.*]] = zext i64 %1 to i256
// CHECK:   [[SHIFT_1:%.*]] = shl i256 [[ZEXT_1]], 64
// CHECK:   [[PAYLOAD_0_1:%.*]] = or i256 [[ZEXT_0]], [[SHIFT_1]]
// CHECK:   [[ZEXT_2_FROM:%.*]] = zext i64 %2 to i256
// CHECK:   [[SHIFT_2_FROM:%.*]] = shl i256 [[ZEXT_2_FROM]], 128
// CHECK:   [[ZEXT_2_TO:%.*]] = zext i64 %3 to i256
// CHECK:   [[SHIFT_2_TO:%.*]] = shl i256 [[ZEXT_2_TO]], 192
// CHECK:   [[PAYLOAD_2:%.*]] = or i256 [[SHIFT_2_FROM]], [[SHIFT_2_TO]]
// CHECK:   [[PAYLOAD:%.*]] = or i256 [[PAYLOAD_0_1]], [[PAYLOAD_2]]
// CHECK:   [[RES_0:%.*]] = insertvalue { i256, i1 } undef, i256 [[PAYLOAD]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i256, i1 } [[RES_0]], i1 false, 1
// CHECK:   ret { i256, i1 } [[RES]]
// CHECK: }

// CHECK: define { i256, i1 } @_TO5union23AggregateSinglePayload21yFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i256, i1 } { i256 0, i1 true }
// CHECK: }

// CHECK: define { i256, i1 } @_TO5union23AggregateSinglePayload21zFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i256, i1 } { i256 1, i1 true }
// CHECK: }


// CHECK: define i64 @_TO5union21SinglePayloadSpareBit1xfMS0_FBi63_S0_(i63) {
// CHECK: entry:
// CHECK:   [[A:%.*]] = zext i63 %0 to i64
// CHECK:   ret i64 [[A]]
// CHECK: }

// CHECK: define i64 @_TO5union21SinglePayloadSpareBit1yFMS0_S0_() {
// CHECK: entry:
//                 0x8000_0000_0000_0000
// CHECK:   ret i64 -9223372036854775808
// CHECK: }

// CHECK: define i64 @_TO5union21SinglePayloadSpareBit1zFMS0_S0_() {
// CHECK: entry:
//                 0x8000_0000_0000_0001
// CHECK:   ret i64 -9223372036854775807
// CHECK: }


// CHECK: define { i64, i2 } @_TO5union23MultiPayloadNoSpareBits1xfMS0_FBi64_S0_(i64) {
// CHECK: entry:
// CHECK:   [[RES_0:%.*]] = insertvalue { i64, i2 } undef, i64 %0, 0
// CHECK:   [[RES:%.*]] = insertvalue { i64, i2 } [[RES_0]], i2 0, 1
// CHECK:   ret { i64, i2 } [[RES]]
// CHECK: }

// CHECK: define { i64, i2 } @_TO5union23MultiPayloadNoSpareBits1yfMS0_FBi32_S0_(i32) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i32 %0 to i64
// CHECK:   [[RES_0:%.*]] = insertvalue { i64, i2 } undef, i64 [[ZEXT]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i64, i2 } [[RES_0]], i2 1, 1
// CHECK:   ret { i64, i2 } [[RES]]
// CHECK: }

// CHECK: define { i64, i2 } @_TO5union23MultiPayloadNoSpareBits1zfMS0_FBi63_S0_(i63) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i63 %0 to i64
// CHECK:   [[RES_0:%.*]] = insertvalue { i64, i2 } undef, i64 [[ZEXT]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i64, i2 } [[RES_0]], i2 -2, 1
// CHECK:   ret { i64, i2 } [[RES]]
// CHECK: }

// CHECK: define { i64, i2 } @_TO5union23MultiPayloadNoSpareBits1aFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i64, i2 } { i64 0, i2 -1 }
// CHECK: }

// CHECK: define { i64, i2 } @_TO5union23MultiPayloadNoSpareBits1bFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i64, i2 } { i64 1, i2 -1 }
// CHECK: }

// CHECK: define { i64, i2 } @_TO5union23MultiPayloadNoSpareBits1cFMS0_S0_() {
// CHECK: entry:
// CHECK:   ret { i64, i2 } { i64 2, i2 -1 }
// CHECK: }


// CHECK: define { i64, i1 } @_TO5union23MultiPayloadOneSpareBit1xfMS0_FBi62_S0_(i62) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i62 %0 to i64
// CHECK:   [[RES_0:%.*]] = insertvalue { i64, i1 } undef, i64 [[ZEXT]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i64, i1 } [[RES_0]], i1 false, 1
// CHECK:   ret { i64, i1 } [[RES]]
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union23MultiPayloadOneSpareBit1yfMS0_FBi63_S0_(i63) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i63 %0 to i64
// --                                        0x8000_0000_0000_0000
// CHECK:   [[TAGGED:%.*]] = or i64 [[ZEXT]], -9223372036854775808
// CHECK:   [[RES_0:%.*]] = insertvalue { i64, i1 } undef, i64 [[TAGGED]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i64, i1 } [[RES_0]], i1 false, 1
// CHECK:   ret { i64, i1 } [[RES]]
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union23MultiPayloadOneSpareBit1zfMS0_FBi61_S0_(i61) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i61 %0 to i64
// CHECK:   [[RES_0:%.*]] = insertvalue { i64, i1 } undef, i64 [[ZEXT]], 0
// CHECK:   [[RES:%.*]] = insertvalue { i64, i1 } [[RES_0]], i1 true, 1
// CHECK:   ret { i64, i1 } [[RES]]
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union23MultiPayloadOneSpareBit1aFMS0_S0_() {
// CHECK: entry:
// --                            0x8000_0000_0000_0000
// CHECK:   ret { i64, i1 } { i64 -9223372036854775808, i1 true }
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union23MultiPayloadOneSpareBit1bFMS0_S0_() {
// CHECK: entry:
// --                            0x8000_0000_0000_0001
// CHECK:   ret { i64, i1 } { i64 -9223372036854775807, i1 true }
// CHECK: }

// CHECK: define { i64, i1 } @_TO5union23MultiPayloadOneSpareBit1cFMS0_S0_() {
// CHECK: entry:
// --                            0x8000_0000_0000_0002
// CHECK:   ret { i64, i1 } { i64 -9223372036854775806, i1 true }
// CHECK: }


// CHECK: define i64 @_TO5union24MultiPayloadTwoSpareBits1xfMS0_FBi62_S0_(i62) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i62 %0 to i64
// CHECK:   ret i64 [[ZEXT]]
// CHECK: }

// CHECK: define i64 @_TO5union24MultiPayloadTwoSpareBits1yfMS0_FBi60_S0_(i60) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i60 %0 to i64
// --                     0x4000_0000_0000_0000
// CHECK:   [[TAGGED:%.*]] = or i64 [[ZEXT]], 4611686018427387904
// CHECK:   ret i64 [[TAGGED]]
// CHECK: }

// CHECK: define i64 @_TO5union24MultiPayloadTwoSpareBits1zfMS0_FBi61_S0_(i61) {
// CHECK: entry:
// CHECK:   [[ZEXT:%.*]] = zext i61 %0 to i64
// --                      0x8000_0000_0000_0000
// CHECK:   [[TAGGED:%.*]] = or i64 [[ZEXT]], -9223372036854775808
// CHECK:   ret i64 [[TAGGED]]
// CHECK: }

// CHECK: define i64 @_TO5union24MultiPayloadTwoSpareBits1aFMS0_S0_() {
// CHECK: entry:
// --              0xC000_0000_0000_0000
// CHECK:   ret i64 -4611686018427387904
// CHECK: }

// CHECK: define i64 @_TO5union24MultiPayloadTwoSpareBits1bFMS0_S0_() {
// CHECK: entry:
// --              0xC000_0000_0000_0001
// CHECK:   ret i64 -4611686018427387903
// CHECK: }

// CHECK: define i64 @_TO5union24MultiPayloadTwoSpareBits1cFMS0_S0_() {
// CHECK: entry:
// --              0xC000_0000_0000_0002
// CHECK:   ret i64 -4611686018427387902
// CHECK: }


// Force the storage types to all be generated.
typealias AllTestUnions = (
  Singleton,
  NoPayloads,
  NoPayloads2,
  SinglePayloadNoXI,
  SinglePayloadNoXI2,
  SinglePayloadSpareBit,
  MultiPayloadNoSpareBits,
  MultiPayloadOneSpareBit,
  MultiPayloadTwoSpareBits)

var x : AllTestUnions

sil @top_level_code : $() -> () {
entry:
  // Force the global variables to materialize.
  %x = global_addr #x : $*AllTestUnions
  initialize_var %x : $*AllTestUnions
  %z = tuple ()
  return %z : $()
}
