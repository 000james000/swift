// RUN: %swift -triple x86_64-apple-darwin10 %s -emit-llvm -enable-dynamic-value-type-layout | FileCheck %s

import Builtin

// -- Generic structs with dynamic layout contain the vwtable pattern as part
//    of the metadata pattern, and no independent vwtable symbol
// CHECK-NOT: @_TWVV15generic_structs13SingleDynamic
// CHECK: @_TMPdV15generic_structs13SingleDynamic = global {{[{].*\* [}]}} {
// -- template header
// CHECK:   void (i8*, i8*)* [[SINGLE_DYNAMIC_FILL_METADATA:@fill_generic_metadata[0-9]*]],
// CHECK:   i32 176, i16 1, i16 8, [8 x i8*] zeroinitializer,
// -- placeholder for vwtable pointer
// CHECK:   i8* null,
// -- address point
// CHECK:   i64 1, i8* null, %swift.type* null, i64 0, %swift.type* null,
// -- tail-allocated vwtable pattern
// CHECK:   i8* bitcast (void ([24 x i8]*, %swift.type*)* @_TwXXV15generic_structs13SingleDynamic to i8*),
// -- ...
// -- placeholder for size, flags, stride
// CHECK:   i8* null, i8* null, i8* null }
// CHECK-NOT: @_TWVV15generic_structs13SingleDynamic

// -- Fixed-layout struct metadata contains fixed field offsets
// CHECK: @_TMdV15generic_structs6Intish = constant { {{.*}} i64 } {
// CHECK:   i64 0
// CHECK: }
// CHECK: @_TMdV15generic_structs7Chareth = constant { {{.*}} i64 } {
// CHECK:   i64 0
// CHECK: }
// CHECK: @_TMdV15generic_structs8Stringly = constant { {{.*}} i64, i64, i64 } {
// CHECK:   i64 0, i64 8, i64 16
// CHECK: }


struct SingleDynamic<T> {
  var x : T
}

struct Intish { var value : Builtin.Int64 }
struct Chareth { var value : Builtin.Int21 }
struct Byteful { var value : Builtin.Int8 }
struct Stringly {
  var owner : Builtin.ObjectPointer
  var base : Builtin.RawPointer
  var size : Builtin.Int64
}

// CHECK-LABEL: define { i64, i21 } @concrete_instances(i64, i21) {
// CHECK: entry:
// CHECK:   %2 = insertvalue { i64, i21 } undef, i64 %0, 0
// CHECK:   %3 = insertvalue { i64, i21 } %2, i21 %1, 1
// CHECK:   ret { i64, i21 } %3
// CHECK: }
sil @concrete_instances : $(SingleDynamic<Intish>, SingleDynamic<Chareth>) -> (Intish, Chareth) {
entry(%0 : $SingleDynamic<Intish>, %1 : $SingleDynamic<Chareth>):
  %a = struct_extract %0 : $SingleDynamic<Intish>, #x
  %b = struct_extract %1 : $SingleDynamic<Chareth>, #x
  %c = tuple (%a : $Intish, %b : $Chareth)
  return %c : $(Intish, Chareth)
}

struct ComplexDynamic<U, V> {
  var a, a2 : Byteful
  var b : U
  var c : SingleDynamic<V>
  var d : Chareth
}

// CHECK-LABEL: define void @explode_complex_dynamic
sil @explode_complex_dynamic : $<A, B> (ComplexDynamic<A, B>, [inout] Byteful, [inout] A, [inout] B, [inout] Chareth) -> () {
entry(%0 : $*ComplexDynamic<A, B>, %1 : $*Byteful, %2 : $*A, %3 : $*B, %4 : $*Chareth):
  %a = struct_element_addr %0 : $*ComplexDynamic<A, B>, #a2

  // CHECK: [[METADATA:%.*]] = bitcast %swift.type* {{%.*}} to i64*
  // CHECK: [[FIELD_OFFSET_VECTOR:%.*]] = getelementptr inbounds i64* [[METADATA]], i32 3
  // CHECK: [[FIELD_OFFSET_ADDR:%.*]] = getelementptr inbounds i64* [[FIELD_OFFSET_VECTOR]], i32 2
  // CHECK: [[FIELD_OFFSET:%.*]] = load i64* [[FIELD_OFFSET_ADDR]], align 8
  // CHECK: [[BYTES:%.*]] = bitcast %V15generic_structs14ComplexDynamic* %0 to i8*
  // CHECK: [[BYTE_OFFSET:%.*]] = getelementptr inbounds i8* [[BYTES]], i64 [[FIELD_OFFSET]]
  // CHECK: bitcast i8* [[BYTE_OFFSET]] to %swift.opaque*
  %b = struct_element_addr %0 : $*ComplexDynamic<A, B>, #b

  // CHECK: [[METADATA:%.*]] = bitcast %swift.type* {{%.*}} to i64*
  // CHECK: [[FIELD_OFFSET_VECTOR:%.*]] = getelementptr inbounds i64* [[METADATA]], i32 3
  // CHECK: [[FIELD_OFFSET_ADDR:%.*]] = getelementptr inbounds i64* [[FIELD_OFFSET_VECTOR]], i32 3
  // CHECK: [[FIELD_OFFSET:%.*]] = load i64* [[FIELD_OFFSET_ADDR]], align 8
  // CHECK: [[BYTES:%.*]] = bitcast %V15generic_structs14ComplexDynamic* %0 to i8*
  // CHECK: [[BYTE_OFFSET:%.*]] = getelementptr inbounds i8* [[BYTES]], i64 [[FIELD_OFFSET]]
  // CHECK: bitcast i8* [[BYTE_OFFSET]] to %V15generic_structs13SingleDynamic
  %5 = struct_element_addr %0 : $*ComplexDynamic<A, B>, #c
  %c = struct_element_addr %5 : $*SingleDynamic<B>, #x

  // CHECK: [[METADATA:%.*]] = bitcast %swift.type* {{%.*}} to i64*
  // CHECK: [[FIELD_OFFSET_VECTOR:%.*]] = getelementptr inbounds i64* [[METADATA]], i32 3
  // CHECK: [[FIELD_OFFSET_ADDR:%.*]] = getelementptr inbounds i64* [[FIELD_OFFSET_VECTOR]], i32 4
  // CHECK: [[FIELD_OFFSET:%.*]] = load i64* [[FIELD_OFFSET_ADDR]], align 8
  // CHECK: [[BYTES:%.*]] = bitcast %V15generic_structs14ComplexDynamic* %0 to i8*
  // CHECK: [[BYTE_OFFSET:%.*]] = getelementptr inbounds i8* [[BYTES]], i64 [[FIELD_OFFSET]]
  // CHECK: bitcast i8* [[BYTE_OFFSET]] to %V15generic_structs7Chareth
  %d = struct_element_addr %0 : $*ComplexDynamic<A, B>, #d
  copy_addr %a to %1 : $*Byteful
  copy_addr %b to %2 : $*A
  copy_addr %c to %3 : $*B
  copy_addr %d to %4 : $*Chareth
  %v = tuple ()
  return %v : $()
}

sil @top_level_code : $() -> () {
entry:
  %0 = tuple ()
  return %0 : $()
}

// CHECK: define linkonce_odr hidden void @_TwXXV15generic_structs13SingleDynamic([24 x i8]* %buffer, %swift.type* %Self) {
// CHECK:   [[SELF_ARRAY:%.*]] = bitcast %swift.type* %Self to %swift.type**
// CHECK:   [[SELF_T_ADDR:%.*]] = getelementptr inbounds %swift.type** [[SELF_ARRAY]], i64 4
// CHECK:   %T = load %swift.type** [[SELF_T_ADDR]], align 8

// CHECK: define internal void [[SINGLE_DYNAMIC_FILL_METADATA]](i8*, i8*) {
// CHECK: entry:
// CHECK:   [[METADATA_ADDR:%.*]] = bitcast i8* %0 to i64*
// CHECK:   [[ARGS_ADDR:%.*]] = bitcast i8* %1 to i64*
// -- fill ops
// CHECK:   [[METADATA_SLOT_ADDR:%.*]] = getelementptr inbounds i64* [[METADATA_ADDR]], i32 5
// CHECK:   [[ARGS_SLOT_ADDR:%.*]] = getelementptr inbounds i64* [[ARGS_ADDR]], i32 0
// CHECK:   [[ARG:%.*]] = load i64* [[ARGS_SLOT_ADDR]], align 8
// CHECK:   store i64 [[ARG]], i64* [[METADATA_SLOT_ADDR]], align 8
// -- store vwtable reference
// CHECK:   [[VWTABLE_ADDR:%.*]] = getelementptr inbounds i64* [[METADATA_ADDR]], i32 6
// CHECK:   [[VWTABLE_VAL:%.*]] = ptrtoint i64* [[VWTABLE_ADDR]] to i64
// CHECK:   [[VWTABLE_SLOT_ADDR:%.*]] = getelementptr inbounds i64* [[METADATA_ADDR]], i32 0
// CHECK:   store i64 [[VWTABLE_VAL]], i64* [[VWTABLE_SLOT_ADDR]], align 8
// -- lay out fields
// CHECK:   [[VWTABLE_ADDR_I8:%.*]] = bitcast i64* [[VWTABLE_ADDR]] to i8**
// CHECK:   call void @swift_initStructMetadata_UniversalStrategy(i64 1, %swift.type** {{%.*}}, i64* {{%.*}}, i8** [[VWTABLE_ADDR_I8]])
// CHECK:   ret void
// CHECK: }
