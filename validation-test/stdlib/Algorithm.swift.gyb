// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Algorithm.swift
// RUN: %S/../../utils/line-directive %t/Algorithm.swift -- %target-build-swift %t/Algorithm.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/Algorithm.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest
import SwiftPrivate

var Algorithm = TestSuite("Algorithm")

// FIXME(prext): remove this conformance.
extension String.UnicodeScalarView : Equatable {}

// FIXME(prext): remove this function.
public func == (
  lhs: String.UnicodeScalarView, rhs: String.UnicodeScalarView) -> Bool {
  return Array(lhs) == Array(rhs)
}

Algorithm.test("split") {
  expectEqual(
    [ "foo", "  bar baz " ].map { $0.unicodeScalars },
    split("  foo   bar baz ".unicodeScalars, maxSplit: 1) { $0._isSpace() })

  expectEqual(
    [ "foo", "bar", "baz" ].map { $0.unicodeScalars },
    split(
      "  foo   bar baz ".unicodeScalars, allowEmptySlices: false) {
      $0._isSpace()
    })

  expectEqual(
    [ "", "", "foo", "", "", "bar", "baz", "" ].map { $0.unicodeScalars },
    split(
      "  foo   bar baz ".unicodeScalars, allowEmptySlices: true) {
      $0._isSpace()
    })

  expectEqual(
    [ "", "", "foo   bar baz " ].map { $0.unicodeScalars },
    split(
      "  foo   bar baz ".unicodeScalars, allowEmptySlices: true, maxSplit: 2,
      isSeparator: { $0._isSpace() }))
}

// FIXME(prext): move this struct to the point of use.
struct StartsWithTest {
  let expected: Bool
  let sequence: [Int]
  let prefix: [Int]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverPrefix: [Int]
  let loc: SourceLoc

  init(
    _ expected: Bool, _ sequence: [Int], _ prefix: [Int],
    _ expectedLeftoverSequence: [Int],
    _ expectedLeftoverPrefix: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.prefix = prefix
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverPrefix = expectedLeftoverPrefix
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let startsWithTests = [
  // Corner cases.
  StartsWithTest(true, [], [], [], []),

  StartsWithTest(false, [], [ 1 ], [], []),
  StartsWithTest(true, [ 1 ], [], [], []),

  // Equal sequences.
  StartsWithTest(true, [ 1 ], [ 1 ], [], []),
  StartsWithTest(true, [ 1, 2 ], [ 1, 2 ], [], []),

  // Proper prefix.
  StartsWithTest(true, [ 0, 1, 2 ], [ 0, 1 ], [], []),
  StartsWithTest(false, [ 0, 1 ], [ 0, 1, 2 ], [], []),

  StartsWithTest(true, [ 1, 2, 3, 4 ], [ 1, 2 ], [ 4 ], []),
  StartsWithTest(false, [ 1, 2 ], [ 1, 2, 3, 4 ], [], [ 4 ]),

  // Not a prefix.
  StartsWithTest(false, [ 1, 2, 3, 4 ], [ 1, 2, 10 ], [ 4 ], []),
  StartsWithTest(false, [ 1, 2, 10 ], [ 1, 2, 3, 4 ], [], [ 4 ]),

  StartsWithTest(false, [ 1, 2, 3, 4, 10 ], [ 1, 2, 10 ], [ 4, 10 ], []),
  StartsWithTest(false, [ 1, 2, 10 ], [ 1, 2, 3, 4, 10 ], [], [ 4, 10 ]),
]

Algorithm.test("min,max") {
  expectEqual(2, min(3, 2))
  expectEqual(3, min(3, 7, 5))
  expectEqual(3, max(3, 2))
  expectEqual(7, max(3, 7, 5))

  // FIXME: add tests that check that min/max return the
  // first element of the sequence (by reference equailty) that satisfy the
  // condition.
}

Algorithm.test("sorted/strings")
  .xfail(.LinuxAny(reason: "String comparison: ICU vs. Foundation"))
  .code {
  expectEqual(
    [ "Banana", "apple", "cherry" ],
    [ "apple", "Banana", "cherry" ].sort())

  let s = ["apple", "Banana", "cherry"].sort() {
    $0.characters.count > $1.characters.count
  }
  expectEqual([ "Banana", "cherry", "apple" ], s)
}

// A wrapper around Array<T> that disables any type-specific algorithm
// optimizations and forces bounds checking on.
struct A<T> : MutableSliceable {
  init(_ a: Array<T>) {
    impl = a
  }

  var startIndex: Int {
    return 0
  }

  var endIndex: Int {
    return impl.count
  }

  func generate() -> Array<T>.Generator {
    return impl.generate()
  }

  subscript(i: Int) -> T {
    get {
      expectTrue(i >= 0 && i < impl.count)
      return impl[i]
    }
    set (x) {
      expectTrue(i >= 0 && i < impl.count)
      impl[i] = x
    }
  }

  subscript(r: Range<Int>) -> Array<T>.SubSlice {
    get {
      expectTrue(r.startIndex >= 0 && r.startIndex <= impl.count)
      expectTrue(r.endIndex >= 0 && r.endIndex <= impl.count)
      return impl[r]
    }
    set (x) {
      expectTrue(r.startIndex >= 0 && r.startIndex <= impl.count)
      expectTrue(r.endIndex >= 0 && r.endIndex <= impl.count)
      impl[r] = x
    }
  }

  var impl: Array<T>
}

func withInvalidOrderings(body: ((Int,Int)->Bool)->Void) {
  // Test some ordering predicates that don't create strict weak orderings
  body { (_,_) in true }
  body { (_,_) in false }
  var i = 0
  body { (_,_) in i++ % 2 == 0 }
  body { (_,_) in i++ % 3 == 0 }
  body { (_,_) in i++ % 5 == 0 }
}

func randomArray() -> A<Int> {
  let count = Int(rand32(exclusiveUpperBound: 50))
  return A(randArray(count))
}

Algorithm.test("invalidOrderings") {
  withInvalidOrderings {
    var a = randomArray()
    _blackHole(a.sort($0))
  }
  withInvalidOrderings {
    var a: A<Int>
    a = randomArray()
    a.partition(a.indices, isOrderedBefore: $0)
  }
  /*
  // FIXME: Disabled due to <rdar://problem/17734737> Unimplemented:
  // abstraction difference in l-value
  withInvalidOrderings {
    var a = randomArray()
    var pred = $0
    _insertionSort(&a, a.indices, &pred)
  }
  */
}

// The routine is based on http://www.cs.dartmouth.edu/~doug/mdmspe.pdf
func makeQSortKiller(len: Int) -> [Int] {
  var candidate: Int = 0
  var keys = [Int:Int]()
  func Compare(x: Int, y : Int) -> Bool {
    if keys[x] == nil && keys[y] == nil {
      if (x == candidate) {
        keys[x] = keys.count
      } else {
        keys[y] = keys.count
      }
    }
    if keys[x] == nil {
      candidate = x
      return true
    }
    if keys[y] == nil {
      candidate = y
      return false
    }
    return keys[x]! > keys[y]!
  }

  var ary = [Int](count: len, repeatedValue:0)
  var ret = [Int](count: len, repeatedValue:0)
  for i in 0..<len { ary[i] = i }
  ary = ary.sort(Compare)
  for i in 0..<len {
    ret[ary[i]] = i
  }
  return ret
}

Algorithm.test("sorted/complexity") {
  var ary: [Int] = []

  // Check performance of sort on array of repeating values
  var comparisons_100 = 0
  ary = [Int](count: 100, repeatedValue: 0)
  ary.sortInPlace { comparisons_100++; return $0 < $1 }
  var comparisons_1000 = 0
  ary = [Int](count: 1000, repeatedValue: 0)
  ary.sortInPlace { comparisons_1000++; return $0 < $1 }
  expectTrue(comparisons_1000/comparisons_100 < 20)

  // Try to construct 'bad' case for quicksort, on which the algorithm
  // goes quadratic.
  comparisons_100 = 0
  ary = makeQSortKiller(100)
  ary.sortInPlace { comparisons_100++; return $0 < $1 }
  comparisons_1000 = 0
  ary = makeQSortKiller(1000)
  ary.sortInPlace { comparisons_1000++; return $0 < $1 }
  expectTrue(comparisons_1000/comparisons_100 < 20)
}

Algorithm.test("sorted/return type") {
  let x: Array = ([5, 4, 3, 2, 1] as ArraySlice).sort()
}

var SequenceTypeAlgorithms = TestSuite("SequenceTypeAlgorithms")

//===--- Demonstrate technique for testing generic dispatching ------------===//
// A counter we can use to record calls to our non-customizable operation

var _nonCustomizableOperation = TypeIndexed(0)
extension SequenceLog {
  static var nonCustomizableOperation : TypeIndexed<Int> {
    get {return _nonCustomizableOperation}
    set {_nonCustomizableOperation = newValue}
  }
}

// Add a non-customizable operation to sequence
extension SequenceType {
  func nonCustomizableOperation() {}
}

// Extend LoggingSequence to shadow the new operation.  When
// requirements are added to a protocol 'P', there should be an
// implementation in 'InstrumentedP' that does some bookeeping for
// testing (like counting calls to the operation) and then dispatches
// to the same operation on its 'base' member.  InstrumentedSequence
// already contains implementations of all the SequenceType
// requirements.
extension LoggingSequence {
  func nonCustomizableOperation() {
    ++Log.nonCustomizableOperation[self.dynamicType]
    return base.nonCustomizableOperation()
  }
}

SequenceTypeAlgorithms.test("Demonstration/NotCustomizable") {
  let tester = SequenceLog.dispatchTester([OpaqueValue(1)])

  tester.nonCustomizableOperation()
  
  expectNotCustomizable(tester, tester.log.nonCustomizableOperation)
}

//===----------------------------------------------------------------------===//

// FIXME: add tests for:
//
// - Array, ContiguousArray and ArraySlice as inputs.  These types special-case
// a lot of collection behavior for performance reasons.  Not to even mention
// that these are important types to test in any case.
//
// - NaN behavior of floating point types, combined with these generic
// algorithms, should make sense if possible.  For example,
// [1.0, Double.NaN].startsWith([1.0, 2.0]) should be false.

//===----------------------------------------------------------------------===//
// Indexable
//===----------------------------------------------------------------------===//

/// A minimal model of `Indexable`.
///
/// All the interesting semantic features of `Indexable` are covered
/// by tests for `CollectionType`.
struct MinimalIndexable {
  var startIndex: MinimalForwardIndex {
    fatalError("implement")
  }
  var endIndex: MinimalForwardIndex {
    fatalError("implement")
  }
  subscript(position: MinimalForwardIndex) -> OpaqueValue<Int> {
    fatalError("implement")
  }
}

/// Test that `Indexable` has an associated `Index` type.
/// Test that `Index` is used in the appropriate places in the API.
func getIndexableIndexThroughGeneric<I : Indexable>(i: I) {
  var index = expectForwardIndexType(i.startIndex)
  index = i.endIndex // `endIndex` has the same type.
  i[index] // `subscript()` has the same argument type.
  expectType(I.Index.self, &index)
}

func testCollectionRefinesIndexable<C : CollectionType>(c: C) {
  expectIndexable(c)
}

//===----------------------------------------------------------------------===//
// GeneratorSequence
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
protocol TestProtocol1 {}

extension GeneratorSequence where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/GeneratorType/empty") {
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkGenerator(
      data, g, { $0.value == $1.value },
      resiliencyChecks: .none)
  }
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkGenerator(data, g, { $0.value == $1.value })
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/GeneratorType") {
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkGenerator(
      data, g, { $0.value == $1.value },
      resiliencyChecks: .none)
  }
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkGenerator(data, g, { $0.value == $1.value })
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/SequenceType/empty") {
  if true {
    let data = [ 10, 20, 30 ].map { OpaqueValue($0) }
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkSequence(
      data, g, { $0.value == $1.value },
      resiliencyChecks: .none)
  }
  if true {
    let data = [ 10, 20, 30 ].map { OpaqueValue($0) }
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkSequence(data, g, { $0.value == $1.value })
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/SequenceType") {
  if true {
    let data = [ 10, 20, 30 ].map { OpaqueValue($0) }
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkSequence(
      data, g, { $0.value == $1.value },
      resiliencyChecks: .none)
  }
  if true {
    let data = [ 10, 20, 30 ].map { OpaqueValue($0) }
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkSequence(data, g, { $0.value == $1.value })
  }
}

//===----------------------------------------------------------------------===//
// enumerate()
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension EnumerateGenerator where Base : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

extension EnumerateSequence where Base : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

struct EnumerateTest {
  let expected: [(Int, Int)]
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ expected: [(Int, Int)], _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expected = expected
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }
}

let enumerateTests = [
  EnumerateTest([], []),
  EnumerateTest([ (0, 10) ], [ 10 ]),
  EnumerateTest([ (0, 10), (1, 20) ], [ 10, 20 ]),
  EnumerateTest([ (0, 10), (1, 20), (2, 30) ], [ 10, 20, 30 ]),
]

SequenceTypeAlgorithms.test("enumerate") {
  typealias Element = (index: Int, element: OpaqueValue<Int>)
  func compareElements(lhs: Element, rhs: Element) -> Bool {
    return lhs.0 == rhs.0 && lhs.1.value == rhs.1.value
  }

  for test in enumerateTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0) })
    var result = s.enumerate()
    expectType(
      EnumerateSequence<MinimalSequence<OpaqueValue<Int>>>.self,
      &result)
    checkSequence(
      test.expected.map {
        (index: $0.0, element: OpaqueValue($0.1))
      } as [Element],
      result, compareElements,
      resiliencyChecks: .none,
      test.loc.withCurrentLoc())
    expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
  }
}

//===----------------------------------------------------------------------===//
// minElement(), maxElement()
//===----------------------------------------------------------------------===//

struct MinMaxElementTest {
  let expectedMinValue: Int?
  let expectedMinIndex: Int?
  let expectedMaxValue: Int?
  let expectedMaxIndex: Int?
  let sequence: [Int]
  let loc: SourceLoc

  init(
    minValue expectedMinValue: Int?,
    index expectedMinIndex: Int?,
    maxValue expectedMaxValue: Int?,
    index expectedMaxIndex: Int?,
    _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expectedMinValue = expectedMinValue
    self.expectedMinIndex = expectedMinIndex
    self.expectedMaxValue = expectedMaxValue
    self.expectedMaxIndex = expectedMaxIndex
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }
}

let minMaxElementTests = [
  MinMaxElementTest(
    minValue: nil, index: nil,
    maxValue: nil, index: nil,
    []),
  MinMaxElementTest(
    minValue: 42, index: 0,
    maxValue: 42, index: 0,
    [ 42 ]),
  MinMaxElementTest(
    minValue: -1, index: 1,
    maxValue: 30, index: 2,
    [ 10, -1, 30, -1, 30 ]),
  MinMaxElementTest(
    minValue: -2, index: 5,
    maxValue: 31, index: 6,
    [ 10, -1, 30, -1, 30, -2, 31 ]),
]

% for algorithmKind in [ 'min', 'max' ]:
%   AlgorithmKind = algorithmKind.capitalize()

SequenceTypeAlgorithms.test("${algorithmKind}Element/WhereElementIsComparable") {
  for test in minMaxElementTests {
    let s = MinimalSequence<MinimalComparableValue>(
      test.sequence.enumerate().map {
        MinimalComparableValue($1, identity: $0)
      })
    var maybeResult = s.${algorithmKind}Element()
    expectType(Optional<MinimalComparableValue>.self, &maybeResult)
    if let result = maybeResult {
      expectEqual(
        test.expected${AlgorithmKind}Value!, result.value,
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expected${AlgorithmKind}Index!, result.identity,
        stackTrace: test.loc.withCurrentLoc())
    } else {
      expectEmpty(
        test.expected${AlgorithmKind}Value,
        stackTrace: test.loc.withCurrentLoc())
      expectEmpty(
        test.expected${AlgorithmKind}Index,
        stackTrace: test.loc.withCurrentLoc())
    }
    expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
  }
}

SequenceTypeAlgorithms.test("${algorithmKind}Element/Predicate") {
  for test in minMaxElementTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.enumerate().map {
        OpaqueValue($1, identity: $0)
      })
    var timesClosureWasCalled = 0
    var maybeResult = s.${algorithmKind}Element {
      (lhs, rhs) -> Bool in
      ++timesClosureWasCalled
      return lhs.value < rhs.value
    }
    expectType(Optional<OpaqueValue<Int>>.self, &maybeResult)
    if let result = maybeResult {
      expectEqual(
        test.expected${AlgorithmKind}Value!, result.value,
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expected${AlgorithmKind}Index!, result.identity,
        stackTrace: test.loc.withCurrentLoc())
    } else {
      expectEmpty(
        test.expected${AlgorithmKind}Value,
        stackTrace: test.loc.withCurrentLoc())
      expectEmpty(
        test.expected${AlgorithmKind}Index,
        stackTrace: test.loc.withCurrentLoc())
    }
    expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
    expectEqual(max(0, test.sequence.count - 1), timesClosureWasCalled) {
      "maxElement() should be eager and should only call its predicate once per element"
    }
  }
}

% end

//===----------------------------------------------------------------------===//
// startsWith()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("startsWith/WhereElementIsEquatable") {
  for test in startsWithTests {
    if true {
      let s = MinimalSequence<MinimalEquatableValue>(
        test.sequence.map { MinimalEquatableValue($0) })
      let prefix = MinimalSequence<MinimalEquatableValue>(
        test.prefix.map { MinimalEquatableValue($0) })
      expectEqual(
        test.expected,
        s.startsWith(prefix),
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }

    // Use different types for the sequence and prefix.
    if true {
      let s = MinimalForwardCollection<MinimalEquatableValue>(
        test.sequence.map { MinimalEquatableValue($0) })
      let prefix = MinimalSequence<MinimalEquatableValue>(
        test.prefix.map { MinimalEquatableValue($0) })
      expectEqual(
        test.expected,
        s.startsWith(prefix),
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

SequenceTypeAlgorithms.test("startsWith/Predicate") {
  for test in startsWithTests {
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) })
      let prefix = MinimalSequence<OpaqueValue<Int>>(
        test.prefix.map { OpaqueValue($0) })
      expectEqual(
        test.expected,
        s.startsWith(prefix) { $0.value == $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0 * 2) })
      let prefix = MinimalSequence<OpaqueValue<Int>>(
        test.prefix.map { OpaqueValue($0) })
      expectEqual(
        test.expected,
        s.startsWith(prefix) { $0.value / 2 == $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value / 2 },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }

    // Use different types for the sequence and prefix.
    if true {
      let s = MinimalForwardCollection<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) })
      let prefix = MinimalSequence<OpaqueValue<Int>>(
        test.prefix.map { OpaqueValue($0) })
      expectEqual(
        test.expected,
        s.startsWith(prefix) { $0.value == $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

//===----------------------------------------------------------------------===//
// equal()
//===----------------------------------------------------------------------===//

struct ElementsEqualTest {
  let expected: Bool
  let sequence: [Int]
  let other: [Int]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverOther: [Int]
  let loc: SourceLoc

  init(
    _ expected: Bool, _ sequence: [Int], _ other: [Int],
    _ expectedLeftoverSequence: [Int],
    _ expectedLeftoverOther: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expected = expected
    self.sequence = sequence
    self.other = other
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverOther = expectedLeftoverOther
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }

  func flip() -> ElementsEqualTest {
    return ElementsEqualTest(
      expected, other, sequence,
      expectedLeftoverOther, expectedLeftoverSequence,
      file: loc.file, line: loc.line, comment: " (flipped)")
  }
}

let elementsEqualTests: [ElementsEqualTest] = [
  ElementsEqualTest(true, [], [], [], []),

  ElementsEqualTest(false, [ 1 ], [], [], []),
  ElementsEqualTest(false, [], [ 1 ], [], []),

  ElementsEqualTest(false, [ 1, 2 ], [], [ 2 ], []),
  ElementsEqualTest(false, [], [ 1, 2 ], [], [ 2 ]),

  ElementsEqualTest(false, [ 1, 2, 3, 4 ], [ 1, 2 ], [ 4 ], []),
  ElementsEqualTest(false, [ 1, 2 ], [ 1, 2, 3, 4 ], [], [ 4 ]),
].flatMap { [ $0, $0.flip() ] }

SequenceTypeAlgorithms.test("elementsEqual/WhereElementIsEquatable") {
  for test in elementsEqualTests {
    if true {
      let s = MinimalSequence<MinimalEquatableValue>(
        test.sequence.map { MinimalEquatableValue($0) })
      let other = MinimalSequence<MinimalEquatableValue>(
        test.other.map { MinimalEquatableValue($0) })
      expectEqual(
        test.expected,
        s.elementsEqual(other),
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<MinimalEquatableValue>(
        test.sequence.map { MinimalEquatableValue($0) })
      let other = MinimalSequence<MinimalEquatableValue>(
        test.other.map { MinimalEquatableValue($0) })
      expectEqual(
        test.expected,
        s.elementsEqual(other),
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

SequenceTypeAlgorithms.test("elementsEqual/Predicate") {
  for test in elementsEqualTests {
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) })
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map { OpaqueValue($0) })
      expectEqual(
        test.expected,
        s.elementsEqual(other) { $0.value == $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) })
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map { OpaqueValue($0) })
      expectEqual(
        test.expected,
        s.elementsEqual(other) { $0.value == $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

//===----------------------------------------------------------------------===//
// lexicographicalCompare()
//===----------------------------------------------------------------------===//

struct LexicographicalCompareTest {
  let expected: ExpectedComparisonResult
  let sequence: [Int]
  let other: [Int]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverOther: [Int]
  let loc: SourceLoc

  init(
    _ expected: ExpectedComparisonResult, _ sequence: [Int], _ other: [Int],
    _ expectedLeftoverSequence: [Int],
    _ expectedLeftoverOther: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expected = expected
    self.sequence = sequence
    self.other = other
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverOther = expectedLeftoverOther
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }

  func flip() -> LexicographicalCompareTest {
    return LexicographicalCompareTest(
      expected.flip(), other, sequence,
      expectedLeftoverOther, expectedLeftoverSequence,
      file: loc.file, line: loc.line, comment: " (flipped)")
  }
}

let lexicographicalCompareTests = [
  LexicographicalCompareTest(.EQ, [], [], [], []),
  LexicographicalCompareTest(.EQ, [ 1 ], [ 1 ], [], []),

  LexicographicalCompareTest(.GT, [ 1 ], [], [], []),

  LexicographicalCompareTest(.GT, [ 1 ], [ 0 ], [], []),
  LexicographicalCompareTest(.EQ, [ 1 ], [ 1 ], [], []),
  LexicographicalCompareTest(.LT, [ 1 ], [ 2 ], [], []),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [], [ 2 ], []),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0 ], [ 2 ], []),
  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 1 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2 ], [ 2 ], []),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 0 ], [ 2 ], [ 0 ]),
  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 1, 0 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 0 ], [ 2 ], [ 0 ]),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 1 ], [ 2 ], [ 1 ]),
  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 1, 1 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 1 ], [ 2 ], [ 1 ]),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 2 ], [ 2 ], [ 2 ]),
  LexicographicalCompareTest(.EQ, [ 1, 2 ], [ 1, 2 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 2 ], [ 2 ], [ 2 ]),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 3 ], [ 2 ], [ 3 ]),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 1, 3 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 3 ], [ 2 ], [ 3 ]),
].flatMap { [ $0, $0.flip() ] }

SequenceTypeAlgorithms.test("lexicographicalCompare/WhereElementIsComparable") {
  for test in lexicographicalCompareTests {
    if true {
      let s = MinimalSequence<MinimalComparableValue>(
        test.sequence.map { MinimalComparableValue($0) })
      let other = MinimalSequence<MinimalComparableValue>(
        test.other.map { MinimalComparableValue($0) })
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other),
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<MinimalComparableValue>(
        test.sequence.map { MinimalComparableValue($0) })
      let other = MinimalSequence<MinimalComparableValue>(
        test.other.map { MinimalComparableValue($0) })
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other),
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

SequenceTypeAlgorithms.test("lexicographicalCompare/Predicate") {
  for test in lexicographicalCompareTests {
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) })
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map { OpaqueValue($0) })
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other) { $0.value < $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) })
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map { OpaqueValue($0) })
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other) { $0.value < $1.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

//===----------------------------------------------------------------------===//
// contains()
//===----------------------------------------------------------------------===//

// These tests are shared between find() and contains().
struct FindTest {
  let expected: Int?
  let element: MinimalEquatableValue
  let sequence: [MinimalEquatableValue]
  let expectedLeftoverSequence: [MinimalEquatableValue]
  let loc: SourceLoc

  init(
    _ expected: Int?, _ element: Int, _ sequence: [Int],
    _ expectedLeftoverSequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.element = MinimalEquatableValue(element)
    self.sequence = sequence.map { MinimalEquatableValue($0) }
    self.expectedLeftoverSequence = expectedLeftoverSequence.map {
      MinimalEquatableValue($0)}
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let findTests = [
  FindTest(nil, 42, [], []),

  FindTest(nil, 42, [ 1 ], []),
  FindTest(0, 1, [ 1 ], []),

  FindTest(nil, 42, [ 1, 2, 3, 4 ], []),
  FindTest(0, 1, [ 1, 2, 3, 4 ], [ 2, 3, 4 ]),
  FindTest(1, 2, [ 1, 2, 3, 4 ], [ 3, 4 ]),
  FindTest(2, 3, [ 1, 2, 3, 4 ], [ 4 ]),
  FindTest(3, 4, [ 1, 2, 3, 4 ], []),
]

typealias StrictSequenceOfEquatable = MinimalSequence<MinimalEquatableValue>

// FIXME: rename in StdlibUnittest
// typealias StrictSequence = MinimalSequence

SequenceTypeAlgorithms.test("contains/WhereElementIsEquatable/dispatch") {
  let tester = SequenceLog.dispatchTester([MinimalEquatableValue(1)])
  _ = tester.contains(MinimalEquatableValue(1))
  expectCustomizable(tester, tester.log._customContainsEquatableElement)
}

SequenceTypeAlgorithms.test("contains/WhereElementIsEquatable/semantics") {
  for test in findTests {
    let s = StrictSequenceOfEquatable(MinimalSequence(test.sequence))
    
    expectEqual(
      test.expected != nil,
      s.contains(test.element),
      stackTrace: test.loc.withCurrentLoc())
    
    expectEqualSequence(
      test.expectedLeftoverSequence, s, stackTrace: test.loc.withCurrentLoc())
  }
}

func callStaticContains(
  set: Set<MinimalHashableValue>,
  _ element: MinimalHashableValue
) -> Bool {
  return set.contains(element)
}


func callGenericContains<
  S : SequenceType where S.Generator.Element : Equatable
>(sequence: S, _ element: S.Generator.Element) -> Bool {
  return sequence.contains(element)
}

% for dispatch in [ 'Static', 'Generic' ]:

// FIXME: implement the same optimization for Dictionary.
// FIXME: move to the file where other Set tests live.
SequenceTypeAlgorithms.test("Set<T>.contains/CustomImplementation/${dispatch}") {
  for test in findTests {
    let s = Set<MinimalHashableValue>(
      test.sequence.map { MinimalHashableValue($0.value) })
    MinimalHashableValue.timesEqualEqualWasCalled = 0
    MinimalHashableValue.timesHashValueWasCalled = 0
    expectEqual(
      test.expected != nil,
      call${dispatch}Contains(s, MinimalHashableValue(test.element.value)),
      stackTrace: test.loc.withCurrentLoc())
    if test.sequence.isEmpty {
      expectEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: test.loc.withCurrentLoc())
    } else {
      expectNotEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: test.loc.withCurrentLoc())
    }
    if test.expected != nil {
      expectNotEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

% end

SequenceTypeAlgorithms.test("contains/Predicate") {
  for test in findTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0.value) })
    expectEqual(
      test.expected != nil,
      s.contains { $0.value == test.element.value },
      stackTrace: test.loc.withCurrentLoc())
    expectEqual(
      test.expectedLeftoverSequence.map { $0.value }, s.map { $0.value },
      stackTrace: test.loc.withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// reduce()
//===----------------------------------------------------------------------===//

struct ReduceTest {
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let reduceTests = [
  ReduceTest([]),
  ReduceTest([ 1 ]),
  ReduceTest([ 1, 2 ]),
  ReduceTest([ 1, 2, 3 ]),
  ReduceTest([ 1, 2, 3, 4, 5, 6, 7 ]),
]

SequenceTypeAlgorithms.test("reduce") {
  for test in reduceTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0) })
    var timesClosureWasCalled = 0
    let result = s.reduce(OpaqueValue<[Int]>([])) {
      (partialResult: OpaqueValue<[Int]>, element: OpaqueValue<Int>)
        -> OpaqueValue<[Int]> in
      ++timesClosureWasCalled
      return OpaqueValue<[Int]>(partialResult.value + [ element.value ])
    }
    expectEqual(test.sequence, result.value)
    expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
    expectEqual(test.sequence.count, timesClosureWasCalled) {
      "reduce() should be eager and should only call its predicate once per element"
    }
  }
}

//===----------------------------------------------------------------------===//
// reverse()
//===----------------------------------------------------------------------===//

struct ReverseTest {
  let expected: [Int]
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ expected: [Int], _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let reverseTests: [ReverseTest] = [
  ReverseTest([], []),
  ReverseTest([ 1 ], [ 1 ]),
  ReverseTest([ 2, 1 ], [ 1, 2 ]),
  ReverseTest([ 3, 2, 1 ], [ 1, 2, 3 ]),
  ReverseTest([ 4, 3, 2, 1 ], [ 1, 2, 3, 4]),
  ReverseTest(
    [ 7, 6, 5, 4, 3, 2, 1 ],
    [ 1, 2, 3, 4, 5, 6, 7 ]),
]

SequenceTypeAlgorithms.test("reverse/SequenceType") {
  for test in reverseTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0) })
    var result = s.reverse()
    expectType([OpaqueValue<Int>].self, &result)
    expectEqual(
      test.expected, result.map { $0.value },
      stackTrace: test.loc.withCurrentLoc())
    expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
  }
}

SequenceTypeAlgorithms.test("reverse/WhereIndexIsBidirectional,BidirectionalReverseView") {
  for test in reverseTests {
    let s = MinimalBidirectionalCollection<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0) })
    var result = s.reverse()
    expectType(
      ReverseCollection<MinimalBidirectionalCollection<OpaqueValue<Int>>>.self,
      &result)
    expectEqual(
      test.expected, result.map { $0.value },
      stackTrace: test.loc.withCurrentLoc())

    // Check ReverseCollection's CollectionType conformance.
    checkBidirectionalCollection(
      test.expected.map { OpaqueValue($0) } as [OpaqueValue<Int>],
      result,
      { $0.value == $1.value },
      test.loc.withCurrentLoc())
  }
}

SequenceTypeAlgorithms.test("reverse/WhereIndexIsRandomAccess,RandomAccessReverseView") {
  for test in reverseTests {
    let s = MinimalRandomAccessCollection<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0) })
    var result = s.reverse()
    expectType(
      ReverseRandomAccessCollection<MinimalRandomAccessCollection<OpaqueValue<Int>>>.self,
      &result)
    expectEqual(
      test.expected, result.map { $0.value },
      stackTrace: test.loc.withCurrentLoc())

    // Check ReverseRandomAccessCollection CollectionType conformance.
    checkRandomAccessCollection(
      test.expected.map { OpaqueValue($0) } as [OpaqueValue<Int>],
      result,
      { $0.value == $1.value },
      test.loc.withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// filter()
//===----------------------------------------------------------------------===//

struct FilterTest {
  let expected: [Int]
  let sequence: [Int]
  let includeElement: (Int) -> Bool
  let loc: SourceLoc

  init(
    _ expected: [Int],
    _ sequence: [Int],
    _ includeElement: (Int) -> Bool,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.includeElement = includeElement
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let filterTests = [
  FilterTest(
    [], [],
    { (x: Int) -> Bool in expectUnreachable(); return true }),

  FilterTest([], [ 0, 30, 10, 90 ], { (x: Int) -> Bool in false }),
  FilterTest(
    [ 0, 30, 10, 90 ], [ 0, 30, 10, 90 ], { (x: Int) -> Bool in true }
  ),
  FilterTest(
    [ 0, 30, 90 ], [ 0, 30, 10, 90 ], { (x: Int) -> Bool in x % 3 == 0 }
  ),
]

SequenceTypeAlgorithms.test("filter/SequenceType/Dispatch") {
  let tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.filter { _ in false }
  expectCustomizable(tester, tester.log.filter)
}

SequenceTypeAlgorithms.test("filter/SequenceType/Semantics") {
  for test in filterTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      
      let s = DefaultedSequence<OpaqueValue<Int>> (
        test.sequence.map { OpaqueValue($0) },
        underestimatedCount: underestimateCountBehavior)
      
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
      var result = s.filter {
        (element) in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return test.includeElement(element.value)
      }
      expectType([OpaqueValue<Int>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
      expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
      expectEqual(test.sequence.count, timesClosureWasCalled) {
        "filter() should be eager and should only call its predicate once per element"
      }
      expectGE(2 * result.count, result.capacity) {
        "filter() should not reserve capacity (it does not know how much the predicate will filter out)"
      }
    }
  }
}

var MinimalForwardCollectionWithCustomFilter_timesFilterWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalForwardCollectionWith${Implementation}Filter<Element>
  : CollectionType {

  init(_ data: [Element], underestimatedCount: UnderestimateCountBehavior) {
    self._data = MinimalForwardCollection(
      data, underestimatedCount: underestimatedCount)
  }

  func generate() -> MinimalGenerator<Element> {
    return _data.generate()
  }

  var startIndex: MinimalForwardIndex {
    return _data.startIndex
  }

  var endIndex: MinimalForwardIndex {
    return _data.endIndex
  }

  subscript(i: MinimalForwardIndex) -> Element {
    return _data[i]
  }

  var _data: MinimalForwardCollection<Element>


%   if Implementation == 'Custom':

  static var timesFilterWasCalled: Int {
    get {
      return MinimalForwardCollectionWithCustomFilter_timesFilterWasCalled
    }
    set {
      MinimalForwardCollectionWithCustomFilter_timesFilterWasCalled = newValue
    }
  }

  func filter(
    @noescape transform: (Element) -> Bool
  ) -> [Element] {
    ++MinimalForwardCollectionWithCustomFilter.timesFilterWasCalled
    return _data.filter(transform)
  }

%   end

}

% end

func callStaticCollectionFilter(
  sequence: MinimalForwardCollectionWithDefaultFilter<OpaqueValue<Int>>,
  @noescape includeElement: (OpaqueValue<Int>) -> Bool
) -> [OpaqueValue<Int>] {
  var result = sequence.filter(includeElement)
  expectType([OpaqueValue<Int>].self, &result)
  return result
}

func callStaticCollectionFilter(
  sequence: MinimalForwardCollectionWithCustomFilter<OpaqueValue<Int>>,
  @noescape includeElement: (OpaqueValue<Int>) -> Bool
) -> [OpaqueValue<Int>] {
  var result = sequence.filter(includeElement)
  expectType([OpaqueValue<Int>].self, &result)
  return result
}

func callGenericCollectionFilter<S : CollectionType>(
  sequence: S,
  @noescape includeElement: (S.Generator.Element) -> Bool
) -> [S.Generator.Element] {
  var result = sequence.filter(includeElement)
  expectType(Array<S.Generator.Element>.self, &result)
  return result
}

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("filter/CollectionType/${Implementation}Implementation/${dispatch}") {
  for test in filterTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalForwardCollectionWith${Implementation}Filter<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) },
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
%     if Implementation == 'Custom':
      MinimalForwardCollectionWithCustomFilter<OpaqueValue<Int>>.timesFilterWasCalled = 0
%     end
      var result = call${dispatch}CollectionFilter(s) {
        (element) in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return test.includeElement(element.value)
      }
      expectType([OpaqueValue<Int>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
%     if Implementation == 'Custom':
      expectEqual(1, MinimalForwardCollectionWithCustomFilter<OpaqueValue<Int>>.timesFilterWasCalled)
%     end
      expectEqual(test.sequence, s.map { $0.value }) {
        "collection should not be consumed"
      }
      expectEqual(test.sequence.count, timesClosureWasCalled) {
        "filter() should be eager and should only call its predicate once per element"
      }
      expectGE(2 * result.count, result.capacity) {
        "filter() should not reserve capacity (it does not know how much the predicate will filter out)"
      }
    }
  }
}

%   end

% end

//===----------------------------------------------------------------------===//
// map()
//===----------------------------------------------------------------------===//

struct MapTest {
  let expected: [Int32]
  let sequence: [Int]
  let transform: (Int) -> Int32
  let loc: SourceLoc

  init(
    _ expected: [Int32],
    _ sequence: [Int],
    _ transform: (Int) -> Int32,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.transform = transform
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let mapTests = [
  MapTest(
    [], [],
    { (x: Int) -> Int32 in expectUnreachable(); return 0xffff }),

  MapTest([ 101 ], [ 1 ], { (x: Int) -> Int32 in x + 100 }),
  MapTest([ 101, 102 ], [ 1, 2 ], { (x: Int) -> Int32 in x + 100 }),
  MapTest([ 101, 102, 103 ], [ 1, 2, 3 ], { (x: Int) -> Int32 in x + 100 }),
  MapTest(Array(101..<200), Array(1..<100), { (x: Int) -> Int32 in x + 100 }),
]

var MinimalSequenceWithCustomMap_timesMapWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalSequenceWith${Implementation}Map<Element> : SequenceType {
  init(_ data: [Element], underestimatedCount: UnderestimateCountBehavior) {
    self._data = MinimalSequence(
      data, underestimatedCount: underestimatedCount)
  }

  func generate() -> MinimalGenerator<Element> {
    return _data.generate()
  }

  var _data: MinimalSequence<Element>


%   if Implementation == 'Custom':

  static var timesMapWasCalled: Int {
    get {
      return MinimalSequenceWithCustomMap_timesMapWasCalled
    }
    set {
      MinimalSequenceWithCustomMap_timesMapWasCalled = newValue
    }
  }

  func map<T>(
    @noescape transform: (Element) -> T
  ) -> [T] {
    ++MinimalSequenceWithCustomMap.timesMapWasCalled
    return _data.map(transform)
  }

%   end
}

% end

func callStaticSequenceMap<T>(
  sequence: MinimalSequenceWithDefaultMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = sequence.map(transform)
  expectType([T].self, &result)
  return result
}

func callStaticSequenceMap<T>(
  sequence: MinimalSequenceWithCustomMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = sequence.map(transform)
  expectType([T].self, &result)
  return result
}

func callGenericSequenceMap<S : SequenceType, T>(
  sequence: S,
  @noescape transform: (S.Generator.Element) -> T
) -> [T] {
  var result = sequence.map(transform)
  expectType([T].self, &result)
  return result
}

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("map/SequenceType/${Implementation}Implementation/${dispatch}") {
  for test in mapTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalSequenceWith${Implementation}Map<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) },
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
%     if Implementation == 'Custom':
      MinimalSequenceWithCustomMap<OpaqueValue<Int>>.timesMapWasCalled = 0
%     end
      var result = call${dispatch}SequenceMap(s) {
        (element: OpaqueValue<Int>) -> OpaqueValue<Int32> in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return OpaqueValue(Int32(test.transform(element.value)))
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
%     if Implementation == 'Custom':
      expectEqual(1, MinimalSequenceWithCustomMap<OpaqueValue<Int>>.timesMapWasCalled)
%     end
      expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
      expectEqual(test.sequence.count, timesClosureWasCalled) {
        "map() should be eager and should only call its predicate once per element"
      }
    }
  }
}

%   end

% end

var MinimalForwardCollectionWithCustomMap_timesMapWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalForwardCollectionWith${Implementation}Map<Element>
  : CollectionType {

  init(_ data: [Element], underestimatedCount: UnderestimateCountBehavior) {
    self._data = MinimalForwardCollection(
      data, underestimatedCount: underestimatedCount)
  }

  func generate() -> MinimalGenerator<Element> {
    return _data.generate()
  }

  var startIndex: MinimalForwardIndex {
    return _data.startIndex
  }

  var endIndex: MinimalForwardIndex {
    return _data.endIndex
  }

  subscript(i: MinimalForwardIndex) -> Element {
    return _data[i]
  }

  var _data: MinimalForwardCollection<Element>


%   if Implementation == 'Custom':

  static var timesMapWasCalled: Int {
    get {
      return MinimalForwardCollectionWithCustomMap_timesMapWasCalled
    }
    set {
      MinimalForwardCollectionWithCustomMap_timesMapWasCalled = newValue
    }
  }

  func map<T>(
    @noescape transform: (Element) -> T
  ) -> [T] {
    ++MinimalForwardCollectionWithCustomMap.timesMapWasCalled
    return _data.map(transform)
  }

%   end

}

% end

func callStaticCollectionMap<T>(
  collection: MinimalForwardCollectionWithDefaultMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = collection.map(transform)
  expectType([T].self, &result)
  return result
}

func callStaticCollectionMap<T>(
  collection: MinimalForwardCollectionWithCustomMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = collection.map(transform)
  expectType([T].self, &result)
  return result
}

func callGenericCollectionMap<C : CollectionType, T>(
  collection: C,
  @noescape transform: (C.Generator.Element) -> T
) -> [T] {
  var result = collection.map(transform)
  expectType([T].self, &result)
  return result
}

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("map/CollectionType/${Implementation}Implementation/${dispatch}") {
  for test in mapTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalForwardCollectionWith${Implementation}Map<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) },
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
%     if Implementation == 'Custom':
      MinimalForwardCollectionWithCustomMap<OpaqueValue<Int>>.timesMapWasCalled = 0
%     end
      var result = call${dispatch}CollectionMap(s) {
        (element: OpaqueValue<Int>) -> OpaqueValue<Int32> in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return OpaqueValue(Int32(test.transform(element.value)))
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
%     if Implementation == 'Custom':
      expectEqual(1, MinimalForwardCollectionWithCustomMap<OpaqueValue<Int>>.timesMapWasCalled)
%     end
      expectEqual(test.sequence, s.map { $0.value }) {
        "collection should not be consumed"
      }
      expectEqual(test.sequence.count, timesClosureWasCalled) {
        "map() should be eager and should only call its predicate once per element"
      }
    }
  }
}

%   end

% end

//===----------------------------------------------------------------------===//
// flatMap()
//===----------------------------------------------------------------------===//

struct FlatMapTest {
  let expected: [Int32]
  let sequence: [Int]
  let transform: (Int) -> [Int32]
  let loc: SourceLoc

  init(
    _ expected: [Int32],
    _ sequence: [Int],
    _ transform: (Int) -> [Int32],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.transform = transform
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

func flatMapTransformation(x: Int) -> [Int32] {
  let repetitions = x / 10
  let identity = x % 10
  let range = (1..<(repetitions+1))
  return range.map { Int32($0 * 10 + identity) }
}

let flatMapTests = [
  FlatMapTest(
    [], [],
    { (x: Int) -> [Int32] in expectUnreachable(); return [ 0xffff ] }),

  FlatMapTest([], [ 1 ], { (x: Int) -> [Int32] in [] }),
  FlatMapTest([], [ 1, 2 ], { (x: Int) -> [Int32] in [] }),
  FlatMapTest([], [ 1, 2, 3 ], { (x: Int) -> [Int32] in [] }),

  FlatMapTest([ 101 ], [ 1 ], { (x: Int) -> [Int32] in [ x + 100 ] }),
  FlatMapTest([ 101, 102 ], [ 1, 2 ], { (x: Int) -> [Int32] in [ x + 100 ] }),
  FlatMapTest(
    [ 101, 102, 103 ], [ 1, 2, 3 ], { (x: Int) -> [Int32] in [ x + 100 ] }),

  FlatMapTest(
    [ 101, 201 ], [ 1 ],
    { (x: Int) -> [Int32] in [ x + 100, x + 200 ] }),
  FlatMapTest(
    [ 101, 201, 102, 202 ], [ 1, 2 ],
    { (x: Int) -> [Int32] in [ x + 100, x + 200 ] }),
  FlatMapTest(
    [ 101, 201, 102, 202, 103, 203 ], [ 1, 2, 3 ],
    { (x: Int) -> [Int32] in [ x + 100, x + 200 ] }),

  FlatMapTest([ 11, 15 ], [ 11, 2, 3, 4, 15 ], flatMapTransformation),
  FlatMapTest([ 12, 13, 23 ], [ 1, 12, 23 ], flatMapTransformation),
  FlatMapTest(
    [ 11, 21, 13, 23, 33, 14 ], [ 21, 2, 33, 14 ], flatMapTransformation),
]

SequenceTypeAlgorithms.test("flatMap/SequenceType") {
  for test in flatMapTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) },
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
      var result = s.flatMap {
        (element: OpaqueValue<Int>) -> MinimalSequence<OpaqueValue<Int32>> in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return MinimalSequence<OpaqueValue<Int32>>(
          test.transform(element.value).map { OpaqueValue(Int32($0)) })
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(
        test.expected, result.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
      expectEqual(test.sequence.count, timesClosureWasCalled) {
        "map() should be eager and should only call its predicate once per element"
      }
      expectGE(2 * result.count, result.capacity) {
        "flatMap() should not reserve capacity"
      }
    }
  }
}

struct FlatMapToOptionalTest {
  let expected: [Int32]
  let sequence: [Int]
  let transform: (Int) -> Int32?
  let loc: SourceLoc

  init(
    _ expected: [Int32],
    _ sequence: [Int],
    _ transform: (Int) -> Int32?,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.transform = transform
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let flatMapToOptionalTests = [
  FlatMapToOptionalTest(
    [], [],
    { (x: Int) -> Int32? in expectUnreachable(); return 0xffff }),

  FlatMapToOptionalTest([], [ 1 ], { (x: Int) -> Int32? in nil }),
  FlatMapToOptionalTest([], [ 1, 2 ], { (x: Int) -> Int32? in nil }),
  FlatMapToOptionalTest([], [ 1, 2, 3 ], { (x: Int) -> Int32? in nil }),

  FlatMapToOptionalTest(
    [ 1 ], [ 1 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
  FlatMapToOptionalTest(
    [ 2 ], [ 11, 2, 13, 14 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
  FlatMapToOptionalTest(
    [ 1, 4 ], [ 1, 12, 13, 4 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
  FlatMapToOptionalTest(
    [ 1, 2, 3 ], [ 1, 2, 3 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
]

SequenceTypeAlgorithms.test("flatMap/SequenceType/TransformProducesOptional") {
  for test in flatMapToOptionalTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0) },
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
      var result = s.flatMap {
        (element: OpaqueValue<Int>) -> OpaqueValue<Int32>? in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return test.transform(element.value).map { OpaqueValue(Int32($0)) }
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(
        test.expected, result.map { $0.value },
        stackTrace: test.loc.withCurrentLoc())
      expectEqual([], s.map { $0.value }) { "sequence should be consumed" }
      expectEqual(test.sequence.count, timesClosureWasCalled) {
        "flatMap() should be eager and should only call its predicate once per element"
      }
      expectGE(2 * result.count, result.capacity) {
        "flatMap() should not reserve capacity"
      }
    }
  }
}

//===----------------------------------------------------------------------===//
// zip()
//===----------------------------------------------------------------------===//

// Check that the generic parameters are called 'Generator1' and 'Generator2'.
extension Zip2Generator
  where Generator1 : TestProtocol1, Generator2 : TestProtocol1 {

  var _generator1IsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

extension Zip2Sequence
  where Sequence1 : TestProtocol1, Sequence2 : TestProtocol1 {

  var _sequence1IsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

struct ZipTest {
  let expected: [(Int, Int32)]
  let sequence: [Int]
  let other: [Int32]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverOther: [Int32]
  let loc: SourceLoc

  init(
    _ expected: [(Int, Int32)],
    sequences sequence: [Int],
    _ other: [Int32],
    leftovers expectedLeftoverSequence: [Int],
    _ expectedLeftoverOther: [Int32],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.other = other
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverOther = expectedLeftoverOther
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let zipTests = [
  ZipTest([], sequences: [], [], leftovers: [], []),
  ZipTest([], sequences: [], [ 1 ], leftovers: [], [ 1 ]),
  ZipTest([], sequences: [], [ 1, 2 ], leftovers: [], [ 1, 2 ]),
  ZipTest([], sequences: [], [ 1, 2, 3 ], leftovers: [], [ 1, 2, 3 ]),

  ZipTest([], sequences: [ 10 ], [], leftovers: [], []),
  ZipTest([ (10, 1) ], sequences: [ 10 ], [ 1 ], leftovers: [], []),
  ZipTest([ (10, 1) ], sequences: [ 10 ], [ 1, 2 ], leftovers: [], [ 2 ]),
  ZipTest([ (10, 1) ], sequences: [ 10 ], [ 1, 2, 3 ], leftovers: [], [ 2, 3 ]),

  ZipTest(
    [],
    sequences: [ 10, 20 ], [],
    leftovers: [ 20 ], []),
  ZipTest(
    [ (10, 1) ],
    sequences: [ 10, 20 ], [ 1 ],
    leftovers: [], []),
  ZipTest(
    [ (10, 1), (20, 2) ],
    sequences: [ 10, 20 ], [ 1, 2 ],
    leftovers: [], []),
  ZipTest(
    [ (10, 1), (20, 2) ],
    sequences: [ 10, 20 ], [ 1, 2, 3 ],
    leftovers: [], [ 3 ]),

  ZipTest(
    [],
    sequences: [ 10, 20, 30 ], [],
    leftovers: [ 20, 30 ], []),
  ZipTest(
    [ (10, 1) ],
    sequences: [ 10, 20, 30 ], [ 1 ],
    leftovers: [ 30 ], []),
  ZipTest(
    [ (10, 1), (20, 2) ],
    sequences: [ 10, 20, 30 ], [ 1, 2 ],
    leftovers: [], []),
  ZipTest(
    [ (10, 1), (20, 2), (30, 3) ],
    sequences: [ 10, 20, 30 ], [ 1, 2, 3 ],
    leftovers: [], []),
]

SequenceTypeAlgorithms.test("zip") {
  typealias Element = (OpaqueValue<Int>, OpaqueValue<Int32>)
  func compareElements(lhs: Element, rhs: Element) -> Bool {
    return lhs.0.value == rhs.0.value && lhs.1.value == rhs.1.value
  }

  for test in zipTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0) })
    let other = MinimalSequence<OpaqueValue<Int32>>(
      test.other.map { OpaqueValue($0) })
    var result = zip(s, other)
    expectType(
      Zip2Sequence<MinimalSequence<OpaqueValue<Int>>, MinimalSequence<OpaqueValue<Int32>>>.self,
      &result)

    // Check for expected result and check the Zip2Sequence's SequenceType
    // conformance.
    checkSequence(
      test.expected.map { (OpaqueValue($0), OpaqueValue($1)) },
      result,
      compareElements,
      test.loc.withCurrentLoc())
    // Check leftovers *after* doing checkSequence(), not before, to ensure
    // that checkSequence() didn't force us to consume more elements than
    // needed.
    expectEqual(
      test.expectedLeftoverSequence, s.map { $0.value },
      stackTrace: test.loc.withCurrentLoc())
    expectEqual(
      test.expectedLeftoverOther, other.map { $0.value },
      stackTrace: test.loc.withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// underestimateCount()
//===----------------------------------------------------------------------===//

func callGenericUnderestimatedCount<S : SequenceType>(s: S) -> Int {
  return s.underestimateCount()
}

struct SequenceWithDefaultUnderestimateCount : SequenceType {
  init() {}

  func generate() -> MinimalSequence<OpaqueValue<Int>>.Generator {
    expectUnreachable()
    return MinimalSequence(
      [ 1, 2, 3 ].map { OpaqueValue($0) }
    ).generate()
  }
}

SequenceTypeAlgorithms.test("underestimateCount/SequenceType/DefaultImplementation") {
  let s = SequenceWithDefaultUnderestimateCount()
  expectEqual(0, callGenericUnderestimatedCount(s))
}

struct SequenceWithCustomUnderestimateCount : SequenceType {
  init(underestimatedCount: Int) {
    self._underestimatedCount = underestimatedCount
  }

  func generate() -> MinimalSequence<OpaqueValue<Int>>.Generator {
    expectUnreachable()
    return MinimalSequence(
      [ 0xffff, 0xffff, 0xffff ].map { OpaqueValue($0) }
    ).generate()
  }

  func underestimateCount() -> Int {
    return _underestimatedCount
  }

  let _underestimatedCount: Int
}

SequenceTypeAlgorithms.test("underestimateCount/SequenceType/CustomImplementation") {
  if true {
    let s = SequenceWithCustomUnderestimateCount(underestimatedCount: 5)
    expectEqual(5, callGenericUnderestimatedCount(s))
  }
  if true {
    let s = SequenceWithCustomUnderestimateCount(underestimatedCount: 42)
    expectEqual(42, callGenericUnderestimatedCount(s))
  }
}

struct CollectionWithDefaultUnderestimateCount : CollectionType {
  init(count: Int) {
    self._count = count
  }

  func generate() -> MinimalGenerator<OpaqueValue<Int>> {
    expectUnreachable()
    return MinimalGenerator([])
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return OpaqueValue(0xffff)
  }

  var _count: Int
}

SequenceTypeAlgorithms.test("underestimateCount/CollectionType/DefaultImplementation") {
  if true {
    let s = CollectionWithDefaultUnderestimateCount(count: 0)
    expectEqual(0, callGenericUnderestimatedCount(s))
  }
  if true {
    let s = CollectionWithDefaultUnderestimateCount(count: 5)
    expectEqual(5, callGenericUnderestimatedCount(s))
  }
}

struct CollectionWithCustomUnderestimateCount : CollectionType {
  init(underestimatedCount: Int) {
    self._underestimatedCount = underestimatedCount
  }

  func generate() -> MinimalGenerator<OpaqueValue<Int>> {
    expectUnreachable()
    return MinimalGenerator([])
  }

  var startIndex: MinimalForwardIndex {
    expectUnreachable()
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: 0xffff)
  }

  var endIndex: MinimalForwardIndex {
    expectUnreachable()
    return MinimalForwardIndex(
      position: 0xffff, startIndex: 0, endIndex: 0xffff)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return OpaqueValue(0xffff)
  }

  func underestimateCount() -> Int {
    return _underestimatedCount
  }

  let _underestimatedCount: Int
}

SequenceTypeAlgorithms.test("underestimateCount/CollectionType/CustomImplementation") {
  if true {
    let s = CollectionWithCustomUnderestimateCount(underestimatedCount: 0)
    expectEqual(0, callGenericUnderestimatedCount(s))
  }
  if true {
    let s = CollectionWithCustomUnderestimateCount(underestimatedCount: 5)
    expectEqual(5, callGenericUnderestimatedCount(s))
  }
}

//===----------------------------------------------------------------------===//
// _copyToNativeArrayBuffer()
//===----------------------------------------------------------------------===//
SequenceTypeAlgorithms.test("_copyToNativeArrayBuffer/OverestimatedCount")
  .skip(.Custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let s = MinimalSequence<OpaqueValue<Int>>(
    [ 1, 2, 3 ].map { OpaqueValue($0) },
    underestimatedCount: .Value(4))
  expectCrashLater()
  let array = s._copyToNativeArrayBuffer()
  _blackHole(array)
}

//===----------------------------------------------------------------------===//
// CollectionType.generate(), CollectionType.Generator
//===----------------------------------------------------------------------===//

struct MinimalForwardCollectionWithDefaultGenerator : CollectionType {
  init(count: Int) {
    self._count = count
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    return OpaqueValue(i.position + 1)
  }

  var _count: Int
}

func callGenericGenerate<S : SequenceType>(sequence: S) -> S.Generator {
  return sequence.generate()
}

SequenceTypeAlgorithms.test("CollectionType.generate()/DefaultImplementation") {
  for count in [ 0, 5 ] {
    let collection = MinimalForwardCollectionWithDefaultGenerator(count: count)

    if true {
      // Check the return type of the function when called statically.
      var generator = collection.generate()
      expectType(
        IndexingGenerator<MinimalForwardCollectionWithDefaultGenerator>.self,
        &generator)
    }

    if true {
      // Check the return type of the function when called generically.
      var generator = callGenericGenerate(collection)
      expectType(
        IndexingGenerator<MinimalForwardCollectionWithDefaultGenerator>.self,
        &generator)
    }

    checkForwardCollection(
      Array(1..<count+1).map { OpaqueValue($0) } as [OpaqueValue<Int>],
      collection,
      { $0.value == $1.value },
      SourceLocStack().withCurrentLoc())
  }
}

struct MinimalForwardCollectionWithCustomGenerator : CollectionType {
  init(count: Int) {
    self._count = count
  }

  static var timesGenerateWasCalled: Int = 0

  func generate() -> MinimalGenerator<OpaqueValue<Int>> {
    ++MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled
    return MinimalGenerator<OpaqueValue<Int>>(
      Array(1..<_count+1).map { OpaqueValue($0) } as [OpaqueValue<Int>]
    )
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    return OpaqueValue(i.position + 1)
  }

  var _count: Int
}

SequenceTypeAlgorithms.test("CollectionType.generate()/CustomImplementation") {
  for count in [ 0, 5 ] {
    let collection = MinimalForwardCollectionWithCustomGenerator(count: count)

    if true {
      // Check the return type of the function when called statically.
      MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled = 0
      var generator = collection.generate()
      expectType(
        MinimalGenerator<OpaqueValue<Int>>.self,
        &generator)
      expectEqual(1, MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled)
    }

    if true {
      MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled = 0
      // Check the return type of the function when called generically.
      var generator = callGenericGenerate(collection)
      expectType(
        MinimalGenerator<OpaqueValue<Int>>.self,
        &generator)
      expectEqual(1, MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled)
    }

    checkForwardCollection(
      Array(1..<count+1).map { OpaqueValue($0) } as [OpaqueValue<Int>],
      collection,
      { $0.value == $1.value },
      resiliencyChecks: .none,
      SourceLocStack().withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// CollectionType.subscript(_: Range<Index>), CollectionType.SubSequence
//===----------------------------------------------------------------------===//

struct SubscriptRangeTest {
  let expected: [OpaqueValue<Int>]
  let collection: [OpaqueValue<Int>]
  let bounds: Range<Int>
  let loc: SourceLoc

  func boundsIn<C : CollectionType>(c: C) -> Range<C.Index> {
    let i = c.startIndex
    return Range(
      start: advance(i, numericCast(bounds.startIndex)),
      end: advance(i, numericCast(bounds.endIndex)))
  }

  init(
    expected: [Int], collection: [Int], bounds: Range<Int>,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected.map { OpaqueValue($0) }
    self.collection = collection.map { OpaqueValue($0) }
    self.bounds = bounds
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let subscriptRangeTests = [
  // Slice an empty collection.
  SubscriptRangeTest(
    expected: [],
    collection: [],
    bounds: 0..<0),

  // Slice to the full extent.
  SubscriptRangeTest(
    expected: [ 10, 20, 30 ],
    collection: [ 10, 20, 30 ],
    bounds: 0..<3),

  // Slice a prefix.
  SubscriptRangeTest(
    expected: [ 10, 20, ],
    collection: [ 10, 20, 30 ],
    bounds: 0..<2),

  // Slice a suffix.
  SubscriptRangeTest(
    expected: [ 20, 30 ],
    collection: [ 10, 20, 30 ],
    bounds: 1..<3),

  // Slice the middle part.
  SubscriptRangeTest(
    expected: [ 20 ],
    collection: [ 10, 20, 30 ],
    bounds: 1..<2),

  // Slice the middle part.
  SubscriptRangeTest(
    expected: [ 20, 30, 40 ],
    collection: [ 10, 20, 30, 40, 50, 60 ],
    bounds: 1..<4),
]

SequenceTypeAlgorithms.test("subscript(_: Range<Index>)/Dispatch") {
  let tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  _ = tester[tester.startIndex..<tester.endIndex]
  let log = tester.log
  let log2 = tester.log.subscriptRange
  expectCustomizable(tester, tester.log.subscriptRange)
}

SequenceTypeAlgorithms.test("subscript(_: Range<Index>)/Semantics") {
  for test in subscriptRangeTests {
    let c = DefaultedForwardCollection<OpaqueValue<Int>>(test.collection)
    var result = c[test.boundsIn(c)]

    // FIXME: improve checkForwardCollection to check the SubSequence type.
    checkForwardCollection(
      test.expected,
      result,
      { $0.value == $1.value },
      resiliencyChecks: .none,
      test.loc.withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// Slice<Base>
//===----------------------------------------------------------------------===//

func expectCollectionGeneratorIsIndexingGenerator<
  C : CollectionType
  where
  C.Generator == IndexingGenerator<C>
>(c: C) {}

func expectCollectionSubSequenceIsSelf<
  C : CollectionType
  where
  C.SubSequence == C
>(c: C) {}

func expectCollectionIndexIsMinimalForwardIndex<
  C : CollectionType
  where
  C.Index == MinimalForwardIndex
>(c: C) {}

SequenceTypeAlgorithms.test("Slice/AssociatedTypes") {
  let c = MinimalForwardCollection([ OpaqueValue(1) ])
  var slice = c[c.indices]
  expectType(
    Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
    &slice)

  expectCollectionType(slice)
  expectCollectionGeneratorIsIndexingGenerator(slice)
  expectCollectionSubSequenceIsSelf(slice)
  expectCollectionIndexIsMinimalForwardIndex(slice)
}

SequenceTypeAlgorithms.test("Slice.{startIndex,endIndex}") {
  for test in subscriptRangeTests {
    let c = MinimalForwardCollection(test.collection)
    var slice = c[c.indices]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &slice)
    let bounds = test.boundsIn(c)
    var result = slice[bounds]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &result)

    expectEqual(bounds.startIndex, result.startIndex)
    expectEqual(bounds.endIndex, result.endIndex)
  }
}

SequenceTypeAlgorithms.test("Slice.subscript(_: Index)") {
  for test in subscriptRangeTests {
    let c = MinimalForwardCollection(test.collection)
    var slice = c[c.indices]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &slice)
    let bounds = test.boundsIn(c)
    var result = slice[bounds]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &result)

    for i in bounds {
      var element = result[i]
      expectType(OpaqueValue<Int>.self, &element)
      expectEqual(c[i].value, element.value)
    }
  }
}

SequenceTypeAlgorithms.test("Slice.subscript(_: Range<Index>)") {
  for test in subscriptRangeTests {
    let c = MinimalForwardCollection(test.collection)
    var slice = c[c.indices]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &slice)

    var result = slice[test.boundsIn(slice)]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &result)

    checkForwardCollection(
      test.expected,
      result,
      { $0.value == $1.value },
      test.loc.withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// isEmpty
//===----------------------------------------------------------------------===//

struct MinimalForwardCollectionWithDefaultIsEmpty : CollectionType {
  init(count: Int) {
    self._count = count
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return OpaqueValue(i.position + 1)
  }

  var _count: Int
}

func callStaticIsEmpty(
  collection: MinimalForwardCollectionWithDefaultIsEmpty
) -> Bool {
  return collection.isEmpty
}

func callGenericIsEmpty<C : CollectionType>(collection: C) -> Bool {
  return collection.isEmpty
}

% for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("isEmpty/DefaultImplementation/${dispatch}") {
  if true {
    let s = MinimalForwardCollectionWithDefaultIsEmpty(count: 0)
    expectTrue(call${dispatch}IsEmpty(s))
  }
  if true {
    let s = MinimalForwardCollectionWithDefaultIsEmpty(count: 1)
    expectFalse(call${dispatch}IsEmpty(s))
  }
}

% end

struct MinimalForwardCollectionWithCustomIsEmpty : CollectionType {
  static var timesIsEmptyWasColled: Int = 0

  init(count: Int) {
    self._count = count
  }

  var startIndex: MinimalForwardIndex {
    expectUnreachable()
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    expectUnreachable()
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return OpaqueValue(i.position + 1)
  }

  var isEmpty: Bool {
    ++MinimalForwardCollectionWithCustomIsEmpty.timesIsEmptyWasColled
    return _count == 0
  }

  var _count: Int
}

func callStaticIsEmpty(
  collection: MinimalForwardCollectionWithCustomIsEmpty
) -> Bool {
  return collection.isEmpty
}

% for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("isEmpty/CustomImplementation/${dispatch}") {
  if true {
    let s = MinimalForwardCollectionWithCustomIsEmpty(count: 0)
    MinimalForwardCollectionWithCustomIsEmpty.timesIsEmptyWasColled = 0
    expectTrue(call${dispatch}IsEmpty(s))
    expectEqual(1, MinimalForwardCollectionWithCustomIsEmpty.timesIsEmptyWasColled)
  }
  if true {
    let s = MinimalForwardCollectionWithCustomIsEmpty(count: 1)
    MinimalForwardCollectionWithCustomIsEmpty.timesIsEmptyWasColled = 0
    expectFalse(call${dispatch}IsEmpty(s))
    expectEqual(1, MinimalForwardCollectionWithCustomIsEmpty.timesIsEmptyWasColled)
  }
}

% end

//===----------------------------------------------------------------------===//
// first
//===----------------------------------------------------------------------===//

struct MinimalForwardCollectionWithDefaultFirst : CollectionType {
  init(_ data: [OpaqueValue<Int>]) {
    self._data = MinimalForwardCollection(data)
  }

  var startIndex: MinimalForwardIndex {
    return _data.startIndex
  }

  var endIndex: MinimalForwardIndex {
    return _data.endIndex
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectEqual(startIndex, i)
    return _data[i]
  }

  var _data: MinimalForwardCollection<OpaqueValue<Int>>
}

func callStaticFirst(
  collection: MinimalForwardCollectionWithDefaultFirst
) -> OpaqueValue<Int>? {
  return collection.first
}

func callGenericFirst<C : CollectionType>(collection: C)
  -> C.Generator.Element? {

  return collection.first
}

% for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("first/DefaultImplementation/${dispatch}") {
  if true {
    let s = MinimalForwardCollectionWithDefaultFirst([])
    expectEmpty(call${dispatch}First(s))
  }
  if true {
    let s = MinimalForwardCollectionWithDefaultFirst([
      OpaqueValue<Int>(1, identity: 10),
      OpaqueValue<Int>(2, identity: 20)
    ])
    if let result = call${dispatch}First(s) {
      expectEqual(1, result.value)
      expectEqual(10, result.identity)
    } else {
      expectUnreachable()
    }
  }
}

% end

struct MinimalForwardCollectionWithCustomFirst : CollectionType {
  static var timesFirstWasColled: Int = 0

  init(_ data: [OpaqueValue<Int>]) {
    self._data = MinimalForwardCollection(data)
  }

  var startIndex: MinimalForwardIndex {
    expectUnreachable()
    return _data.startIndex
  }

  var endIndex: MinimalForwardIndex {
    expectUnreachable()
    return _data.endIndex
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return _data[i]
  }

  var first: OpaqueValue<Int>? {
    ++MinimalForwardCollectionWithCustomFirst.timesFirstWasColled
    return _data.first
  }

  var _data: MinimalForwardCollection<OpaqueValue<Int>>
}

func callStaticFirst(
  collection: MinimalForwardCollectionWithCustomFirst
) -> OpaqueValue<Int>? {
  return collection.first
}

% for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("first/CustomImplementation/${dispatch}") {
  if true {
    let s = MinimalForwardCollectionWithCustomFirst([])
    MinimalForwardCollectionWithCustomFirst.timesFirstWasColled = 0
    expectEmpty(call${dispatch}First(s))
    expectEqual(1, MinimalForwardCollectionWithCustomFirst.timesFirstWasColled)
  }
  if true {
    let s = MinimalForwardCollectionWithCustomFirst([
      OpaqueValue<Int>(1, identity: 10),
      OpaqueValue<Int>(2, identity: 20)
    ])
    MinimalForwardCollectionWithCustomFirst.timesFirstWasColled = 0
    if let result = call${dispatch}First(s) {
      expectEqual(1, result.value)
      expectEqual(10, result.identity)
    } else {
      expectUnreachable()
    }

    expectEqual(1, MinimalForwardCollectionWithCustomFirst.timesFirstWasColled)
  }
}

% end

//===----------------------------------------------------------------------===//
// last
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("last") {
  if true {
    let s = MinimalBidirectionalCollection<OpaqueValue<Int>>([])
    expectEmpty(s.last)
  }
  if true {
    let s = MinimalBidirectionalCollection<OpaqueValue<Int>>([
      OpaqueValue<Int>(1, identity: 10),
      OpaqueValue<Int>(2, identity: 20)
    ])
    if let result = s.last {
      expectEqual(2, result.value)
      expectEqual(20, result.identity)
    } else {
      expectUnreachable()
    }
  }
}

//===----------------------------------------------------------------------===//
// count
//===----------------------------------------------------------------------===//

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalForwardCollectionWith${Implementation}Count : CollectionType {
  init(count: Int) {
    self._count = count
  }

  var startIndex: MinimalForwardInt32Index {
    return MinimalForwardInt32Index(
      position: 0,
      startIndex: 0,
      endIndex: _count)
  }

  var endIndex: MinimalForwardInt32Index {
    return MinimalForwardInt32Index(
      position: _count,
      startIndex: 0,
      endIndex: _count)
  }

  subscript(i: MinimalForwardInt32Index) -> OpaqueValue<Int> {
    return OpaqueValue(i.position + 1)
  }

  var _count: Int

%   if Implementation == 'Custom':

  static var timesCountWasCalled: Int = 0

  var count: Int32 {
    ++MinimalForwardCollectionWithCustomCount.timesCountWasCalled
    return Int32(_count)
  }

%   end
}

% end

func callGenericCount<C : CollectionType>(collection: C) -> C.Index.Distance {
  return collection.count
}

% for Implementation in [ 'Default', 'Custom' ]:

SequenceTypeAlgorithms.test("CollectionType.count/${Implementation}Implementation") {
  for count in [ 0, 5 ] {
    let collection = MinimalForwardCollectionWith${Implementation}Count(count: count)

    if true {
      // Check the return type of the function when called statically.
%   if Implementation == 'Custom':
      MinimalForwardCollectionWithCustomCount.timesCountWasCalled = 0
%   end
      var result = collection.count
      expectType(Int32.self, &result)
      expectEqual(Int32(count), result)
%   if Implementation == 'Custom':
      expectEqual(1, MinimalForwardCollectionWithCustomCount.timesCountWasCalled)
%   end
    }

    if true {
      // Check the return type of the function when called generically.
%   if Implementation == 'Custom':
      MinimalForwardCollectionWithCustomCount.timesCountWasCalled = 0
%   end
      var result = callGenericCount(collection)
      expectType(Int32.self, &result)
      expectEqual(Int32(count), result)
%   if Implementation == 'Custom':
      expectEqual(1, MinimalForwardCollectionWithCustomCount.timesCountWasCalled)
%   end
    }

    checkForwardCollection(
      Array(1..<count+1).map { OpaqueValue($0) } as [OpaqueValue<Int>],
      collection,
      { $0.value == $1.value },
      SourceLocStack().withCurrentLoc())
  }
}

% end

//===----------------------------------------------------------------------===//
// find()
//===----------------------------------------------------------------------===//

func callStaticFind(
  collection: MinimalForwardCollection<MinimalEquatableValue>,
  _ element: MinimalEquatableValue
) -> MinimalForwardCollection<MinimalEquatableValue>.Index? {
  return collection.indexOf(element)
}

func callGenericFind<
  C : CollectionType where C.Generator.Element : Equatable
>(collection: C, _ element: C.Generator.Element) -> C.Index? {
  return collection.indexOf(element)
}

% for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("find/WhereElementIsEquatable/${dispatch}") {
  for test in findTests {
    let s = MinimalForwardCollection<MinimalEquatableValue>(test.sequence)
    expectEqual(
      test.expected,
      call${dispatch}Find(s, test.element).map { $0.position },
      stackTrace: test.loc.withCurrentLoc())
  }
}

% end

struct CollectionWithCustomFindMethod<
  Base: CollectionType where Base.Generator.Element : Equatable
> : CollectionType {
  var timesFindWasCalled = Box(0)

  typealias Element = Base.Generator.Element
  internal let _elements: [Element]

  init(_ elements: Base) {
    self._elements = elements.map { $0 }
  }

  func generate() -> MinimalGenerator<Element> {
    // Lie from our generate() method about sequence contents.
    // Tests using this type should not call generate() anyway.
    expectUnreachable()
    return MinimalSequence<Element>([]).generate()
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: 0, startIndex: 0, endIndex: _elements.endIndex)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _elements.endIndex,
      startIndex: 0,
      endIndex: _elements.endIndex)
  }

  subscript(i: MinimalForwardIndex) -> Element {
    return _elements[i.position]
  }

  func _customIndexOfEquatableElement(
    element: Element
  ) -> MinimalForwardIndex?? {
    ++timesFindWasCalled.value
    for i in _elements.indices {
      if _elements[i] == element {
        return MinimalForwardIndex(
          position: i,
          startIndex: 0,
          endIndex: _elements.endIndex)
      }
    }
    return Optional(nil)
  }
}

func callStaticFind(
  sequence: CollectionWithCustomFindMethod<[MinimalEquatableValue]>,
  _ element: MinimalEquatableValue
) -> CollectionWithCustomFindMethod<[MinimalEquatableValue]>.Index? {
  return sequence.indexOf(element)
}

% for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("find/WhereElementIsEquatable/CustomImplementation/${dispatch}") {
  for test in findTests {
    let s = CollectionWithCustomFindMethod(test.sequence)
    expectEqual(
      test.expected,
      call${dispatch}Find(s, test.element).map { $0.position },
      stackTrace: test.loc.withCurrentLoc())
    expectEqual(1, s.timesFindWasCalled.value)
  }
}

% end

// FIXME: underscores are a workaround for:
// <rdar://problem/20582358> Commenting out one line determines whether a
// completely different line type-checks
func callGenericFind_<
  C : CollectionType where C.Generator.Element : Equatable
>(collection: C, _ element: C.Generator.Element) -> C.Index? {
  return collection.indexOf(element)
}

func callStaticFind_(
  set: Set<MinimalHashableValue>,
  _ element: MinimalHashableValue
) -> Set<MinimalHashableValue>.Index? {
  return set.indexOf(element)
}

% for dispatch in [ 'Static', 'Generic' ]:

// FIXME: implement the same optimization for Dictionary.
// FIXME: move to the file where other Set tests live.
SequenceTypeAlgorithms.test("Set<T>.find/CustomImplementation/${dispatch}") {
  for test in findTests {
    let s = Set<MinimalHashableValue>(
      test.sequence.map { MinimalHashableValue($0.value) })
    MinimalHashableValue.timesEqualEqualWasCalled = 0
    MinimalHashableValue.timesHashValueWasCalled = 0
    expectEqual(
      test.expected
        .map { _ in MinimalHashableValue(test.element.value) },
      call${dispatch}Find_(s, MinimalHashableValue(test.element.value))
        .map { s[$0] },
      stackTrace: test.loc.withCurrentLoc())
    if test.sequence.isEmpty {
      expectEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: test.loc.withCurrentLoc())
      expectEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: test.loc.withCurrentLoc())
    } else {
      expectNotEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: test.loc.withCurrentLoc())
    }
    if test.expected != nil {
      expectNotEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: test.loc.withCurrentLoc())
    }
  }
}

% end

SequenceTypeAlgorithms.test("find/Predicate") {
  for test in findTests {
    let s = MinimalForwardCollection<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0.value) })
    let closureLifetimeTracker = LifetimeTracked(0)
    expectEqual(1, LifetimeTracked.instances)
    let result = s.indexOf {
      (candidate) in
      _blackHole(closureLifetimeTracker)
      return candidate.value == test.element.value
    }
    expectEqual(
      test.expected,
      result.map { $0.position },
      stackTrace: test.loc.withCurrentLoc())
  }
}

//===----------------------------------------------------------------------===//
// indices
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("indices") {
  if true {
    let s = MinimalForwardCollection<OpaqueValue<Int>>([])
    let indices = s.indices
    expectEqual(s.startIndex, indices.startIndex)
    expectEqual(s.endIndex, indices.endIndex)
  }
  if true {
    let s = MinimalForwardCollection<OpaqueValue<Int>>([
      OpaqueValue<Int>(1, identity: 10),
      OpaqueValue<Int>(2, identity: 20)
    ])
    let indices = s.indices
    expectEqual(s.startIndex, indices.startIndex)
    expectEqual(s.endIndex, indices.endIndex)
  }
}

//===----------------------------------------------------------------------===//
// MutableCollectionType
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// _withUnsafeMutableBufferPointerIfSupported()
//===----------------------------------------------------------------------===//

var _timesWithUnsafeMutableBufferPointerIfSupportedWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

%   for Traversal in [ 'Forward', 'RandomAccess' ]:

struct MinimalMutable${Traversal}CollectionWith${Implementation}WithUnsafeMutableBufferPointerIfSupported<T>
  : MutableCollectionType {

  init(_ data: [T]) {
    self._data = data
    self._count = data.count
  }

  var startIndex: Minimal${Traversal}Index {
    return Minimal${Traversal}Index(
      position: 0,
      startIndex: 0,
      endIndex: _count)
  }

  var endIndex: Minimal${Traversal}Index {
    return Minimal${Traversal}Index(
      position: _count,
      startIndex: 0,
      endIndex: _count)
  }

  subscript(i: Minimal${Traversal}Index) -> T {
    get {
      return _data[i.position]
    }
    set {
      _data[i.position] = newValue
    }
  }

  var _data: [T]

  // Store 'count' separately from 'data' to prevent inout violations in
  // '_withUnsafeMutableBufferPointerIfSupported'.
  var _count: Int

%     if Implementation == 'Custom':

  static var timesWithUnsafeMutableBufferPointerIfSupportedWasCalled: Int {
    get {
      return _timesWithUnsafeMutableBufferPointerIfSupportedWasCalled
    }
    set {
      _timesWithUnsafeMutableBufferPointerIfSupportedWasCalled = newValue
    }
  }

  mutating func _withUnsafeMutableBufferPointerIfSupported<R>(
    @noescape body: (inout UnsafeMutableBufferPointer<T>) -> R
  ) -> R? {
    ++MinimalMutable${Traversal}CollectionWith${Implementation}WithUnsafeMutableBufferPointerIfSupported.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled
    return _data._withUnsafeMutableBufferPointerIfSupported(body)
  }

%     end

}

%   end

% end

func callGenericWithUnsafeMutableBufferPointerIfSupported<
  C : MutableCollectionType, R
>(
  inout collection: C,
  @noescape body: (inout UnsafeMutableBufferPointer<C.Generator.Element>) -> R
) -> R? {
  return collection._withUnsafeMutableBufferPointerIfSupported(body)
}

% for Implementation in [ 'Default', 'Custom' ]:

func callStaticWithUnsafeMutableBufferPointerIfSupported<R>(
  inout collection: MinimalMutableForwardCollectionWith${Implementation}WithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>,
  @noescape body: (inout UnsafeMutableBufferPointer<OpaqueValue<Int>>) -> R
) -> R? {
  return collection._withUnsafeMutableBufferPointerIfSupported(body)
}

% end

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("MutableCollectionType._withUnsafeMutableBufferPointerIfSupported()/${Implementation}Implementation/${dispatch}") {
  let data = [ 1, 2, 3, 4, 5 ]
  var collection = MinimalMutableForwardCollectionWith${Implementation}WithUnsafeMutableBufferPointerIfSupported(
    data.map { OpaqueValue($0) })
  if true {
%     if Implementation == 'Custom':
    MinimalMutableForwardCollectionWith${Implementation}WithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled = 0
    var result = collection._withUnsafeMutableBufferPointerIfSupported {
      (inout buffer: UnsafeMutableBufferPointer<OpaqueValue<Int>>) in
      return OpaqueValue(Array(buffer))
    }
    expectType(Optional<OpaqueValue<Array<OpaqueValue<Int>>>>.self, &result)
    expectEqual(data, result!.value.map { $0.value })
    expectEqual(1, MinimalMutableForwardCollectionWith${Implementation}WithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled)
%     else:
    var result = collection._withUnsafeMutableBufferPointerIfSupported {
      (inout buffer: UnsafeMutableBufferPointer<OpaqueValue<Int>>) -> OpaqueValue<Int> in
      expectUnreachable()
      return OpaqueValue(42)
    }
    expectType(Optional<OpaqueValue<Int>>.self, &result)
    expectEmpty(result)
%     end
  }
}

%   end

% end

//===----------------------------------------------------------------------===//
// partition()
//===----------------------------------------------------------------------===//

func _forAllPermutationsImpl(
  index: Int, _ size: Int,
  inout _ perm: [Int], inout _ visited: [Bool],
  _ body: ([Int]) -> ()
) {
  if index == size {
    body(perm)
    return
  }

  for i in 0..<size {
    if visited[i] {
      continue
    }
    visited[i] = true
    perm[index] = i
    _forAllPermutationsImpl(index + 1, size, &perm, &visited, body)
    visited[i] = false
  }
}

/// Generate all permutations.
func forAllPermutations(size: Int, body: ([Int]) -> ()) {
  if size == 0 {
    return
  }

  var permutation = [Int](count: size, repeatedValue: 0)
  var visited = [Bool](count: size, repeatedValue: false)
  _forAllPermutationsImpl(0, size, &permutation, &visited, body)
}

/// Generate all permutations.
func forAllPermutations<S : SequenceType>(
  sequence: S, body: ([S.Generator.Element]) -> ()
) {
  let data = Array(sequence)
  forAllPermutations(data.count) {
    (indices: [Int]) in
    body(indices.map { data[$0] })
    return ()
  }
}

SequenceTypeAlgorithms.test("forAllPermutations") {
  if true {
    var permutations: [[Int]] = []
    forAllPermutations(0) {
      permutations.append($0)
    }
    expectEqualSequence([] as [[Int]], permutations, { $0 == $1 })
  }

  if true {
    var permutations: [[Int]] = []
    forAllPermutations(1) {
      permutations.append($0)
    }
    expectEqualSequence([ [ 0 ] ] as [[Int]], permutations, { $0 == $1 })
  }

  if true {
    var permutations: [[Int]] = []
    forAllPermutations(2) {
      permutations.append($0)
    }
    expectEqualSequence(
      [
        [ 0, 1 ],
        [ 1, 0 ]
      ] as [[Int]],
      permutations,
      { $0 == $1 })
  }

  if true {
    var permutations: [[Int]] = []
    forAllPermutations(3) {
      permutations.append($0)
    }
    expectEqualSequence(
      [
        [ 0, 1, 2 ],
        [ 0, 2, 1 ],
        [ 1, 0, 2 ],
        [ 1, 2, 0 ],
        [ 2, 0, 1 ],
        [ 2, 1, 0 ],
      ] as [[Int]],
      permutations,
      { $0 == $1 })
  }

  if true {
    var permutations: [[Int]] = []
    forAllPermutations([ 10, 20, 30 ]) {
      permutations.append($0)
    }
    expectEqualSequence(
      [
        [ 10, 20, 30 ],
        [ 10, 30, 20 ],
        [ 20, 10, 30 ],
        [ 20, 30, 10 ],
        [ 30, 10, 20 ],
        [ 30, 20, 10 ],
      ] as [[Int]],
      permutations,
      { $0 == $1 })
  }
}

public struct CustomComparableValue : Equatable, Comparable {
  public static var timesEqualEqualWasCalled: Int = 0
  public static var timesLessWasCalled: Int = 0

  public static var equalImpl: (Int, Int) -> Bool = { $0 == $1 }
  public static var lessImpl: (Int, Int) -> Bool = { $0 < $1 }

  public var value: Int
  public var identity: Int

  public init(_ value: Int) {
    self.value = value
    self.identity = 0
  }

  public init(_ value: Int, identity: Int) {
    self.value = value
    self.identity = identity
  }
}

public func == (
  lhs: CustomComparableValue,
  rhs: CustomComparableValue
) -> Bool {
  ++CustomComparableValue.timesEqualEqualWasCalled
  return CustomComparableValue.equalImpl(lhs.value, rhs.value)
}

public func < (
  lhs: CustomComparableValue,
  rhs: CustomComparableValue
) -> Bool {
  ++CustomComparableValue.timesLessWasCalled
  return CustomComparableValue.lessImpl(lhs.value, rhs.value)
}

// These tests are shared between partition() and sort().
struct PartitionExhaustiveTest {
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let partitionExhaustiveTests = [
  PartitionExhaustiveTest([]),
  PartitionExhaustiveTest([ 10 ]),
  PartitionExhaustiveTest([ 10, 10 ]),
  PartitionExhaustiveTest([ 10, 20 ]),
  PartitionExhaustiveTest([ 10, 10, 10 ]),
  PartitionExhaustiveTest([ 10, 10, 20 ]),
  PartitionExhaustiveTest([ 10, 20, 20 ]),
  PartitionExhaustiveTest([ 10, 20, 30 ]),
  PartitionExhaustiveTest([ 10, 10, 10, 10 ]),
  PartitionExhaustiveTest([ 10, 10, 10, 20 ]),
  PartitionExhaustiveTest([ 10, 10, 20, 20 ]),
  PartitionExhaustiveTest([ 10, 20, 30, 40 ]),
  PartitionExhaustiveTest([ 10, 10, 10, 10, 10 ]),
  PartitionExhaustiveTest([ 10, 10, 10, 20, 20 ]),
  PartitionExhaustiveTest([ 10, 10, 10, 20, 30 ]),
  PartitionExhaustiveTest([ 10, 10, 20, 20, 30 ]),
  PartitionExhaustiveTest([ 10, 10, 20, 30, 40 ]),
  PartitionExhaustiveTest([ 10, 20, 30, 40, 50 ]),
  PartitionExhaustiveTest([ 10, 20, 30, 40, 50, 60 ]),
  PartitionExhaustiveTest([ 10, 10, 10, 10, 10, 20, 20 ]),
  PartitionExhaustiveTest([ 10, 20, 30, 40, 50, 60, 70 ]),
]

% for predicate in [ False, True ]:

SequenceTypeAlgorithms.test("partition/${'Predicate' if predicate else 'WhereElementIsEquatable'}") {
%   if not predicate:
  CustomComparableValue.equalImpl = { $0 == $1 }
  CustomComparableValue.lessImpl = { $0 < $1 }
%   end

  for test in partitionExhaustiveTests {
    forAllPermutations(test.sequence) { (sequence) in
%   for slice in [ False, True ]:
      if true {
%     if predicate:
        var sequenceAsArray: [OpaqueValue<Int>] =
          zip(sequence, 0..<sequence.count).map {
            OpaqueValue($0, identity: $1)
          }

%       if slice:
        sequenceAsArray.insert(
          OpaqueValue(0xfffe, identity: 0xfffe), atIndex: 0)
        sequenceAsArray.append(OpaqueValue(0xffff, identity: 0xffff))
%       end

        var s = MinimalMutableRandomAccessCollection<OpaqueValue<Int>>(
          sequenceAsArray)

%       if slice:
        let indices = s.startIndex.successor()..<s.endIndex.predecessor()
%       else:
        let indices = s.indices
%       end

        let closureLifetimeTracker = LifetimeTracked(0)
        expectEqual(1, LifetimeTracked.instances)
        let pivot = s.partition(indices) {
          (lhs, rhs) in
          _blackHole(closureLifetimeTracker)
          return lhs.value < rhs.value
        }
%     else:
        var sequenceAsArray: [CustomComparableValue] =
          zip(sequence, 0..<sequence.count).map {
            CustomComparableValue($0, identity: $1)
          }

%       if slice:
        sequenceAsArray.insert(
          CustomComparableValue(0xfffe, identity: 0xfffe), atIndex: 0)
        sequenceAsArray.append(CustomComparableValue(0xffff, identity: 0xffff))
%       end

        var s = MinimalMutableRandomAccessCollection<CustomComparableValue>(
          sequenceAsArray)

%       if slice:
        let indices = s.startIndex.successor()..<s.endIndex.predecessor()
%       else:
        let indices = s.indices
%       end

        let pivot = s.partition(indices)
%     end

        // Check that we didn't lose any elements.
%       if slice:
        expectEqual(0xfffe, s.first!.identity)
        expectEqual(0xffff, s.last!.identity)
        var identities = s.map { $0.identity }
        identities.removeLast()
        identities.removeAtIndex(0)
        expectEqualsUnordered(0..<sequence.count, identities)
%       else:
        expectEqualsUnordered(0..<sequence.count, s.map { $0.identity })
%     end

        // All the elements in the first partition are less than the pivot
        // value.
        for i in indices.startIndex..<pivot {
          expectLT(s[i].value, s[pivot].value)
        }
        // All the elements in the second partition are greater or equal to
        // the pivot value.
        for i in pivot..<indices.endIndex {
          expectLE(s[pivot].value, s[i].value)
        }
      }
%   end
    }
  }
}

% end

% for predicate in [ False, True ]:

SequenceTypeAlgorithms.test("partition/${'Predicate' if predicate else 'WhereElementIsEquatable'}/InvalidOrderings") {
  withInvalidOrderings { (comparisonPredicate) in
    for i in 0..<7 {
      forAllPermutations(i) { (sequence) in
%   if predicate:
        var s = MinimalMutableRandomAccessCollection<OpaqueValue<Int>>(
          sequence.map { OpaqueValue($0) })
        let closureLifetimeTracker = LifetimeTracked(0)
        expectEqual(1, LifetimeTracked.instances)
        let pivot = s.partition(s.indices) {
          (lhs, rhs) in
          _blackHole(closureLifetimeTracker)
          return comparisonPredicate(lhs.value, rhs.value)
        }
%    else:
        var s = MinimalMutableRandomAccessCollection<CustomComparableValue>(
          sequence.map { CustomComparableValue($0) })
        CustomComparableValue.equalImpl = {
          !comparisonPredicate($0, $1) &&
          !comparisonPredicate($1, $0)
        }
        CustomComparableValue.lessImpl = {
          comparisonPredicate($0, $1)
        }
        let pivot = s.partition(s.indices)
%    end

        // Weak postcondition: we didn't lose any elements.
        expectEqualsUnordered(0..<i, s.map { $0.value })

        expectTrue(0 <= s[pivot].value && s[pivot].value < i)
      }
    }
  }
}

% end

//===----------------------------------------------------------------------===//
// sort()
//===----------------------------------------------------------------------===//

% for predicate in [ False, True ]:

SequenceTypeAlgorithms.test("sort/${'Predicate' if predicate else 'WhereElementIsEquatable'}") {
%   if not predicate:
  CustomComparableValue.equalImpl = { $0 == $1 }
  CustomComparableValue.lessImpl = { $0 < $1 }
%   end

  for test in partitionExhaustiveTests {
    forAllPermutations(test.sequence) { (sequence) in
      if true {
%   if predicate:
        var sequenceAsArray: [OpaqueValue<Int>] =
          zip(sequence, 0..<sequence.count).map {
            OpaqueValue($0, identity: $1)
          }

        var s = MinimalMutableRandomAccessCollection<OpaqueValue<Int>>(
          sequenceAsArray)

        let result = s.sort { $0.value < $1.value }
%   else:
        var sequenceAsArray: [CustomComparableValue] =
          zip(sequence, 0..<sequence.count).map {
            CustomComparableValue($0, identity: $1)
          }

        var s = MinimalMutableRandomAccessCollection<CustomComparableValue>(
          sequenceAsArray)

        let result = s.sort()
%   end

        // Check that we didn't lose any elements.
        expectEqualsUnordered(0..<sequence.count, result.map { $0.identity })

        // Check that the elements are sorted.
        if result.count >= 2 {
          for i in result.startIndex..<result.endIndex.predecessor() {
            expectLE(result[i].value, result[i.successor()].value)
          }
        }
      }
    }
  }
}

SequenceTypeAlgorithms.test("sort/CustomImplementation/${'Predicate' if predicate else 'WhereElementIsEquatable'}") {
%   if not predicate:
  CustomComparableValue.equalImpl = { $0 == $1 }
  CustomComparableValue.lessImpl = { $0 < $1 }
%   end

  let data = [ 5, 4, 3, 2, 1 ]
%     if predicate:
  var collection = MinimalMutableForwardCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported(
    data.map { MinimalComparableValue($0) })
%   else:
  var collection = MinimalMutableForwardCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported(
    data.map { OpaqueValue($0) })
%   end
  MinimalMutableForwardCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled = 0
%   if predicate:
  let result = collection.sort()
%   else:
  let result = collection.sort { $0.value < $1.value }
%   end
  // The collection is copied into an array before sorting.
  expectEqual(0, MinimalMutableForwardCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled)

  expectEqual([ 1, 2, 3, 4, 5 ], result.map { $0.value })
}

% end

% for predicate in [ False, True ]:

SequenceTypeAlgorithms.test("sort/${'Predicate' if predicate else 'WhereElementIsEquatable'}/InvalidOrderings") {
  withInvalidOrderings { (comparisonPredicate) in
    for i in 0..<7 {
      forAllPermutations(i) { (sequence) in
%   if predicate:
        var s = MinimalMutableRandomAccessCollection<OpaqueValue<Int>>(
          sequence.map { OpaqueValue($0) })
        let result = s.sort {
          comparisonPredicate($0.value, $1.value)
        }
%    else:
        var s = MinimalMutableRandomAccessCollection<CustomComparableValue>(
          sequence.map { CustomComparableValue($0) })
        CustomComparableValue.equalImpl = {
          !comparisonPredicate($0, $1) &&
          !comparisonPredicate($1, $0)
        }
        CustomComparableValue.lessImpl = {
          comparisonPredicate($0, $1)
        }
        let result = s.sort()
%    end

        // Weak postcondition: we didn't lose any elements.
        expectEqualsUnordered(0..<i, result.map { $0.value })
      }
    }
  }
}

SequenceTypeAlgorithms.test("partition/CustomImplementation/${'Predicate' if predicate else 'WhereElementIsEquatable'}") {
%   if not predicate:
  CustomComparableValue.equalImpl = { $0 == $1 }
  CustomComparableValue.lessImpl = { $0 < $1 }
%   end

  for test in partitionExhaustiveTests {
    forAllPermutations(test.sequence) { (sequence) in

%     if predicate:
      var sequenceAsArray: [OpaqueValue<Int>] =
        zip(sequence, 0..<sequence.count).map {
          OpaqueValue($0, identity: $1)
        }
%   else:
      var sequenceAsArray: [MinimalComparableValue] =
        zip(sequence, 0..<sequence.count).map {
          MinimalComparableValue($0, identity: $1)
        }
%   end
      var s = MinimalMutableRandomAccessCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported(
        sequenceAsArray)
      MinimalMutableRandomAccessCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled = 0
%   if predicate:
      let pivot = s.partition(s.indices) { $0.value < $1.value }
%   else:
      let pivot = s.partition(s.indices)
%   end
      expectEqual(1, MinimalMutableRandomAccessCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled)

      // Check that we didn't lose any elements.
      expectEqualsUnordered(0..<sequence.count, s.map { $0.identity })

      // All the elements in the first partition are less than the pivot
      // value.
      for i in s.startIndex..<pivot {
        expectLT(s[i].value, s[pivot].value)
      }
      // All the elements in the second partition are greater or equal to
      // the pivot value.
      for i in pivot..<s.endIndex {
        expectLE(s[pivot].value, s[i].value)
      }
    }
  }
}

% end

% for predicate in [ False, True ]:

SequenceTypeAlgorithms.test("sortInPlace/${'Predicate' if predicate else 'WhereElementIsEquatable'}") {
%   if not predicate:
  CustomComparableValue.equalImpl = { $0 == $1 }
  CustomComparableValue.lessImpl = { $0 < $1 }
%   end

  for test in partitionExhaustiveTests {
    forAllPermutations(test.sequence) { (sequence) in
      if true {
%   if predicate:
        var sequenceAsArray: [OpaqueValue<Int>] =
          zip(sequence, 0..<sequence.count).map {
            OpaqueValue($0, identity: $1)
          }

        var s = MinimalMutableRandomAccessCollection<OpaqueValue<Int>>(
          sequenceAsArray)

        s.sortInPlace { $0.value < $1.value }
%   else:
        var sequenceAsArray: [CustomComparableValue] =
          zip(sequence, 0..<sequence.count).map {
            CustomComparableValue($0, identity: $1)
          }

        var s = MinimalMutableRandomAccessCollection<CustomComparableValue>(
          sequenceAsArray)

        s.sortInPlace()
%   end

        // Check that we didn't lose any elements.
        expectEqualsUnordered(0..<sequence.count, s.map { $0.identity })

        // Check that the elements are sorted.
        if s.count >= 2 {
          for i in s.startIndex..<s.endIndex.predecessor() {
            expectLE(s[i].value, s[i.successor()].value)
          }
        }
      }
    }
  }
}

SequenceTypeAlgorithms.test("partition/CustomImplementation/${'Predicate' if predicate else 'WhereElementIsEquatable'}/InvalidOrderings") {
  withInvalidOrderings { (comparisonPredicate) in
    for i in 0..<7 {
      forAllPermutations(i) { (sequence) in

%   if not predicate:
        CustomComparableValue.equalImpl = { $0 == $1 }
        CustomComparableValue.lessImpl = { $0 < $1 }
%   end

%     if predicate:
        var sequenceAsArray: [OpaqueValue<Int>] =
          zip(sequence, 0..<sequence.count).map {
            OpaqueValue($0, identity: $1)
          }
%   else:
        var sequenceAsArray: [MinimalComparableValue] =
          zip(sequence, 0..<sequence.count).map {
            MinimalComparableValue($0, identity: $1)
          }
%   end
        var s = MinimalMutableRandomAccessCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported(
        sequenceAsArray)
        MinimalMutableRandomAccessCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled = 0
%   if predicate:
        let pivot = s.partition(s.indices) { $0.value < $1.value }
%   else:
        let pivot = s.partition(s.indices)
%   end
        expectEqual(1, MinimalMutableRandomAccessCollectionWithCustomWithUnsafeMutableBufferPointerIfSupported<OpaqueValue<Int>>.timesWithUnsafeMutableBufferPointerIfSupportedWasCalled)

        // Check that we didn't lose any elements.
        expectEqualsUnordered(0..<sequence.count, s.map { $0.identity })

        // All the elements in the first partition are less than the pivot
        // value.
        for i in s.startIndex..<pivot {
          expectLT(s[i].value, s[pivot].value)
        }
        // All the elements in the second partition are greater or equal to
        // the pivot value.
        for i in pivot..<s.endIndex {
          expectLE(s[pivot].value, s[i].value)
        }
      }
    }
  }
}

% end

% for predicate in [ False, True ]:

SequenceTypeAlgorithms.test("sortInPlace/${'Predicate' if predicate else 'WhereElementIsEquatable'}/InvalidOrderings") {
  withInvalidOrderings { (comparisonPredicate) in
    for i in 0..<7 {
      forAllPermutations(i) { (sequence) in
%   if predicate:
        var s = MinimalMutableRandomAccessCollection<OpaqueValue<Int>>(
          sequence.map { OpaqueValue($0) })
        s.sortInPlace {
          comparisonPredicate($0.value, $1.value)
        }
%    else:
        var s = MinimalMutableRandomAccessCollection<CustomComparableValue>(
          sequence.map { CustomComparableValue($0) })
        CustomComparableValue.equalImpl = {
          !comparisonPredicate($0, $1) &&
          !comparisonPredicate($1, $0)
        }
        CustomComparableValue.lessImpl = {
          comparisonPredicate($0, $1)
        }
        s.sortInPlace()
%    end

        // Weak postcondition: we didn't lose any elements.
        expectEqualsUnordered(0..<i, s.map { $0.value })
      }
    }
  }
}

% end

runAllTests()

