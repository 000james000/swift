// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Algorithm.swift
// RUN: %S/../../utils/line-directive %t/Algorithm.swift -- %target-build-swift %t/Algorithm.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/Algorithm.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest
import SwiftPrivate

var Algorithm = TestSuite("Algorithm")

// FIXME(prext): remove this conformance.
extension String.UnicodeScalarView : Equatable {}

// FIXME(prext): remove this function.
public func == (
  lhs: String.UnicodeScalarView, rhs: String.UnicodeScalarView) -> Bool {
  return Array(lhs) == Array(rhs)
}

// FIXME(prext): move this struct to the point of use.
struct StartsWithTest {
  let expected: Bool
  let sequence: [Int]
  let prefix: [Int]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverPrefix: [Int]
  let loc: SourceLoc

  init(
    _ expected: Bool, _ sequence: [Int], _ prefix: [Int],
    _ expectedLeftoverSequence: [Int],
    _ expectedLeftoverPrefix: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.prefix = prefix
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverPrefix = expectedLeftoverPrefix
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let startsWithTests = [
  // Corner cases.
  StartsWithTest(true, [], [], [], []),

  StartsWithTest(false, [], [ 1 ], [], []),
  StartsWithTest(true, [ 1 ], [], [], []),

  // Equal sequences.
  StartsWithTest(true, [ 1 ], [ 1 ], [], []),
  StartsWithTest(true, [ 1, 2 ], [ 1, 2 ], [], []),

  // Proper prefix.
  StartsWithTest(true, [ 0, 1, 2 ], [ 0, 1 ], [], []),
  StartsWithTest(false, [ 0, 1 ], [ 0, 1, 2 ], [], []),

  StartsWithTest(true, [ 1, 2, 3, 4 ], [ 1, 2 ], [ 4 ], []),
  StartsWithTest(false, [ 1, 2 ], [ 1, 2, 3, 4 ], [], [ 4 ]),

  // Not a prefix.
  StartsWithTest(false, [ 1, 2, 3, 4 ], [ 1, 2, 10 ], [ 4 ], []),
  StartsWithTest(false, [ 1, 2, 10 ], [ 1, 2, 3, 4 ], [], [ 4 ]),

  StartsWithTest(false, [ 1, 2, 3, 4, 10 ], [ 1, 2, 10 ], [ 4, 10 ], []),
  StartsWithTest(false, [ 1, 2, 10 ], [ 1, 2, 3, 4, 10 ], [], [ 4, 10 ]),
]

Algorithm.test("min,max") {
  expectEqual(2, min(3, 2))
  expectEqual(3, min(3, 7, 5))
  expectEqual(3, max(3, 2))
  expectEqual(7, max(3, 7, 5))

  // FIXME: add tests that check that min/max return the
  // first element of the sequence (by reference equailty) that satisfy the
  // condition.
}

Algorithm.test("sorted/strings")
  .xfail(.LinuxAny(reason: "String comparison: ICU vs. Foundation"))
  .code {
  expectEqual(
    [ "Banana", "apple", "cherry" ],
    [ "apple", "Banana", "cherry" ].sort())

  let s = ["apple", "Banana", "cherry"].sort() {
    $0.characters.count > $1.characters.count
  }
  expectEqual([ "Banana", "cherry", "apple" ], s)
}

// A wrapper around Array<T> that disables any type-specific algorithm
// optimizations and forces bounds checking on.
struct A<T> : MutableSliceable {
  init(_ a: Array<T>) {
    impl = a
  }

  var startIndex: Int {
    return 0
  }

  var endIndex: Int {
    return impl.count
  }

  func generate() -> Array<T>.Generator {
    return impl.generate()
  }

  subscript(i: Int) -> T {
    get {
      expectTrue(i >= 0 && i < impl.count)
      return impl[i]
    }
    set (x) {
      expectTrue(i >= 0 && i < impl.count)
      impl[i] = x
    }
  }

  subscript(r: Range<Int>) -> Array<T>.SubSequence {
    get {
      expectTrue(r.startIndex >= 0 && r.startIndex <= impl.count)
      expectTrue(r.endIndex >= 0 && r.endIndex <= impl.count)
      return impl[r]
    }
    set (x) {
      expectTrue(r.startIndex >= 0 && r.startIndex <= impl.count)
      expectTrue(r.endIndex >= 0 && r.endIndex <= impl.count)
      impl[r] = x
    }
  }

  var impl: Array<T>
}

func randomArray() -> A<Int> {
  let count = Int(rand32(exclusiveUpperBound: 50))
  return A(randArray(count))
}

Algorithm.test("invalidOrderings") {
  withInvalidOrderings {
    var a = randomArray()
    _blackHole(a.sort($0))
  }
  withInvalidOrderings {
    var a: A<Int>
    a = randomArray()
    a.partition(a.indices, isOrderedBefore: $0)
  }
  /*
  // FIXME: Disabled due to <rdar://problem/17734737> Unimplemented:
  // abstraction difference in l-value
  withInvalidOrderings {
    var a = randomArray()
    var pred = $0
    _insertionSort(&a, a.indices, &pred)
  }
  */
}

// The routine is based on http://www.cs.dartmouth.edu/~doug/mdmspe.pdf
func makeQSortKiller(len: Int) -> [Int] {
  var candidate: Int = 0
  var keys = [Int:Int]()
  func Compare(x: Int, y : Int) -> Bool {
    if keys[x] == nil && keys[y] == nil {
      if (x == candidate) {
        keys[x] = keys.count
      } else {
        keys[y] = keys.count
      }
    }
    if keys[x] == nil {
      candidate = x
      return true
    }
    if keys[y] == nil {
      candidate = y
      return false
    }
    return keys[x]! > keys[y]!
  }

  var ary = [Int](count: len, repeatedValue:0)
  var ret = [Int](count: len, repeatedValue:0)
  for i in 0..<len { ary[i] = i }
  ary = ary.sort(Compare)
  for i in 0..<len {
    ret[ary[i]] = i
  }
  return ret
}

Algorithm.test("sorted/complexity") {
  var ary: [Int] = []

  // Check performance of sort on array of repeating values
  var comparisons_100 = 0
  ary = [Int](count: 100, repeatedValue: 0)
  ary.sortInPlace { comparisons_100++; return $0 < $1 }
  var comparisons_1000 = 0
  ary = [Int](count: 1000, repeatedValue: 0)
  ary.sortInPlace { comparisons_1000++; return $0 < $1 }
  expectTrue(comparisons_1000/comparisons_100 < 20)

  // Try to construct 'bad' case for quicksort, on which the algorithm
  // goes quadratic.
  comparisons_100 = 0
  ary = makeQSortKiller(100)
  ary.sortInPlace { comparisons_100++; return $0 < $1 }
  comparisons_1000 = 0
  ary = makeQSortKiller(1000)
  ary.sortInPlace { comparisons_1000++; return $0 < $1 }
  expectTrue(comparisons_1000/comparisons_100 < 20)
}

Algorithm.test("sorted/return type") {
  let x: Array = ([5, 4, 3, 2, 1] as ArraySlice).sort()
}

var SequenceTypeAlgorithms = TestSuite("SequenceTypeAlgorithms")

//===--- Demonstrate technique for testing generic dispatching ------------===//
// A counter we can use to record calls to our non-customizable operation

var _nonCustomizableOperation = TypeIndexed(0)
extension SequenceLog {
  static var nonCustomizableOperation : TypeIndexed<Int> {
    get {return _nonCustomizableOperation}
    set {_nonCustomizableOperation = newValue}
  }
}

// Add a non-customizable operation to sequence
extension SequenceType {
  func nonCustomizableOperation() {}
}

// Extend LoggingSequence to shadow the new operation.  When
// requirements are added to a protocol 'P', there should be an
// implementation in 'InstrumentedP' that does some bookeeping for
// testing (like counting calls to the operation) and then dispatches
// to the same operation on its 'base' member.  InstrumentedSequence
// already contains implementations of all the SequenceType
// requirements.
extension LoggingSequence {
  func nonCustomizableOperation() {
    ++Log.nonCustomizableOperation[self.dynamicType]
    return base.nonCustomizableOperation()
  }
}

SequenceTypeAlgorithms.test("Demonstration/NotCustomizable") {
  let tester = SequenceLog.dispatchTester([OpaqueValue(1)])

  tester.nonCustomizableOperation()
  
  expectNotCustomizable(tester, tester.log.nonCustomizableOperation)
}

//===----------------------------------------------------------------------===//

// FIXME: add tests for:
//
// - Array, ContiguousArray and ArraySlice as inputs.  These types special-case
// a lot of collection behavior for performance reasons.  Not to even mention
// that these are important types to test in any case.
//
// - NaN behavior of floating point types, combined with these generic
// algorithms, should make sense if possible.  For example,
// [1.0, Double.NaN].startsWith([1.0, 2.0]) should be false.

//===----------------------------------------------------------------------===//
// Indexable
//===----------------------------------------------------------------------===//

/// A minimal model of `Indexable`.
///
/// All the interesting semantic features of `Indexable` are covered
/// by tests for `CollectionType`.
struct MinimalIndexable {
  var startIndex: MinimalForwardIndex {
    fatalError("implement")
  }
  var endIndex: MinimalForwardIndex {
    fatalError("implement")
  }
  subscript(position: MinimalForwardIndex) -> OpaqueValue<Int> {
    fatalError("implement")
  }
}

/// Test that `Indexable` has an associated `Index` type.
/// Test that `Index` is used in the appropriate places in the API.
func getIndexableIndexThroughGeneric<I : Indexable>(i: I) {
  var index = expectForwardIndexType(i.startIndex)
  index = i.endIndex // `endIndex` has the same type.
  i[index] // `subscript()` has the same argument type.
  expectType(I.Index.self, &index)
}

func testCollectionRefinesIndexable<C : CollectionType>(c: C) {
  expectIndexable(c)
}

//===----------------------------------------------------------------------===//
// GeneratorSequence
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
protocol TestProtocol1 {}

extension GeneratorSequence where Base : TestProtocol1 {
  var _baseIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/GeneratorType/empty") {
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkGenerator(data, g, resiliencyChecks: .none) { $0.value == $1.value }
  }
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkGenerator(data, g) { $0.value == $1.value }
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/GeneratorType") {
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkGenerator(data, g, resiliencyChecks: .none) { $0.value == $1.value }
  }
  if true {
    let data: [OpaqueValue<Int>] = []
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkGenerator(data, g) { $0.value == $1.value }
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/SequenceType/empty") {
  if true {
    let data = [ 10, 20, 30 ].map(OpaqueValue.init)
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkSequence(data, g, resiliencyChecks: .none) { $0.value == $1.value }
  }
  if true {
    let data = [ 10, 20, 30 ].map(OpaqueValue.init)
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkSequence(data, g) { $0.value == $1.value }
  }
}

SequenceTypeAlgorithms.test("GeneratorSequence/SequenceType") {
  if true {
    let data = [ 10, 20, 30 ].map(OpaqueValue.init)
    let base = MinimalGenerator(data)
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<MinimalGenerator<OpaqueValue<Int>>>.self,
      &g)
    checkSequence(data, g, resiliencyChecks: .none) { $0.value == $1.value }
  }
  if true {
    let data = [ 10, 20, 30 ].map(OpaqueValue.init)
    let base = data.generate()
    var g = GeneratorSequence(base)
    expectType(
      GeneratorSequence<IndexingGenerator<Array<OpaqueValue<Int>>>>.self,
      &g)
    checkSequence(data, g) { $0.value == $1.value }
  }
}

//===----------------------------------------------------------------------===//
// enumerate()
//===----------------------------------------------------------------------===//

// Check that the generic parameter is called 'Base'.
extension EnumerateGenerator where Base : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

extension EnumerateSequence where Base : TestProtocol1 {
  var _elementIsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

struct EnumerateTest {
  let expected: [(Int, Int)]
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ expected: [(Int, Int)], _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expected = expected
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }
}

let enumerateTests = [
  EnumerateTest([], []),
  EnumerateTest([ (0, 10) ], [ 10 ]),
  EnumerateTest([ (0, 10), (1, 20) ], [ 10, 20 ]),
  EnumerateTest([ (0, 10), (1, 20), (2, 30) ], [ 10, 20, 30 ]),
]

SequenceTypeAlgorithms.test("enumerate") {
  typealias Element = (index: Int, element: OpaqueValue<Int>)
  func compareElements(lhs: Element, rhs: Element) -> Bool {
    return lhs.0 == rhs.0 && lhs.1.value == rhs.1.value
  }

  for test in enumerateTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    var result = s.enumerate()
    expectType(
      EnumerateSequence<MinimalSequence<OpaqueValue<Int>>>.self,
      &result)
    
    checkSequence(
      test.expected.map {
        (index: $0.0, element: OpaqueValue($0.1))
      } as [Element],
      result,
      resiliencyChecks: .none, sameValue: compareElements)
    expectEqual([], s.map { $0.value }, "sequence should be consumed")
  }
}

//===----------------------------------------------------------------------===//
// minElement(), maxElement()
//===----------------------------------------------------------------------===//

struct MinMaxElementTest {
  let expectedMinValue: Int?
  let expectedMinIndex: Int?
  let expectedMaxValue: Int?
  let expectedMaxIndex: Int?
  let sequence: [Int]
  let loc: SourceLoc

  init(
    minValue expectedMinValue: Int?,
    index expectedMinIndex: Int?,
    maxValue expectedMaxValue: Int?,
    index expectedMaxIndex: Int?,
    _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expectedMinValue = expectedMinValue
    self.expectedMinIndex = expectedMinIndex
    self.expectedMaxValue = expectedMaxValue
    self.expectedMaxIndex = expectedMaxIndex
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }
}

let minMaxElementTests = [
  MinMaxElementTest(
    minValue: nil, index: nil,
    maxValue: nil, index: nil,
    []),
  MinMaxElementTest(
    minValue: 42, index: 0,
    maxValue: 42, index: 0,
    [ 42 ]),
  MinMaxElementTest(
    minValue: -1, index: 1,
    maxValue: 30, index: 2,
    [ 10, -1, 30, -1, 30 ]),
  MinMaxElementTest(
    minValue: -2, index: 5,
    maxValue: 31, index: 6,
    [ 10, -1, 30, -1, 30, -2, 31 ]),
]

% for algorithmKind in [ 'min', 'max' ]:
%   AlgorithmKind = algorithmKind.capitalize()

SequenceTypeAlgorithms.test("${algorithmKind}Element/WhereElementIsComparable") {
  for test in minMaxElementTests {
    let s = MinimalSequence<MinimalComparableValue>(
      test.sequence.enumerate().map {
        MinimalComparableValue($1, identity: $0)
      })
    var maybeResult = s.${algorithmKind}Element()
    expectType(Optional<MinimalComparableValue>.self, &maybeResult)
    if let result = maybeResult {
      expectEqual(
        test.expected${AlgorithmKind}Value!, result.value,
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expected${AlgorithmKind}Index!, result.identity,
        stackTrace: SourceLocStack().with(test.loc))
    } else {
      expectEmpty(
        test.expected${AlgorithmKind}Value,
        stackTrace: SourceLocStack().with(test.loc))
      expectEmpty(
        test.expected${AlgorithmKind}Index,
        stackTrace: SourceLocStack().with(test.loc))
    }
    expectEqual([], s.map { $0.value }, "sequence should be consumed")
  }
}

SequenceTypeAlgorithms.test("${algorithmKind}Element/Predicate") {
  for test in minMaxElementTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.enumerate().map {
        OpaqueValue($1, identity: $0)
      })
    var timesClosureWasCalled = 0
    var maybeResult = s.${algorithmKind}Element {
      (lhs, rhs) -> Bool in
      ++timesClosureWasCalled
      return lhs.value < rhs.value
    }
    expectType(Optional<OpaqueValue<Int>>.self, &maybeResult)
    if let result = maybeResult {
      expectEqual(
        test.expected${AlgorithmKind}Value!, result.value,
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expected${AlgorithmKind}Index!, result.identity,
        stackTrace: SourceLocStack().with(test.loc))
    } else {
      expectEmpty(
        test.expected${AlgorithmKind}Value,
        stackTrace: SourceLocStack().with(test.loc))
      expectEmpty(
        test.expected${AlgorithmKind}Index,
        stackTrace: SourceLocStack().with(test.loc))
    }
    expectEqual([], s.map { $0.value }, "sequence should be consumed")
    expectEqual(
      max(0, test.sequence.count - 1), timesClosureWasCalled,
      "maxElement() should be eager and should only call its predicate"
      + " once per element")
  }
}

% end

//===----------------------------------------------------------------------===//
// startsWith()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("startsWith/WhereElementIsEquatable") {
  for test in startsWithTests {
    if true {
      let s = MinimalSequence<MinimalEquatableValue>(
        test.sequence.map(MinimalEquatableValue.init))
      let prefix = MinimalSequence<MinimalEquatableValue>(
        test.prefix.map(MinimalEquatableValue.init))
      expectEqual(
        test.expected,
        s.startsWith(prefix),
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }

    // Use different types for the sequence and prefix.
    if true {
      let s = MinimalForwardCollection<MinimalEquatableValue>(
        test.sequence.map(MinimalEquatableValue.init))
      let prefix = MinimalSequence<MinimalEquatableValue>(
        test.prefix.map(MinimalEquatableValue.init))
      expectEqual(
        test.expected,
        s.startsWith(prefix),
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

SequenceTypeAlgorithms.test("startsWith/Predicate") {
  for test in startsWithTests {
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init))
      let prefix = MinimalSequence<OpaqueValue<Int>>(
        test.prefix.map(OpaqueValue.init))
      expectEqual(
        test.expected,
        s.startsWith(prefix) { $0.value == $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map { OpaqueValue($0 * 2) })
      let prefix = MinimalSequence<OpaqueValue<Int>>(
        test.prefix.map(OpaqueValue.init))
      expectEqual(
        test.expected,
        s.startsWith(prefix) { $0.value / 2 == $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value / 2 },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }

    // Use different types for the sequence and prefix.
    if true {
      let s = MinimalForwardCollection<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init))
      let prefix = MinimalSequence<OpaqueValue<Int>>(
        test.prefix.map(OpaqueValue.init))
      expectEqual(
        test.expected,
        s.startsWith(prefix) { $0.value == $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverPrefix, prefix.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

//===----------------------------------------------------------------------===//
// equal()
//===----------------------------------------------------------------------===//

struct ElementsEqualTest {
  let expected: Bool
  let sequence: [Int]
  let other: [Int]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverOther: [Int]
  let loc: SourceLoc

  init(
    _ expected: Bool, _ sequence: [Int], _ other: [Int],
    _ expectedLeftoverSequence: [Int],
    _ expectedLeftoverOther: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expected = expected
    self.sequence = sequence
    self.other = other
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverOther = expectedLeftoverOther
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }

  func flip() -> ElementsEqualTest {
    return ElementsEqualTest(
      expected, other, sequence,
      expectedLeftoverOther, expectedLeftoverSequence,
      file: loc.file, line: loc.line, comment: " (flipped)")
  }
}

let elementsEqualTests: [ElementsEqualTest] = [
  ElementsEqualTest(true, [], [], [], []),

  ElementsEqualTest(false, [ 1 ], [], [], []),
  ElementsEqualTest(false, [], [ 1 ], [], []),

  ElementsEqualTest(false, [ 1, 2 ], [], [ 2 ], []),
  ElementsEqualTest(false, [], [ 1, 2 ], [], [ 2 ]),

  ElementsEqualTest(false, [ 1, 2, 3, 4 ], [ 1, 2 ], [ 4 ], []),
  ElementsEqualTest(false, [ 1, 2 ], [ 1, 2, 3, 4 ], [], [ 4 ]),
].flatMap { [ $0, $0.flip() ] }

SequenceTypeAlgorithms.test("elementsEqual/WhereElementIsEquatable") {
  for test in elementsEqualTests {
    if true {
      let s = MinimalSequence<MinimalEquatableValue>(
        test.sequence.map(MinimalEquatableValue.init))
      let other = MinimalSequence<MinimalEquatableValue>(
        test.other.map(MinimalEquatableValue.init))
      expectEqual(
        test.expected,
        s.elementsEqual(other),
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<MinimalEquatableValue>(
        test.sequence.map(MinimalEquatableValue.init))
      let other = MinimalSequence<MinimalEquatableValue>(
        test.other.map(MinimalEquatableValue.init))
      expectEqual(
        test.expected,
        s.elementsEqual(other),
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

SequenceTypeAlgorithms.test("elementsEqual/Predicate") {
  for test in elementsEqualTests {
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init))
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map(OpaqueValue.init))
      expectEqual(
        test.expected,
        s.elementsEqual(other) { $0.value == $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init))
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map(OpaqueValue.init))
      expectEqual(
        test.expected,
        s.elementsEqual(other) { $0.value == $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

//===----------------------------------------------------------------------===//
// lexicographicalCompare()
//===----------------------------------------------------------------------===//

struct LexicographicalCompareTest {
  let expected: ExpectedComparisonResult
  let sequence: [Int]
  let other: [Int]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverOther: [Int]
  let loc: SourceLoc

  init(
    _ expected: ExpectedComparisonResult, _ sequence: [Int], _ other: [Int],
    _ expectedLeftoverSequence: [Int],
    _ expectedLeftoverOther: [Int],
    file: String = __FILE__, line: UWord = __LINE__,
    comment: String = ""
  ) {
    self.expected = expected
    self.sequence = sequence
    self.other = other
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverOther = expectedLeftoverOther
    self.loc = SourceLoc(file, line, comment: "test data" + comment)
  }

  func flip() -> LexicographicalCompareTest {
    return LexicographicalCompareTest(
      expected.flip(), other, sequence,
      expectedLeftoverOther, expectedLeftoverSequence,
      file: loc.file, line: loc.line, comment: " (flipped)")
  }
}

let lexicographicalCompareTests = [
  LexicographicalCompareTest(.EQ, [], [], [], []),
  LexicographicalCompareTest(.EQ, [ 1 ], [ 1 ], [], []),

  LexicographicalCompareTest(.GT, [ 1 ], [], [], []),

  LexicographicalCompareTest(.GT, [ 1 ], [ 0 ], [], []),
  LexicographicalCompareTest(.EQ, [ 1 ], [ 1 ], [], []),
  LexicographicalCompareTest(.LT, [ 1 ], [ 2 ], [], []),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [], [ 2 ], []),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0 ], [ 2 ], []),
  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 1 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2 ], [ 2 ], []),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 0 ], [ 2 ], [ 0 ]),
  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 1, 0 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 0 ], [ 2 ], [ 0 ]),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 1 ], [ 2 ], [ 1 ]),
  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 1, 1 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 1 ], [ 2 ], [ 1 ]),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 2 ], [ 2 ], [ 2 ]),
  LexicographicalCompareTest(.EQ, [ 1, 2 ], [ 1, 2 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 2 ], [ 2 ], [ 2 ]),

  LexicographicalCompareTest(.GT, [ 1, 2 ], [ 0, 3 ], [ 2 ], [ 3 ]),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 1, 3 ], [], []),
  LexicographicalCompareTest(.LT, [ 1, 2 ], [ 2, 3 ], [ 2 ], [ 3 ]),
].flatMap { [ $0, $0.flip() ] }

SequenceTypeAlgorithms.test("lexicographicalCompare/WhereElementIsComparable") {
  for test in lexicographicalCompareTests {
    if true {
      let s = MinimalSequence<MinimalComparableValue>(
        test.sequence.map(MinimalComparableValue.init))
      let other = MinimalSequence<MinimalComparableValue>(
        test.other.map(MinimalComparableValue.init))
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other),
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<MinimalComparableValue>(
        test.sequence.map(MinimalComparableValue.init))
      let other = MinimalSequence<MinimalComparableValue>(
        test.other.map(MinimalComparableValue.init))
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other),
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

SequenceTypeAlgorithms.test("lexicographicalCompare/Predicate") {
  for test in lexicographicalCompareTests {
    if true {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init))
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map(OpaqueValue.init))
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other) { $0.value < $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverSequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }

    // Use different types for the sequence and other.
    if true {
      let s = MinimalForwardCollection<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init))
      let other = MinimalSequence<OpaqueValue<Int>>(
        test.other.map(OpaqueValue.init))
      expectEqual(
        test.expected.isLT(),
        s.lexicographicalCompare(other) { $0.value < $1.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.sequence, s.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        test.expectedLeftoverOther, other.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

//===----------------------------------------------------------------------===//
// contains()
//===----------------------------------------------------------------------===//

typealias StrictSequenceOfEquatable = MinimalSequence<MinimalEquatableValue>

// FIXME: rename in StdlibUnittest
// typealias StrictSequence = MinimalSequence

SequenceTypeAlgorithms.test("contains/WhereElementIsEquatable/dispatch") {
  let tester = SequenceLog.dispatchTester([MinimalEquatableValue(1)])
  _ = tester.contains(MinimalEquatableValue(1))
  expectCustomizable(tester, tester.log._customContainsEquatableElement)
}

func callStaticContains(
  set: Set<MinimalHashableValue>,
  _ element: MinimalHashableValue
) -> Bool {
  return set.contains(element)
}

func callGenericContains<
  S : SequenceType where S.Generator.Element : Equatable
>(sequence: S, _ element: S.Generator.Element) -> Bool {
  return sequence.contains(element)
}

% for dispatch in [ 'Static', 'Generic' ]:

// FIXME: implement the same optimization for Dictionary.
// FIXME: move to the file where other Set tests live.
SequenceTypeAlgorithms.test("Set<T>.contains/CustomImplementation/${dispatch}") {
  for test in findTests {
    let s = Set<MinimalHashableValue>(
      test.sequence.map { MinimalHashableValue($0.value) })
    MinimalHashableValue.timesEqualEqualWasCalled = 0
    MinimalHashableValue.timesHashValueWasCalled = 0
    expectEqual(
      test.expected != nil,
      call${dispatch}Contains(s, MinimalHashableValue(test.element.value)),
      stackTrace: SourceLocStack().with(test.loc))
    if test.sequence.isEmpty {
      expectEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
    } else {
      expectNotEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
    }
    if test.expected != nil {
      expectNotEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

% end

SequenceTypeAlgorithms.test("contains/Predicate") {
  for test in findTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map { OpaqueValue($0.value) })
    expectEqual(
      test.expected != nil,
      s.contains { $0.value == test.element.value },
      stackTrace: SourceLocStack().with(test.loc))
    expectEqual(
      test.expectedLeftoverSequence.map { $0.value }, s.map { $0.value },
      stackTrace: SourceLocStack().with(test.loc))
  }
}

//===----------------------------------------------------------------------===//
// reduce()
//===----------------------------------------------------------------------===//

struct ReduceTest {
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let reduceTests = [
  ReduceTest([]),
  ReduceTest([ 1 ]),
  ReduceTest([ 1, 2 ]),
  ReduceTest([ 1, 2, 3 ]),
  ReduceTest([ 1, 2, 3, 4, 5, 6, 7 ]),
]

SequenceTypeAlgorithms.test("reduce") {
  for test in reduceTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    var timesClosureWasCalled = 0
    let result = s.reduce(OpaqueValue<[Int]>([])) {
      (partialResult: OpaqueValue<[Int]>, element: OpaqueValue<Int>)
        -> OpaqueValue<[Int]> in
      ++timesClosureWasCalled
      return OpaqueValue<[Int]>(partialResult.value + [ element.value ])
    }
    expectEqual(test.sequence, result.value)
    expectEqual([], s.map { $0.value }, "sequence should be consumed")
    expectEqual(
      test.sequence.count, timesClosureWasCalled,
      "reduce() should be eager and should only call its predicate"
      + "once per element")
  }
}

//===----------------------------------------------------------------------===//
// reverse()
//===----------------------------------------------------------------------===//

struct ReverseTest {
  let expected: [Int]
  let sequence: [Int]
  let loc: SourceLoc

  init(
    _ expected: [Int], _ sequence: [Int],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let reverseTests: [ReverseTest] = [
  ReverseTest([], []),
  ReverseTest([ 1 ], [ 1 ]),
  ReverseTest([ 2, 1 ], [ 1, 2 ]),
  ReverseTest([ 3, 2, 1 ], [ 1, 2, 3 ]),
  ReverseTest([ 4, 3, 2, 1 ], [ 1, 2, 3, 4]),
  ReverseTest(
    [ 7, 6, 5, 4, 3, 2, 1 ],
    [ 1, 2, 3, 4, 5, 6, 7 ]),
]

SequenceTypeAlgorithms.test("reverse/SequenceType") {
  for test in reverseTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    var result = s.reverse()
    expectType([OpaqueValue<Int>].self, &result)
    expectEqual(
      test.expected, result.map { $0.value },
      stackTrace: SourceLocStack().with(test.loc))
    expectEqual([], s.map { $0.value }, "sequence should be consumed")
  }
}

SequenceTypeAlgorithms.test("reverse/WhereIndexIsBidirectional,BidirectionalReverseView") {
  for test in reverseTests {
    let s = MinimalBidirectionalCollection<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    var result = s.reverse()
    expectType(
      ReverseCollection<MinimalBidirectionalCollection<OpaqueValue<Int>>>.self,
      &result)
    expectEqual(
      test.expected, result.map { $0.value },
      stackTrace: SourceLocStack().with(test.loc))

    // Check ReverseCollection's CollectionType conformance.
    checkBidirectionalCollection(
      test.expected.map(OpaqueValue.init) as [OpaqueValue<Int>],
      result) { $0.value == $1.value }
  }
}

SequenceTypeAlgorithms.test("reverse/WhereIndexIsRandomAccess,RandomAccessReverseView") {
  for test in reverseTests {
    let s = MinimalRandomAccessCollection<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    var result = s.reverse()
    expectType(
      ReverseRandomAccessCollection<MinimalRandomAccessCollection<OpaqueValue<Int>>>.self,
      &result)
    expectEqual(
      test.expected, result.map { $0.value },
      stackTrace: SourceLocStack().with(test.loc))

    // Check ReverseRandomAccessCollection CollectionType conformance.
    checkRandomAccessCollection(
      test.expected.map(OpaqueValue.init) as [OpaqueValue<Int>],
      result) { $0.value == $1.value }

  }
}

//===----------------------------------------------------------------------===//
// filter()
//===----------------------------------------------------------------------===//

struct FilterTest {
  let expected: [Int]
  let sequence: [Int]
  let includeElement: (Int) -> Bool
  let loc: SourceLoc

  init(
    _ expected: [Int],
    _ sequence: [Int],
    _ includeElement: (Int) -> Bool,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.includeElement = includeElement
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let filterTests = [
  FilterTest(
    [], [],
    { (x: Int) -> Bool in expectUnreachable(); return true }),

  FilterTest([], [ 0, 30, 10, 90 ], { (x: Int) -> Bool in false }),
  FilterTest(
    [ 0, 30, 10, 90 ], [ 0, 30, 10, 90 ], { (x: Int) -> Bool in true }
  ),
  FilterTest(
    [ 0, 30, 90 ], [ 0, 30, 10, 90 ], { (x: Int) -> Bool in x % 3 == 0 }
  ),
]

SequenceTypeAlgorithms.test("filter/SequenceType/Dispatch") {
  let tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.filter { _ in false }
  expectCustomizable(tester, tester.log.filter)
}

SequenceTypeAlgorithms.test("filter/SequenceType/Semantics") {
  for test in filterTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      
      let s = DefaultedSequence<OpaqueValue<Int>> (
        test.sequence.map(OpaqueValue.init),
        underestimatedCount: underestimateCountBehavior)
      
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
      var result = s.filter {
        (element) in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return test.includeElement(element.value)
      }
      expectType([OpaqueValue<Int>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
      expectEqual([], s.map { $0.value }, "sequence should be consumed")
      expectEqual(
        test.sequence.count, timesClosureWasCalled,
        "filter() should be eager and should only call its predicate"
        + "once per element")
      expectGE(
        2 * result.count, result.capacity,
        "filter() should not reserve capacity (it does not know how much the"
        + "predicate will filter out)")
    }
  }
}

var MinimalForwardCollectionWithCustomFilter_timesFilterWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalForwardCollectionWith${Implementation}Filter<Element>
  : CollectionType {

  init(_ data: [Element], underestimatedCount: UnderestimateCountBehavior) {
    self._data = MinimalForwardCollection(
      data, underestimatedCount: underestimatedCount)
  }

  func generate() -> MinimalGenerator<Element> {
    return _data.generate()
  }

  var startIndex: MinimalForwardIndex {
    return _data.startIndex
  }

  var endIndex: MinimalForwardIndex {
    return _data.endIndex
  }

  subscript(i: MinimalForwardIndex) -> Element {
    return _data[i]
  }

  var _data: MinimalForwardCollection<Element>


%   if Implementation == 'Custom':

  static var timesFilterWasCalled: Int {
    get {
      return MinimalForwardCollectionWithCustomFilter_timesFilterWasCalled
    }
    set {
      MinimalForwardCollectionWithCustomFilter_timesFilterWasCalled = newValue
    }
  }

  func filter(
    @noescape transform: (Element) -> Bool
  ) -> [Element] {
    ++MinimalForwardCollectionWithCustomFilter.timesFilterWasCalled
    return _data.filter(transform)
  }

%   end

}

% end

func callStaticCollectionFilter(
  sequence: MinimalForwardCollectionWithDefaultFilter<OpaqueValue<Int>>,
  @noescape includeElement: (OpaqueValue<Int>) -> Bool
) -> [OpaqueValue<Int>] {
  var result = sequence.filter(includeElement)
  expectType([OpaqueValue<Int>].self, &result)
  return result
}

func callStaticCollectionFilter(
  sequence: MinimalForwardCollectionWithCustomFilter<OpaqueValue<Int>>,
  @noescape includeElement: (OpaqueValue<Int>) -> Bool
) -> [OpaqueValue<Int>] {
  var result = sequence.filter(includeElement)
  expectType([OpaqueValue<Int>].self, &result)
  return result
}

func callGenericCollectionFilter<S : CollectionType>(
  sequence: S,
  @noescape includeElement: (S.Generator.Element) -> Bool
) -> [S.Generator.Element] {
  var result = sequence.filter(includeElement)
  expectType(Array<S.Generator.Element>.self, &result)
  return result
}

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test("filter/CollectionType/${Implementation}Implementation/${dispatch}") {
  for test in filterTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalForwardCollectionWith${Implementation}Filter<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init),
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
%     if Implementation == 'Custom':
      MinimalForwardCollectionWithCustomFilter<OpaqueValue<Int>>.timesFilterWasCalled = 0
%     end
      var result = call${dispatch}CollectionFilter(s) {
        (element) in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return test.includeElement(element.value)
      }
      expectType([OpaqueValue<Int>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
%     if Implementation == 'Custom':
      expectEqual(1, MinimalForwardCollectionWithCustomFilter<OpaqueValue<Int>>.timesFilterWasCalled)
%     end
      expectEqual(
        test.sequence, s.map { $0.value }, "collection should not be consumed")
      expectEqual(test.sequence.count, timesClosureWasCalled,
        "filter() should be eager and should only call its predicate once per element")
      expectGE(
        2 * result.count, result.capacity,
        "filter() should not reserve capacity"
        + "(it does not know how much the predicate will filter out)")
    }
  }
}

%   end

% end

//===----------------------------------------------------------------------===//
// map()
//===----------------------------------------------------------------------===//

struct MapTest {
  let expected: [Int32]
  let sequence: [Int]
  let transform: (Int) -> Int32
  let loc: SourceLoc

  init(
    _ expected: [Int32],
    _ sequence: [Int],
    _ transform: (Int) -> Int32,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.transform = transform
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let mapTests = [
  MapTest(
    [], [],
    { (x: Int) -> Int32 in expectUnreachable(); return 0xffff }),

  MapTest([ 101 ], [ 1 ], { (x: Int) -> Int32 in x + 100 }),
  MapTest([ 101, 102 ], [ 1, 2 ], { (x: Int) -> Int32 in x + 100 }),
  MapTest([ 101, 102, 103 ], [ 1, 2, 3 ], { (x: Int) -> Int32 in x + 100 }),
  MapTest(Array(101..<200), Array(1..<100), { (x: Int) -> Int32 in x + 100 }),
]

var MinimalSequenceWithCustomMap_timesMapWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalSequenceWith${Implementation}Map<Element> : SequenceType {
  init(_ data: [Element], underestimatedCount: UnderestimateCountBehavior) {
    self._data = MinimalSequence(
      data, underestimatedCount: underestimatedCount)
  }

  func generate() -> MinimalGenerator<Element> {
    return _data.generate()
  }

  var _data: MinimalSequence<Element>


%   if Implementation == 'Custom':

  static var timesMapWasCalled: Int {
    get {
      return MinimalSequenceWithCustomMap_timesMapWasCalled
    }
    set {
      MinimalSequenceWithCustomMap_timesMapWasCalled = newValue
    }
  }

  func map<T>(
    @noescape transform: (Element) -> T
  ) -> [T] {
    ++MinimalSequenceWithCustomMap.timesMapWasCalled
    return _data.map(transform)
  }

%   end
}

% end

func callStaticSequenceMap<T>(
  sequence: MinimalSequenceWithDefaultMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = sequence.map(transform)
  expectType([T].self, &result)
  return result
}

func callStaticSequenceMap<T>(
  sequence: MinimalSequenceWithCustomMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = sequence.map(transform)
  expectType([T].self, &result)
  return result
}

func callGenericSequenceMap<S : SequenceType, T>(
  sequence: S,
  @noescape transform: (S.Generator.Element) -> T
) -> [T] {
  var result = sequence.map(transform)
  expectType([T].self, &result)
  return result
}

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test(
  "map/SequenceType/${Implementation}Implementation/${dispatch}"
) {
  for test in mapTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalSequenceWith${Implementation}Map<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init),
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
%     if Implementation == 'Custom':
      MinimalSequenceWithCustomMap<OpaqueValue<Int>>.timesMapWasCalled = 0
%     end
      var result = call${dispatch}SequenceMap(s) {
        (element: OpaqueValue<Int>) -> OpaqueValue<Int32> in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return OpaqueValue(Int32(test.transform(element.value)))
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
%     if Implementation == 'Custom':
      expectEqual(
        1, MinimalSequenceWithCustomMap<OpaqueValue<Int>>.timesMapWasCalled)
%     end
      expectEqual([], s.map { $0.value }, "sequence should be consumed")
      expectEqual(
        test.sequence.count, timesClosureWasCalled,
        "map() should be eager and should only call its predicate"
        + "once per element")
    }
  }
}

%   end

% end

var MinimalForwardCollectionWithCustomMap_timesMapWasCalled: Int = 0

% for Implementation in [ 'Default', 'Custom' ]:

struct MinimalForwardCollectionWith${Implementation}Map<Element>
  : CollectionType {

  init(_ data: [Element], underestimatedCount: UnderestimateCountBehavior) {
    self._data = MinimalForwardCollection(
      data, underestimatedCount: underestimatedCount)
  }

  func generate() -> MinimalGenerator<Element> {
    return _data.generate()
  }

  var startIndex: MinimalForwardIndex {
    return _data.startIndex
  }

  var endIndex: MinimalForwardIndex {
    return _data.endIndex
  }

  subscript(i: MinimalForwardIndex) -> Element {
    return _data[i]
  }

  var _data: MinimalForwardCollection<Element>


%   if Implementation == 'Custom':

  static var timesMapWasCalled: Int {
    get {
      return MinimalForwardCollectionWithCustomMap_timesMapWasCalled
    }
    set {
      MinimalForwardCollectionWithCustomMap_timesMapWasCalled = newValue
    }
  }

  func map<T>(
    @noescape transform: (Element) -> T
  ) -> [T] {
    ++MinimalForwardCollectionWithCustomMap.timesMapWasCalled
    return _data.map(transform)
  }

%   end

}

% end

func callStaticCollectionMap<T>(
  collection: MinimalForwardCollectionWithDefaultMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = collection.map(transform)
  expectType([T].self, &result)
  return result
}

func callStaticCollectionMap<T>(
  collection: MinimalForwardCollectionWithCustomMap<OpaqueValue<Int>>,
  @noescape transform: (OpaqueValue<Int>) -> T
) -> [T] {
  var result = collection.map(transform)
  expectType([T].self, &result)
  return result
}

func callGenericCollectionMap<C : CollectionType, T>(
  collection: C,
  @noescape transform: (C.Generator.Element) -> T
) -> [T] {
  var result = collection.map(transform)
  expectType([T].self, &result)
  return result
}

% for Implementation in [ 'Default', 'Custom' ]:

%   for dispatch in [ 'Static', 'Generic' ]:

SequenceTypeAlgorithms.test(
  "map/CollectionType/${Implementation}Implementation/${dispatch}"
) {
  for test in mapTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Half,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalForwardCollectionWith${Implementation}Map<
        OpaqueValue<Int>
      >(
        test.sequence.map(OpaqueValue.init),
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
%     if Implementation == 'Custom':
      MinimalForwardCollectionWithCustomMap<
        OpaqueValue<Int>
      >.timesMapWasCalled = 0
%     end
      var result = call${dispatch}CollectionMap(s) {
        (element: OpaqueValue<Int>) -> OpaqueValue<Int32> in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return OpaqueValue(Int32(test.transform(element.value)))
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(test.expected, result.map { $0.value })
%     if Implementation == 'Custom':
      expectEqual(
        1, MinimalForwardCollectionWithCustomMap<
          OpaqueValue<Int>
        >.timesMapWasCalled)
%     end
      expectEqual(test.sequence, s.map { $0.value },
        "collection should not be consumed")
      expectEqual(test.sequence.count, timesClosureWasCalled,
        "map() should be eager and should only call its predicate"
        + "once per element")
    }
  }
}

%   end

% end

//===----------------------------------------------------------------------===//
// flatMap()
//===----------------------------------------------------------------------===//

struct FlatMapTest {
  let expected: [Int32]
  let sequence: [Int]
  let transform: (Int) -> [Int32]
  let loc: SourceLoc

  init(
    _ expected: [Int32],
    _ sequence: [Int],
    _ transform: (Int) -> [Int32],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.transform = transform
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

func flatMapTransformation(x: Int) -> [Int32] {
  let repetitions = x / 10
  let identity = x % 10
  let range = (1..<(repetitions+1))
  return range.map { Int32($0 * 10 + identity) }
}

let flatMapTests = [
  FlatMapTest(
    [], [],
    { (x: Int) -> [Int32] in expectUnreachable(); return [ 0xffff ] }),

  FlatMapTest([], [ 1 ], { (x: Int) -> [Int32] in [] }),
  FlatMapTest([], [ 1, 2 ], { (x: Int) -> [Int32] in [] }),
  FlatMapTest([], [ 1, 2, 3 ], { (x: Int) -> [Int32] in [] }),

  FlatMapTest([ 101 ], [ 1 ], { (x: Int) -> [Int32] in [ x + 100 ] }),
  FlatMapTest([ 101, 102 ], [ 1, 2 ], { (x: Int) -> [Int32] in [ x + 100 ] }),
  FlatMapTest(
    [ 101, 102, 103 ], [ 1, 2, 3 ], { (x: Int) -> [Int32] in [ x + 100 ] }),

  FlatMapTest(
    [ 101, 201 ], [ 1 ],
    { (x: Int) -> [Int32] in [ x + 100, x + 200 ] }),
  FlatMapTest(
    [ 101, 201, 102, 202 ], [ 1, 2 ],
    { (x: Int) -> [Int32] in [ x + 100, x + 200 ] }),
  FlatMapTest(
    [ 101, 201, 102, 202, 103, 203 ], [ 1, 2, 3 ],
    { (x: Int) -> [Int32] in [ x + 100, x + 200 ] }),

  FlatMapTest([ 11, 15 ], [ 11, 2, 3, 4, 15 ], flatMapTransformation),
  FlatMapTest([ 12, 13, 23 ], [ 1, 12, 23 ], flatMapTransformation),
  FlatMapTest(
    [ 11, 21, 13, 23, 33, 14 ], [ 21, 2, 33, 14 ], flatMapTransformation),
]

SequenceTypeAlgorithms.test("flatMap/SequenceType") {
  for test in flatMapTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init),
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      var timesClosureWasCalled = 0
      var result = s.flatMap {
        (element: OpaqueValue<Int>) -> MinimalSequence<OpaqueValue<Int32>> in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return MinimalSequence<OpaqueValue<Int32>>(
          test.transform(element.value).map { OpaqueValue(Int32($0)) })
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(
        test.expected, result.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectTrue(Array(s).isEmpty, "sequence should be consumed")
      expectEqual(
        test.sequence.count, timesClosureWasCalled,
        "flatMap() should be eager and should only call its predicate"
        + "once per element")
      expectGE(
        2 * result.count, result.capacity,
        "flatMap() should not reserve capacity")
    }
  }
}

% for Kind in 'Sequence', 'ForwardCollection', 'BidirectionalCollection':
%   Minimal = 'Minimal' + Kind
SequenceTypeAlgorithms.test("flatMap/${Kind}/Lazy") {
  for test in flatMapTests {
    let s = ${Minimal}<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    let closureLifetimeTracker = LifetimeTracked(0)
    var timesClosureWasCalled = 0
    var result = s._prext_lazy.flatMap {
      (element: OpaqueValue<Int>) -> ${Minimal}<OpaqueValue<Int32>> in
      _blackHole(closureLifetimeTracker)
      ++timesClosureWasCalled
      return ${Minimal}<OpaqueValue<Int32>>(
        test.transform(element.value).map { OpaqueValue(Int32($0)) })
    }
    expectEqual(0, timesClosureWasCalled, "Unexpected eagerness")
    check${Kind}(
      test.expected.map(OpaqueValue.init), result,
      stackTrace: SourceLocStack().with(test.loc),
      resiliencyChecks: .none
    ) { $0.value == $1.value }

    % if Kind == 'Sequence':
    expectTrue(Array(s).isEmpty, "sequence should be consumed")
    expectEqual(
      test.sequence.count, timesClosureWasCalled,
      "iterating a lazy flatMap() should call the predicate"
      + "once per element")
    % end
  }
}
% end

struct FlatMapToOptionalTest {
  let expected: [Int32]
  let sequence: [Int]
  let transform: (Int) -> Int32?
  let loc: SourceLoc

  init(
    _ expected: [Int32],
    _ sequence: [Int],
    _ transform: (Int) -> Int32?,
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.transform = transform
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let flatMapToOptionalTests = [
  FlatMapToOptionalTest(
    [], [],
    { (x: Int) -> Int32? in expectUnreachable(); return 0xffff }),

  FlatMapToOptionalTest([], [ 1 ], { (x: Int) -> Int32? in nil }),
  FlatMapToOptionalTest([], [ 1, 2 ], { (x: Int) -> Int32? in nil }),
  FlatMapToOptionalTest([], [ 1, 2, 3 ], { (x: Int) -> Int32? in nil }),

  FlatMapToOptionalTest(
    [ 1 ], [ 1 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
  FlatMapToOptionalTest(
    [ 2 ], [ 11, 2, 13, 14 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
  FlatMapToOptionalTest(
    [ 1, 4 ], [ 1, 12, 13, 4 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
  FlatMapToOptionalTest(
    [ 1, 2, 3 ], [ 1, 2, 3 ],
    { (x: Int) -> Int32? in x > 10 ? nil : Int32(x) }),
]

SequenceTypeAlgorithms.test("flatMap/SequenceType/TransformProducesOptional") {
  for test in flatMapToOptionalTests {
    for underestimateCountBehavior in [
      UnderestimateCountBehavior.Precise,
      UnderestimateCountBehavior.Value(0)
    ] {
      let s = MinimalSequence<OpaqueValue<Int>>(
        test.sequence.map(OpaqueValue.init),
        underestimatedCount: underestimateCountBehavior)
      let closureLifetimeTracker = LifetimeTracked(0)
      expectEqual(1, LifetimeTracked.instances)
      var timesClosureWasCalled = 0
      var result = s.flatMap {
        (element: OpaqueValue<Int>) -> OpaqueValue<Int32>? in
        _blackHole(closureLifetimeTracker)
        ++timesClosureWasCalled
        return test.transform(element.value).map { OpaqueValue(Int32($0)) }
      }
      expectType([OpaqueValue<Int32>].self, &result)
      expectEqual(
        test.expected, result.map { $0.value },
        stackTrace: SourceLocStack().with(test.loc))
      expectTrue(Array(s).isEmpty, "sequence should be consumed")
      expectEqual(
        test.sequence.count, timesClosureWasCalled,
        "flatMap() should be eager and should only call its predicate"
        + "once per element")
      expectGE(
        2 * result.count, result.capacity,
        "flatMap() should not reserve capacity")
    }
  }
}

//===----------------------------------------------------------------------===//
// forEach()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("forEach/dispatch") {
  let tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.forEach { print($0) }
  expectCustomizable(tester, tester.log.forEach)
}

//===----------------------------------------------------------------------===//
// dropFirst()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("dropFirst/dispatch") {
  var tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.dropFirst(1)
  expectCustomizable(tester, tester.log.dropFirst)
}

//===----------------------------------------------------------------------===//
// dropLast()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("dropLast/dispatch") {
  var tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.dropLast(1)
  expectCustomizable(tester, tester.log.dropLast)
}

//===----------------------------------------------------------------------===//
// prefix()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("prefix/dispatch") {
  var tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.prefix(1)
  expectCustomizable(tester, tester.log.prefix)
}

//===----------------------------------------------------------------------===//
// suffix()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("suffix/dispatch") {
  var tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.suffix(1)
  expectCustomizable(tester, tester.log.suffix)
}

//===----------------------------------------------------------------------===//
// split()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("SequenceType/split/dispatch") {
  var tester = SequenceLog.dispatchTester([OpaqueValue(1)])
  tester.split { $0.value == 1 }
  expectCustomizable(tester, tester.log.split)
}

//===----------------------------------------------------------------------===//
// zip()
//===----------------------------------------------------------------------===//

// Check that the generic parameters are called 'Generator1' and 'Generator2'.
extension Zip2Generator
  where Generator1 : TestProtocol1, Generator2 : TestProtocol1 {

  var _generator1IsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

extension Zip2Sequence
  where Sequence1 : TestProtocol1, Sequence2 : TestProtocol1 {

  var _sequence1IsTestProtocol1: Bool {
    fatalError("not implemented")
  }
}

struct ZipTest {
  let expected: [(Int, Int32)]
  let sequence: [Int]
  let other: [Int32]
  let expectedLeftoverSequence: [Int]
  let expectedLeftoverOther: [Int32]
  let loc: SourceLoc

  init(
    _ expected: [(Int, Int32)],
    sequences sequence: [Int],
    _ other: [Int32],
    leftovers expectedLeftoverSequence: [Int],
    _ expectedLeftoverOther: [Int32],
    file: String = __FILE__, line: UWord = __LINE__
  ) {
    self.expected = expected
    self.sequence = sequence
    self.other = other
    self.expectedLeftoverSequence = expectedLeftoverSequence
    self.expectedLeftoverOther = expectedLeftoverOther
    self.loc = SourceLoc(file, line, comment: "test data")
  }
}

let zipTests = [
  ZipTest([], sequences: [], [], leftovers: [], []),
  ZipTest([], sequences: [], [ 1 ], leftovers: [], [ 1 ]),
  ZipTest([], sequences: [], [ 1, 2 ], leftovers: [], [ 1, 2 ]),
  ZipTest([], sequences: [], [ 1, 2, 3 ], leftovers: [], [ 1, 2, 3 ]),

  ZipTest([], sequences: [ 10 ], [], leftovers: [], []),
  ZipTest([ (10, 1) ], sequences: [ 10 ], [ 1 ], leftovers: [], []),
  ZipTest([ (10, 1) ], sequences: [ 10 ], [ 1, 2 ], leftovers: [], [ 2 ]),
  ZipTest([ (10, 1) ], sequences: [ 10 ], [ 1, 2, 3 ], leftovers: [], [ 2, 3 ]),

  ZipTest(
    [],
    sequences: [ 10, 20 ], [],
    leftovers: [ 20 ], []),
  ZipTest(
    [ (10, 1) ],
    sequences: [ 10, 20 ], [ 1 ],
    leftovers: [], []),
  ZipTest(
    [ (10, 1), (20, 2) ],
    sequences: [ 10, 20 ], [ 1, 2 ],
    leftovers: [], []),
  ZipTest(
    [ (10, 1), (20, 2) ],
    sequences: [ 10, 20 ], [ 1, 2, 3 ],
    leftovers: [], [ 3 ]),

  ZipTest(
    [],
    sequences: [ 10, 20, 30 ], [],
    leftovers: [ 20, 30 ], []),
  ZipTest(
    [ (10, 1) ],
    sequences: [ 10, 20, 30 ], [ 1 ],
    leftovers: [ 30 ], []),
  ZipTest(
    [ (10, 1), (20, 2) ],
    sequences: [ 10, 20, 30 ], [ 1, 2 ],
    leftovers: [], []),
  ZipTest(
    [ (10, 1), (20, 2), (30, 3) ],
    sequences: [ 10, 20, 30 ], [ 1, 2, 3 ],
    leftovers: [], []),
]

SequenceTypeAlgorithms.test("zip") {
  typealias Element = (OpaqueValue<Int>, OpaqueValue<Int32>)
  func compareElements(lhs: Element, rhs: Element) -> Bool {
    return lhs.0.value == rhs.0.value && lhs.1.value == rhs.1.value
  }

  for test in zipTests {
    let s = MinimalSequence<OpaqueValue<Int>>(
      test.sequence.map(OpaqueValue.init))
    let other = MinimalSequence<OpaqueValue<Int32>>(
      test.other.map(OpaqueValue.init))
    var result = zip(s, other)
    expectType(
      Zip2Sequence<MinimalSequence<OpaqueValue<Int>>, MinimalSequence<OpaqueValue<Int32>>>.self,
      &result)

    // Check for expected result and check the Zip2Sequence's SequenceType
    // conformance.
    checkSequence(
      test.expected.map { (OpaqueValue($0), OpaqueValue($1)) }, result,
      stackTrace: SourceLocStack().with(test.loc), sameValue: compareElements)
    
    // Check leftovers *after* doing checkSequence(), not before, to ensure
    // that checkSequence() didn't force us to consume more elements than
    // needed.
    expectEqual(
      test.expectedLeftoverSequence, s.map { $0.value },
      stackTrace: SourceLocStack().with(test.loc))
    expectEqual(
      test.expectedLeftoverOther, other.map { $0.value },
      stackTrace: SourceLocStack().with(test.loc))
  }
}

//===----------------------------------------------------------------------===//
// underestimateCount()
//===----------------------------------------------------------------------===//

func callGenericUnderestimatedCount<S : SequenceType>(s: S) -> Int {
  return s.underestimateCount()
}

struct SequenceWithDefaultUnderestimateCount : SequenceType {
  init() {}

  func generate() -> MinimalSequence<OpaqueValue<Int>>.Generator {
    expectUnreachable()
    return MinimalSequence(
      [ 1, 2, 3 ].map(OpaqueValue.init)
    ).generate()
  }
}

SequenceTypeAlgorithms.test("underestimateCount/SequenceType/DefaultImplementation") {
  let s = SequenceWithDefaultUnderestimateCount()
  expectEqual(0, callGenericUnderestimatedCount(s))
}

struct SequenceWithCustomUnderestimateCount : SequenceType {
  init(underestimatedCount: Int) {
    self._underestimatedCount = underestimatedCount
  }

  func generate() -> MinimalSequence<OpaqueValue<Int>>.Generator {
    expectUnreachable()
    return MinimalSequence(
      [ 0xffff, 0xffff, 0xffff ].map(OpaqueValue.init)
    ).generate()
  }

  func underestimateCount() -> Int {
    return _underestimatedCount
  }

  let _underestimatedCount: Int
}

SequenceTypeAlgorithms.test("underestimateCount/SequenceType/CustomImplementation") {
  if true {
    let s = SequenceWithCustomUnderestimateCount(underestimatedCount: 5)
    expectEqual(5, callGenericUnderestimatedCount(s))
  }
  if true {
    let s = SequenceWithCustomUnderestimateCount(underestimatedCount: 42)
    expectEqual(42, callGenericUnderestimatedCount(s))
  }
}

struct CollectionWithDefaultUnderestimateCount : CollectionType {
  init(count: Int) {
    self._count = count
  }

  func generate() -> MinimalGenerator<OpaqueValue<Int>> {
    expectUnreachable()
    return MinimalGenerator([])
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return OpaqueValue(0xffff)
  }

  var _count: Int
}

SequenceTypeAlgorithms.test("underestimateCount/CollectionType/DefaultImplementation") {
  if true {
    let s = CollectionWithDefaultUnderestimateCount(count: 0)
    expectEqual(0, callGenericUnderestimatedCount(s))
  }
  if true {
    let s = CollectionWithDefaultUnderestimateCount(count: 5)
    expectEqual(5, callGenericUnderestimatedCount(s))
  }
}

struct CollectionWithCustomUnderestimateCount : CollectionType {
  init(underestimatedCount: Int) {
    self._underestimatedCount = underestimatedCount
  }

  func generate() -> MinimalGenerator<OpaqueValue<Int>> {
    expectUnreachable()
    return MinimalGenerator([])
  }

  var startIndex: MinimalForwardIndex {
    expectUnreachable()
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: 0xffff)
  }

  var endIndex: MinimalForwardIndex {
    expectUnreachable()
    return MinimalForwardIndex(
      position: 0xffff, startIndex: 0, endIndex: 0xffff)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    expectUnreachable()
    return OpaqueValue(0xffff)
  }

  func underestimateCount() -> Int {
    return _underestimatedCount
  }

  let _underestimatedCount: Int
}

SequenceTypeAlgorithms.test("underestimateCount/CollectionType/CustomImplementation") {
  if true {
    let s = CollectionWithCustomUnderestimateCount(underestimatedCount: 0)
    expectEqual(0, callGenericUnderestimatedCount(s))
  }
  if true {
    let s = CollectionWithCustomUnderestimateCount(underestimatedCount: 5)
    expectEqual(5, callGenericUnderestimatedCount(s))
  }
}

//===----------------------------------------------------------------------===//
// _copyToNativeArrayBuffer()
//===----------------------------------------------------------------------===//
SequenceTypeAlgorithms.test("_copyToNativeArrayBuffer/OverestimatedCount")
  .skip(.Custom(
    { _isFastAssertConfiguration() },
    reason: "this trap is not guaranteed to happen in -Ounchecked"))
  .code {
  let s = MinimalSequence<OpaqueValue<Int>>(
    [ 1, 2, 3 ].map(OpaqueValue.init),
    underestimatedCount: .Value(4))
  expectCrashLater()
  let array = s._copyToNativeArrayBuffer()
  _blackHole(array)
}

//===----------------------------------------------------------------------===//
// CollectionType.generate(), CollectionType.Generator
//===----------------------------------------------------------------------===//

struct MinimalForwardCollectionWithDefaultGenerator : CollectionType {
  init(count: Int) {
    self._count = count
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    return OpaqueValue(i.position + 1)
  }

  var _count: Int
}

func callGenericGenerate<S : SequenceType>(sequence: S) -> S.Generator {
  return sequence.generate()
}

SequenceTypeAlgorithms.test("CollectionType.generate()/DefaultImplementation") {
  for count in [ 0, 5 ] {
    let collection = MinimalForwardCollectionWithDefaultGenerator(count: count)

    if true {
      // Check the return type of the function when called statically.
      var generator = collection.generate()
      expectType(
        IndexingGenerator<MinimalForwardCollectionWithDefaultGenerator>.self,
        &generator)
    }

    if true {
      // Check the return type of the function when called generically.
      var generator = callGenericGenerate(collection)
      expectType(
        IndexingGenerator<MinimalForwardCollectionWithDefaultGenerator>.self,
        &generator)
    }

    checkForwardCollection(
      Array(1..<count+1).map(OpaqueValue.init) as [OpaqueValue<Int>],
      collection
    ) { $0.value == $1.value }
  }
}

struct MinimalForwardCollectionWithCustomGenerator : CollectionType {
  init(count: Int) {
    self._count = count
  }

  static var timesGenerateWasCalled: Int = 0

  func generate() -> MinimalGenerator<OpaqueValue<Int>> {
    ++MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled
    return MinimalGenerator<OpaqueValue<Int>>(
      Array(1..<_count+1).map(OpaqueValue.init) as [OpaqueValue<Int>]
    )
  }

  var startIndex: MinimalForwardIndex {
    return MinimalForwardIndex(position: 0, startIndex: 0, endIndex: _count)
  }

  var endIndex: MinimalForwardIndex {
    return MinimalForwardIndex(
      position: _count, startIndex: 0, endIndex: _count)
  }

  subscript(i: MinimalForwardIndex) -> OpaqueValue<Int> {
    return OpaqueValue(i.position + 1)
  }

  var _count: Int
}

SequenceTypeAlgorithms.test("CollectionType.generate()/CustomImplementation") {
  for count in [ 0, 5 ] {
    let collection = MinimalForwardCollectionWithCustomGenerator(count: count)

    if true {
      // Check the return type of the function when called statically.
      MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled = 0
      var generator = collection.generate()
      expectType(
        MinimalGenerator<OpaqueValue<Int>>.self,
        &generator)
      expectEqual(1, MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled)
    }

    if true {
      MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled = 0
      // Check the return type of the function when called generically.
      var generator = callGenericGenerate(collection)
      expectType(
        MinimalGenerator<OpaqueValue<Int>>.self,
        &generator)
      expectEqual(1, MinimalForwardCollectionWithCustomGenerator.timesGenerateWasCalled)
    }

    checkForwardCollection(
      Array(1..<count+1).map(OpaqueValue.init) as [OpaqueValue<Int>],
      collection, resiliencyChecks: .none) { $0.value == $1.value }

  }
}

//===----------------------------------------------------------------------===//
// CollectionType.subscript(_: Range<Index>), CollectionType.SubSequence
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("subscript(_: Range<Index>)/Dispatch") {
  let tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  _ = tester[tester.startIndex..<tester.endIndex]
  let log = tester.log
  let log2 = tester.log.subscriptRange
  expectCustomizable(tester, tester.log.subscriptRange)
}

//===----------------------------------------------------------------------===//
// Slice<Base>
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("Slice/AssociatedTypes") {
%for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:
  if true {
    typealias Base = Minimal${traversal}Collection<OpaqueValue<Int>>
    typealias ${traversal}Slice = Slice<Base>
    expectSliceType(${traversal}Slice.self)
    expectCollectionAssociatedTypes(
      collectionType: ${traversal}Slice.self,
      generatorType: IndexingGenerator<${traversal}Slice>.self,
      subSequenceType: ${traversal}Slice.self,
      indexType: Minimal${traversal}Index.self)
  }
%end

  func checkStaticTypealiases<Base : CollectionType>(_: Base) {
    expectEqualType(Base.Index.self, Slice<Base>.Index.self)
  }
}

SequenceTypeAlgorithms.test("Slice/init(base:bounds:)") {
  for test in subscriptRangeTests {
    let base = MinimalForwardCollection(test.collection)
    var result = Slice(base: base, bounds: test.boundsIn(base))
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &result)

    checkForwardCollection(
      test.expected,
      result,
      stackTrace: SourceLocStack().with(test.loc))
      { $0.value == $1.value }
  }
}

SequenceTypeAlgorithms.test("Slice.{startIndex,endIndex}") {
  for test in subscriptRangeTests {
    let base = MinimalForwardCollection(test.collection)
    let bounds = test.boundsIn(base)
    var slice = Slice(base: base, bounds: bounds)
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &slice)

    expectEqual(bounds.startIndex, slice.startIndex)
    expectEqual(bounds.endIndex, slice.endIndex)
  }
}

SequenceTypeAlgorithms.test("Slice.subscript(_: Index)") {
  for test in subscriptRangeTests {
    let base = MinimalForwardCollection(test.collection)
    let bounds = test.boundsIn(base)
    var slice = Slice(base: base, bounds: bounds)
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &slice)

    for i in bounds {
      var element = slice[i]
      expectType(OpaqueValue<Int>.self, &element)
      expectEqual(base[i].value, element.value)
    }

    for (i, index) in base.indices.enumerate() {
      if test.bounds.contains(i) {
        expectEqual(base[index].value, slice[index].value)
      } else {
        // `Slice` disallows out-of-bounds indices when the underlying index
        // type can perform a range check.
        expectFailure {
          _blackHole(slice[index])
        }
      }
    }
  }
}

SequenceTypeAlgorithms.test("Slice.subscript(_: Range<Index>)") {
  for test in subscriptRangeTests {
    let base = MinimalForwardCollection(test.collection)
    var slice = Slice(base: base, bounds: base.indices)
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &slice)

    var result = slice[test.boundsIn(slice)]
    expectType(
      Slice<MinimalForwardCollection<OpaqueValue<Int>>>.self,
      &result)

    checkForwardCollection(test.expected, result) { $0.value == $1.value }

    if test.bounds == test.collection.indices {
      let reSliced = result[base.indices]
      checkForwardCollection(
        test.collection,
        reSliced,
        stackTrace: SourceLocStack().with(test.loc))
        { $0.value == $1.value }
    } else {
      // `Slice` disallows out-of-bounds slicing when the underlying index type
      // can perform a range check.
      expectFailure {
        _blackHole(result[base.indices])
      }
    }
  }
}

//===----------------------------------------------------------------------===//
// isEmpty
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("isEmpty/dispatch") {
  let tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  _ = tester.isEmpty
  expectCustomizable(tester, tester.log.isEmpty)
}

//===----------------------------------------------------------------------===//
// first
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("first/dispatch") {
  let tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  _ = tester.first
  expectCustomizable(tester, tester.log.first)
}

//===----------------------------------------------------------------------===//
// count
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("count/dispatch") {
  let tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  _ = tester.count
  expectCustomizable(tester, tester.log.count)
}

//===----------------------------------------------------------------------===//
// indexOf()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("indexOf/WhereElementIsEquatable/dispatch") {
  let tester = CollectionLog.dispatchTester([MinimalEquatableValue(1)])
  _ = tester.indexOf(MinimalEquatableValue(1))
  expectCustomizable(tester, tester.log._customIndexOfEquatableElement)
}

// FIXME: underscores are a workaround for:
// <rdar://problem/20582358> Commenting out one line determines whether a
// completely different line type-checks
func callGenericFind_<
  C : CollectionType where C.Generator.Element : Equatable
>(collection: C, _ element: C.Generator.Element) -> C.Index? {
  return collection.indexOf(element)
}

func callStaticFind_(
  set: Set<MinimalHashableValue>,
  _ element: MinimalHashableValue
) -> Set<MinimalHashableValue>.Index? {
  return set.indexOf(element)
}

% for dispatch in [ 'Static', 'Generic' ]:

// FIXME: implement the same optimization for Dictionary.
// FIXME: move to the file where other Set tests live.
SequenceTypeAlgorithms.test("Set<T>.find/CustomImplementation/${dispatch}") {
  for test in findTests {
    let s = Set<MinimalHashableValue>(
      test.sequence.map { MinimalHashableValue($0.value) })
    MinimalHashableValue.timesEqualEqualWasCalled = 0
    MinimalHashableValue.timesHashValueWasCalled = 0
    expectEqual(
      test.expected
        .map { _ in MinimalHashableValue(test.element.value) },
      call${dispatch}Find_(s, MinimalHashableValue(test.element.value))
        .map { s[$0] },
      stackTrace: SourceLocStack().with(test.loc))
    if test.sequence.isEmpty {
      expectEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
      expectEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
    } else {
      expectNotEqual(
        0, MinimalHashableValue.timesHashValueWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
    }
    if test.expected != nil {
      expectNotEqual(
        0, MinimalHashableValue.timesEqualEqualWasCalled,
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

% end

//===----------------------------------------------------------------------===//
// CollectionType.split()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("CollectionType/split/dispatch") {
  var tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  tester.split { $0.value == 1 }
  expectCustomizable(tester, tester.log.split)
}

//===----------------------------------------------------------------------===//
// prefixThrough()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("CollectionType/prefixThrough/dispatch") {
  var tester = CollectionLog.dispatchTester([1, 2, 3].map(OpaqueValue.init))
  tester.prefixThrough(1)
  expectCustomizable(tester, tester.log.prefixThrough)
}

//===----------------------------------------------------------------------===//
// prefixUpTo()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("CollectionType/prefixUpTo/dispatch") {
  var tester = CollectionLog.dispatchTester([OpaqueValue(1)])
  tester.prefixUpTo(1)
  expectCustomizable(tester, tester.log.prefixUpTo)
}

//===----------------------------------------------------------------------===//
// suffixFrom()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("CollectionType/suffixFrom/dispatch") {
  var tester = CollectionLog.dispatchTester([1, 2, 3].map(OpaqueValue.init))
  tester.suffixFrom(1)
  expectCustomizable(tester, tester.log.suffixFrom)
}

//===----------------------------------------------------------------------===//
// MutableCollectionType
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// _withUnsafeMutableBufferPointerIfSupported()
//===----------------------------------------------------------------------===//

SequenceTypeAlgorithms.test("_withUnsafeMutableBufferPointerIfSupported/dispatch") {
  var tester = MutableCollectionLog.dispatchTester([OpaqueValue(1)])
  _ = tester._withUnsafeMutableBufferPointerIfSupported { _ in () }
  expectCustomizable(tester, tester.log._withUnsafeMutableBufferPointerIfSupported)
}

//===----------------------------------------------------------------------===//
// Standard sequence and collection tests
//===----------------------------------------------------------------------===//

func identity(element: OpaqueValue<Int>) -> OpaqueValue<Int> {
  return element
}
func identityEq(element: MinimalEquatableValue) -> MinimalEquatableValue {
  return element
}
func identityComp(element: MinimalComparableValue) -> MinimalComparableValue {
  return element
}

% for Base in [ 'DefaultedSequence', 'MinimalSequence' ]:
if true {
  let checksAdded: Box<Set<String>> = Box([])
  let resiliencyChecks = CollectionMisuseResiliencyChecks.all

  SequenceTypeAlgorithms.addSequenceTests(
    makeSequence: { (elements: [OpaqueValue<Int>]) in
      return ${Base}(elements)
    },
    wrapValue: identity,
    extractValue: identity,
    makeSequenceOfEquatable: { (elements: [MinimalEquatableValue]) in
      return ${Base}(elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    checksAdded: checksAdded,
    resiliencyChecks: resiliencyChecks)
}
% end

% for traversal in [ 'Forward', 'Bidirectional', 'RandomAccess' ]:
%   for base_kind in [ 'Defaulted', 'Minimal' ]:
// This comment is a workaround for <rdar://problem/18900352> gyb miscompiles nested loops
%     for mutable in [ False, True ]:
// This comment is a workaround for <rdar://problem/18900352> gyb miscompiles nested loops
%       Base = "%s%s%sCollection" % (base_kind, traversal, 'Mutable' if mutable else '')

// Test collections using value types as elements.
if true {
  var checksAdded: Box<Set<String>> = Box([])
  var resiliencyChecks = CollectionMisuseResiliencyChecks.all
  resiliencyChecks.creatingOutOfBoundsIndicesBehavior = .ExpectationFailure

  SequenceTypeAlgorithms.add${traversal}CollectionTests(
    makeCollection: { (elements: [OpaqueValue<Int>]) in
      return ${Base}(elements)
    },
    wrapValue: identity,
    extractValue: identity,
    makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
      return ${Base}(elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    checksAdded: checksAdded,
    resiliencyChecks: resiliencyChecks)

%       if mutable:
  SequenceTypeAlgorithms.add${traversal}MutableCollectionTests(
    makeCollection: { (elements: [OpaqueValue<Int>]) in
      return ${Base}(elements)
    },
    wrapValue: identity,
    extractValue: identity,
    makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
      return ${Base}(elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    makeCollectionOfComparable: { (elements: [MinimalComparableValue]) in
      return ${Base}(elements)
    },
    wrapValueIntoComparable: identityComp,
    extractValueFromComparable: identityComp,
    checksAdded: checksAdded,
    resiliencyChecks: resiliencyChecks,
    withUnsafeMutableBufferPointerIsSupported: false)
%       end
}

// Test collections using a reference type as element.
if true {
  var checksAdded: Box<Set<String>> = Box([])
  var resiliencyChecks = CollectionMisuseResiliencyChecks.all
  resiliencyChecks.creatingOutOfBoundsIndicesBehavior = .ExpectationFailure

  SequenceTypeAlgorithms.add${traversal}CollectionTests(
    makeCollection: { (elements: [LifetimeTracked]) in
      return ${Base}(elements)
    },
    wrapValue: { (element: OpaqueValue<Int>) in
      LifetimeTracked(element.value, identity: element.identity)
    },
    extractValue: { (element: LifetimeTracked) in
      OpaqueValue(element.value, identity: element.identity)
    },
    makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
      // FIXME: use LifetimeTracked.
      return ${Base}(elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    checksAdded: checksAdded,
    resiliencyChecks: resiliencyChecks)

%       if mutable:
  SequenceTypeAlgorithms.add${traversal}MutableCollectionTests(
    makeCollection: { (elements: [LifetimeTracked]) in
      return ${Base}(elements)
    },
    wrapValue: { (element: OpaqueValue<Int>) in
      LifetimeTracked(element.value, identity: element.identity)
    },
    extractValue: { (element: LifetimeTracked) in
      OpaqueValue(element.value, identity: element.identity)
    },
    makeCollectionOfEquatable: { (elements: [MinimalEquatableValue]) in
      // FIXME: use LifetimeTracked.
      return ${Base}(elements)
    },
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    makeCollectionOfComparable: { (elements: [MinimalComparableValue]) in
      // FIXME: use LifetimeTracked.
      return ${Base}(elements)
    },
    wrapValueIntoComparable: identityComp,
    extractValueFromComparable: identityComp,
    checksAdded: checksAdded,
    resiliencyChecks: resiliencyChecks,
    withUnsafeMutableBufferPointerIsSupported: false)
%       end
}

// Test Slice<Base> of various collections using value types as elements.
if true {
  func makeCollection(elements: [OpaqueValue<Int>])
    -> Slice<${Base}<OpaqueValue<Int>>> {
    let baseElements =
      [ -9999, -9998, -9997 ].map(OpaqueValue.init) + elements
    let base = ${Base}(baseElements)
    return Slice(
      base: base,
      bounds: advance(base.startIndex, numericCast(3))..<base.endIndex)
  }

  func makeCollectionOfEquatable(elements: [MinimalEquatableValue])
    -> Slice<${Base}<MinimalEquatableValue>> {
    let baseElements =
      [ -9999, -9998, -9997 ].map(MinimalEquatableValue.init) + elements
    let base = ${Base}(baseElements)
    return Slice(
      base: base,
      bounds: advance(base.startIndex, numericCast(3))..<base.endIndex)
  }

  func makeCollectionOfComparable(elements: [MinimalComparableValue])
    -> Slice<${Base}<MinimalComparableValue>> {
    let baseElements =
      [ -9999, -9998, -9997 ].map(MinimalComparableValue.init) + elements
    let base = ${Base}(baseElements)
    return Slice(
      base: base,
      bounds: advance(base.startIndex, numericCast(3))..<base.endIndex)
  }

  var checksAdded: Box<Set<String>> = Box([])
  var resiliencyChecks = CollectionMisuseResiliencyChecks.all
  resiliencyChecks.creatingOutOfBoundsIndicesBehavior = .ExpectationFailure
  resiliencyChecks.subscriptOnOutOfBoundsIndicesBehavior = .Trap
  resiliencyChecks.subscriptRangeOnOutOfBoundsRangesBehavior
    = .ExpectationFailure

  SequenceTypeAlgorithms.add${traversal}CollectionTests(
    makeCollection: makeCollection,
    wrapValue: identity,
    extractValue: identity,
    makeCollectionOfEquatable: makeCollectionOfEquatable,
    wrapValueIntoEquatable: identityEq,
    extractValueFromEquatable: identityEq,
    checksAdded: checksAdded,
    resiliencyChecks: resiliencyChecks,
    outOfBoundsIndexOffset: 4)
}

%     end
%   end
% end

runAllTests()

