
//===--- Index.swift.gyb - tests for Index types and operations -----------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// -*- swift -*-
// RUN: rm -rf %t ; mkdir -p %t
// RUN: %S/../../utils/gyb %s -o %t/Index.swift
// RUN: %S/../../utils/line-directive %t/Index.swift -- %target-build-swift %t/Index.swift -o %t/a.out
// RUN: %S/../../utils/line-directive %t/Index.swift -- %target-run %t/a.out
// REQUIRES: executable_test

import StdlibUnittest
import StdlibCollectionUnittest


extension Collection {
  func nthIndex(_ offset: Int) -> Index {
    return self.location(self.startIndex, offsetBy: numericCast(offset))
  }
}

struct DistanceFromToTest {
  let startOffset: Int
  let endOffset: Int
  var expectedDistance : Int { return endOffset - startOffset }
  let loc: SourceLoc

  init(
    _ offsets: Range<Int>,
    file: String = #file, line: UInt = #line
  ) {
    self.startOffset = offsets.lowerBound
    self.endOffset = offsets.upperBound
    self.loc = SourceLoc(file, line, comment: "distance(from:to:) test data")
  }
}

struct IndexStepsFromTest {
  let startOffset: Int
  let distance: Int
  let limit: Int?
  
  var expectedOffset: Int? {
    let fullOffset = startOffset + distance
    return limit != nil && fullOffset > limit! ? nil : fullOffset
  }
  
  let loc: SourceLoc
  init(
    startOffset: Int, distance: Int,
    limitedBy limit: Int? = nil,
    file: String = #file, line: UInt = #line
  ) {
    self.startOffset = startOffset
    self.distance = distance
    self.limit = limit
    self.loc = SourceLoc(file, line, comment: "location(_:offsetBy:) test data")
  }
}

let distanceFromToTests = [
  DistanceFromToTest(0..<0),
  DistanceFromToTest(10..<10),
  DistanceFromToTest(10..<13),
  DistanceFromToTest(7..<10),
]

let indexStepsFromTests = [
  IndexStepsFromTest(startOffset: 0, distance: 0),
  IndexStepsFromTest(startOffset: 0, distance: -1),
  IndexStepsFromTest(startOffset: 0, distance: 0, limitedBy: 0),
  IndexStepsFromTest(startOffset: 0, distance: 0, limitedBy: 10),
  IndexStepsFromTest(startOffset: 0, distance: 10, limitedBy: 0),
  IndexStepsFromTest(startOffset: 0, distance: -10, limitedBy: 0),
  IndexStepsFromTest(startOffset: 0, distance: 10, limitedBy: 10),
  IndexStepsFromTest(startOffset: 0, distance: 20, limitedBy: 10),
  IndexStepsFromTest(startOffset: 10, distance: -20, limitedBy: 0),
]

var Index = TestSuite("Index")

% from gyb_stdlib_support import collectionForTraversal

% # RandomAccess does not add any new behaviors to Bidirectional
% # so we are left with just 2 traversals for the following tests
% for Traversal in ['Forward', 'Bidirectional']:
%   TraversalCollection = collectionForTraversal(Traversal)

Index.test("${TraversalCollection}/distance(to:)/dispatch") {
  let c = ${TraversalCollection}Log.dispatchTester(Array(0..<10))
  _ = c.distance(from: 0, to: 10)
  expectCustomizable(c, c.log.distance)
}

Index.test("${TraversalCollection}/location(_:offsetBy:)/dispatch") {
  let c = ${TraversalCollection}Log.dispatchTester(Array(0..<10))
  _ = c.location(c.startIndex, offsetBy: 10)
  expectCustomizable(c, c.log.advance)
}

Index.test("${TraversalCollection}/location(_:offsetBy:limitedBy:)/dispatch") {
  let c = ${TraversalCollection}Log.dispatchTester(Array(0..<10))
  _ = c.location(c.startIndex, offsetBy: 10, limitedBy: 5)
  expectCustomizable(c, c.log.advanceLimit)
}

% end

% for Traversal in ['Forward', 'Bidirectional', 'RandomAccess']:
%   Collection = collectionForTraversal(Traversal).replace('Collection', '')
%   for Base in ['Minimal', 'Defaulted']:
%     Kind = '{}{}'.format(Base, Collection)

Index.test("${Kind}Collection/distance(from:to:)/semantics") {
  let c = ${Kind}Collection(elements: Array(0..<20))
  for test in distanceFromToTests {
    let d = c.distance(
      from: c.nthIndex(test.startOffset), to: c.nthIndex(test.endOffset))
    expectEqual(
      test.expectedDistance, d, stackTrace: SourceLocStack().with(test.loc))
  }
}

Index.test("${Kind}Collection/index(_:stepsFrom: n)/semantics") {
  for test in indexStepsFromTests.filter(
    {$0.limit == nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(elements: Array(0..<10))

    let new = c.location(c.nthIndex(test.startOffset), offsetBy: test.distance)
    // Since the `nthIndex(offset:)` method performs the same operation
    // (i.e. adavances `c.startIndex` by `test.distance`, it would be
    // silly to compare index values. Luckily the underlying collection
    // contains exactly index offsets.
    expectEqual(test.expectedOffset!, c[new],
      stackTrace: SourceLocStack().with(test.loc))
  }
}

%     if Traversal == 'Forward':
Index.test("${Kind}Collection/index(_:stepsFrom: -n)/semantics") {
  for test in indexStepsFromTests.filter({$0.limit == nil && $0.distance < 0}) {
    let c = ${Kind}Collection(elements: Array(0..<10))
    let start = c.nthIndex(test.startOffset)
    expectCrashLater()
    _ = c.location(start, offsetBy: test.distance)
  }
}
%     end

%     if Traversal == 'Forward':
Index.test("${Kind}Collection/advance(by: -n, limitedBy:)/semantics") {
  for test in indexStepsFromTests.filter({$0.limit != nil && $0.distance < 0}) {
    let c = ${Kind}Collection(elements: Array(0..<10))
    let limit = c.nthIndex(test.limit.unsafelyUnwrapped)
    let start = c.nthIndex(test.startOffset)
    expectCrashLater()
    _ = c.location(start, offsetBy: test.distance, limitedBy: limit)
  }
}
%     end

Index.test("${Kind}Collection/advance(by: n, limitedBy:)/semantics") {
  for test in indexStepsFromTests.filter(
    {$0.limit != nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(elements: Array(0..<20))
    let limit = c.nthIndex(test.limit.unsafelyUnwrapped)

%     if Traversal == 'Forward':

    if test.distance < 0 {
      expectCrashLater()
    }

%     end

    let new = c.location(
      c.nthIndex(test.startOffset),
      offsetBy: test.distance,
      limitedBy: limit)
    if test.expectedOffset == nil {
      expectEmpty(new)
    } else {
      expectEqual(c.nthIndex(test.expectedOffset!), new!,
        stackTrace: SourceLocStack().with(test.loc))
    }
  }
}

// Check that a random access collection doesn't call into O(n) predecessor
// calls when it has a more efficient implementation.

%     if Traversal == 'RandomAccess' and Base == 'Defaulted':

Index.test(
  "${Kind}Collection/location(_:offsetBy:)/"
  + "avoidsSuccessorAndPredecessor/dispatch"
) {
  for test in indexStepsFromTests.filter(
    {$0.limit == nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(Array(0..<10))

    let i = c.nthIndex(test.startOffset)
    let result  = c.location(i, offsetBy: test.distance)
    expectEqual(0, c.timesSuccessorCalled.value)
    expectEqual(0, c.timesPredecessorCalled.value)
  }
}

#if false // FIXME: swift-3-indexing-model. implementation missing
Index.test(
  "${Kind}Index/location(_:offsetBy:limitedBy:)/"
  + "avoidsSuccessorAndPredecessor/dispatch"
) {
  for test in indexStepsFromTests.filter(
    {$0.limit != nil && $0.distance >= 0}
  ) {
    let c = ${Kind}Collection(Array(0..<10))

    let i = c.nthIndex(test.startOffset)
    let limit = c.nthIndex(test.limit.unsafelyUnwrapped)
    _ = c.location(i, offsetBy: test.distance, limitedBy: limit)
    expectEqual(0, c.timesSuccessorCalled.value)
    expectEqual(0, c.timesPredecessorCalled.value)
  }
}
#endif

%     end
%   end
% end

runAllTests()
