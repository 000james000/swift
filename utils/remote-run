#!/usr/bin/env python
# remote-run - Runs a command on another machine, for testing -----*- python -*-
#
# This source file is part of the Swift.org open source project
#
# Copyright (c) 2018 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See https://swift.org/LICENSE.txt for license information
# See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
# ----------------------------------------------------------------------------

from __future__ import print_function

import argparse
import os.path
import subprocess

def quote(arg):
    return repr(arg)

class CommandRunner(object):
    @staticmethod
    def _dirnames(files):
        return list(set(os.path.dirname(f) for f in files))

    def send(self, local_to_remote_files):
        # Prepare the remote directory structure.
        # FIXME: This could be folded into the sftp connection below.
        dirs_to_make = self._dirnames(local_to_remote_files.viewvalues())
        self.run_remote(['/bin/mkdir', '-p'] + dirs_to_make)

        # Send the local files.
        copy_proc = self.open_sftp()
        _, _ = copy_proc.communicate('\n'.join("-put {0} {1}".format(quote(local_file), quote(remote_file)) for local_file, remote_file in local_to_remote_files.viewitems()))
        # FIXME: dump stderr at this point
        assert copy_proc.returncode == 0, "sftp send failed"

    def fetch(self, local_to_remote_files):
        # Prepare the local directory structure.
        dirs_to_make = self._dirnames(download_files.viewkeys())
        subprocess.check_call(['/bin/mkdir', '-p'] + dirs_to_make)

        # Fetch the remote files.
        copy_proc = self.open_sftp()
        _, _ = copy_proc.communicate('\n'.join("-get {0} {1}".format(quote(remote_file), quote(local_file)) for local_file, remote_file in download_files.viewitems()))
        # FIXME: dump stderr at this point
        assert copy_proc.returncode == 0, "sftp fetch failed"

class RemoteCommandRunner(CommandRunner):
    def __init__(self, remote_host):
        self.remote_host = remote_host

    def run_remote(self, command):
        return subprocess.check_output(['/usr/bin/ssh', '-n', self.remote_host, '--'] +
            [quote(arg) for arg in command])

    def open_sftp(self):
        return subprocess.Popen(['/usr/bin/sftp', '-b', '-', self.remote_host],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

class LocalCommandRunner(CommandRunner):
    def run_remote(self, command):
        return subprocess.check_output(command)

    def open_sftp(self):
        return subprocess.Popen(['/usr/bin/sftp', '-b', '-', '-D', '/usr/libexec/sftp-server'],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)


def find_transfers(args, source_dir, dest_dir):
    if not source_dir.endswith(os.path.sep):
        source_dir += os.path.sep
    result = dict()
    for arg in args:
        if not arg.startswith(source_dir):
            continue
        relative_path = os.path.relpath(arg, source_dir)
        result[arg] = os.path.join(dest_dir, relative_path)
    return result

parser = argparse.ArgumentParser()
parser.add_argument('--source-dir')
parser.add_argument('--test-dir')
parser.add_argument('--remote-dir', required=True)
parser.add_argument('--debug-as-local', action='store_true')
parser.add_argument('host')
parser.add_argument('command', nargs=argparse.REMAINDER)
args = parser.parse_args()

if args.debug_as_local:
    runner = LocalCommandRunner()
    args.command.insert(0, args.host)
    del args.host
else:
    runner = RemoteCommandRunner(args.host)

upload_files = dict()
download_files = dict()
if args.source_dir:
    input_files = find_transfers(args.command, args.source_dir, os.path.join(args.remote_dir, 'inputs'))
    assert not any(upload_files.has_key(f) for f in input_files)
    upload_files.update(input_files)
if args.test_dir:
    test_files = find_transfers(args.command, args.test_dir, os.path.join(args.remote_dir, 'inout'))
    assert not any(upload_files.has_key(f) for f in test_files)
    upload_files.update(test_files)
    assert not any(download_files.has_key(f) for f in test_files)
    download_files.update(test_files)

if upload_files:
    runner.send(upload_files)

translated_command = [upload_files.get(arg, download_files.get(arg, arg)) for arg in args.command]
print(runner.run_remote(translated_command))

if download_files:
    runner.fetch(download_files)
