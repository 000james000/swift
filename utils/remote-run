#!/usr/bin/env python
# remote-run - Runs a command on another machine, for testing -----*- python -*-
#
# This source file is part of the Swift.org open source project
#
# Copyright (c) 2018 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See https://swift.org/LICENSE.txt for license information
# See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
# ----------------------------------------------------------------------------

from __future__ import print_function

import argparse
import os.path
import subprocess
import sys

def quote(arg):
    return repr(arg)

class CommandRunner(object):
    def __init__(self):
        self.verbose = False

    @staticmethod
    def _dirnames(files):
        return list(set(os.path.dirname(f) for f in files))

    def popen(self, command, **kwargs):
        if self.verbose:
            print(' '.join(command), file=sys.stderr)
        return subprocess.Popen(command, **kwargs)

    def send(self, local_to_remote_files):
        # Prepare the remote directory structure.
        # FIXME: This could be folded into the sftp connection below.
        dirs_to_make = self._dirnames(local_to_remote_files.viewvalues())
        self.run_remote(['/bin/mkdir', '-p'] + dirs_to_make)

        # Send the local files.
        copy_proc = self.open_sftp()
        sftp_commands = '\n'.join("-put {0} {1}".format(quote(local_file), quote(remote_file)) for local_file, remote_file in local_to_remote_files.viewitems())
        if self.verbose:
            print(sftp_commands, file=sys.stderr)
        _, _ = copy_proc.communicate(sftp_commands)
        if copy_proc.returncode:
            sys.exit(copy_proc.returncode)

    def fetch(self, local_to_remote_files):
        # Prepare the local directory structure.
        dirs_to_make = self._dirnames(local_to_remote_files.viewkeys())
        mkdir_command = ['/bin/mkdir', '-p'] + dirs_to_make
        if self.verbose:
            print(' '.join(mkdir_command), file=sys.stderr)
        subprocess.check_call(mkdir_command)

        # Fetch the remote files.
        copy_proc = self.open_sftp()
        sftp_commands = '\n'.join("-get {0} {1}".format(quote(remote_file), quote(local_file)) for local_file, remote_file in local_to_remote_files.viewitems())
        if self.verbose:
            print(sftp_commands, file=sys.stderr)
        _, _ = copy_proc.communicate(sftp_commands)
        if copy_proc.returncode:
            sys.exit(copy_proc.returncode)

    def run_remote(self, command, remote_env={}):
        env_strings = ['{0}={1}'.format(k,v) for k,v in remote_env.viewitems()]
        remote_invocation = self.remote_invocation(
            ['/usr/bin/env'] + env_strings + command)
        remote_proc = self.popen(remote_invocation,
            stdin=subprocess.PIPE,
            stdout=None,
            stderr=None)
        _, _ = remote_proc.communicate()
        if remote_proc.returncode:
            # FIXME: We may still want to fetch the output files to see what
            # went wrong.
            sys.exit(remote_proc.returncode)
    
    def open_sftp(self):
        return self.popen(self.sftp_invocation(),
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=None)

class RemoteCommandRunner(CommandRunner):
    def __init__(self, remote_host):
        self.remote_host = remote_host

    def remote_invocation(self, command):
        return (['/usr/bin/ssh', '-n', self.remote_host, '--'] +
            [quote(arg) for arg in command])

    def sftp_invocation(self):
        return ['/usr/bin/sftp', '-b', '-', self.remote_host]

class LocalCommandRunner(CommandRunner):
    def remote_invocation(self, command):
        return command

    def sftp_invocation(self):
        return ['/usr/bin/sftp', '-b', '-', '-D', '/usr/libexec/sftp-server']

def find_transfers(args, source_prefix, dest_prefix):
    if source_prefix.endswith(os.path.sep):
        source_prefix = source_prefix[:-len(os.path.sep)]
    return dict((arg, dest_prefix + arg[len(source_prefix):]) for arg in args if arg.startswith(source_prefix))

def collect_remote_env(local_env=os.environ, prefix='REMOTE_RUN_CHILD_'):
    return dict((key[len(prefix):], value) for key, value in local_env.items() if key.startswith(prefix))

parser = argparse.ArgumentParser()
parser.add_argument('--input-prefix')
parser.add_argument('--output-prefix')
parser.add_argument('--remote-dir', required=True)
parser.add_argument('--remote-input-prefix', default='input')
parser.add_argument('--remote-output-prefix', default='output')
parser.add_argument('--debug-as-local', action='store_true')
parser.add_argument('--verbose', '-v', action='store_true')
parser.add_argument('host')
parser.add_argument('command', nargs=argparse.REMAINDER)
args = parser.parse_args()

if args.debug_as_local:
    runner = LocalCommandRunner()
    args.command.insert(0, args.host)
    del args.host
else:
    runner = RemoteCommandRunner(args.host, args.identity)
runner.verbose = args.verbose

upload_files = dict()
download_files = dict()
if args.input_prefix:
    input_files = find_transfers(args.command, args.input_prefix, os.path.join(args.remote_dir, args.remote_input_prefix))
    assert not any(upload_files.has_key(f) for f in input_files)
    upload_files.update(input_files)
if args.output_prefix:
    test_files = find_transfers(args.command, args.output_prefix, os.path.join(args.remote_dir, args.remote_output_prefix))
    assert not any(upload_files.has_key(f) for f in test_files)
    upload_files.update(test_files)
    assert not any(download_files.has_key(f) for f in test_files)
    download_files.update(test_files)

if upload_files:
    runner.send(upload_files)

remote_env = collect_remote_env()

translated_command = [upload_files.get(arg, download_files.get(arg, arg)) for arg in args.command]
runner.run_remote(translated_command, remote_env)

if download_files:
    runner.fetch(download_files)
