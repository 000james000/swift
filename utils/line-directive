#!/usr/bin/env python
# line-directive.py - Transform line numbers in error messages -*- python -*-
#
# This source file is part of the Swift.org open source project
#
# Copyright (c) 2014 - 2016 Apple Inc. and the Swift project authors
# Licensed under Apache License v2.0 with Runtime Library Exception
#
# See http://swift.org/LICENSE.txt for license information
# See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#
# ----------------------------------------------------------------------------
#
# Converts line numbers in error messages according to "line directive"
# comments.
#
# ----------------------------------------------------------------------------

import bisect
import re
import subprocess
import sys

line_pattern = re.compile(
    r'^// ###sourceLocation\(file:\s*"([^"]+)",\s*line:\s*([0-9]+)\s*\)')


def _make_line_map(filename, stream=None):
    """
    >>> from StringIO import StringIO
    >>> _make_line_map('box',
    ... StringIO('''// ###sourceLocation(file: "foo.bar", line: 3)
    ... line 2
    ... line 3
    ... line 4
    ... // ###sourceLocation(file: "baz.txt", line: 20)
    ... line 6
    ... line 7
    ... '''))
    [(0, 'box', 1), (1, 'foo.bar', 3), (5, 'baz.txt', 20)]
    """
    result = [(0, filename, 1)]
    input = stream or open(filename)
    for i, l in enumerate(input.readlines()):
        m = line_pattern.match(l)
        if m:
            result.append((i + 1, m.group(1), int(m.group(2))))
    return result

_line_maps = {}


def fline_map(filename):
    map = _line_maps.get(filename)
    if map is None:
        map = _make_line_map(filename)
        _line_maps[filename] = map
    return map


def map_line(filename, line_num):
    """
    >>> from tempfile import *
    >>> t = NamedTemporaryFile()
    >>> t.write('''line 1
    ... line 2
    ... // ###sourceLocation(file: "foo.bar", line: 20)
    ... line 4
    ... line 5
    ... // ###sourceLocation(file: "baz.txt", line: 5)
    ... line 7
    ... line 8
    ... ''')
    >>> t.flush()
    >>> (t2, l) = map_line(t.name, 1)
    >>> t2 == t.name, l
    (True, 1)
    >>> (t2, l) = map_line(t.name, 2)
    >>> t2 == t.name, l
    (True, 2)
    >>> (t2, l) = map_line(t.name, 3)
    >>> t2 == t.name, l
    (True, 3)
    >>> map_line(t.name, 4)
    ('foo.bar', 20)
    >>> map_line(t.name, 5)
    ('foo.bar', 21)
    >>> map_line(t.name, 6)
    ('foo.bar', 22)
    >>> map_line(t.name, 7)
    ('baz.txt', 5)
    >>> map_line(t.name, 8)
    ('baz.txt', 6)
    >>> map_line(t.name, 42)
    ('baz.txt', 40)
    """
    assert(line_num > 0)
    map = fline_map(filename)
    index = bisect.bisect_left(map, (line_num, '', 0))
    base = map[index - 1]
    return base[1], base[2] + (line_num - base[0] - 1)


def run():
    """
    >>> from tempfile import *
    >>> target1 = NamedTemporaryFile()
    >>> target1.write('''line 1
    ... line 2
    ... // ###sourceLocation(file: "foo.bar", line: 20)
    ... line 4
    ... line 5
    ... // ###sourceLocation(file: "baz.txt", line: 5)
    ... line 7
    ... line 8
    ... ''')
    >>> target1.flush()
    >>> target2 = NamedTemporaryFile()
    >>> target2.write('''// ###sourceLocation(file: "foo.bar", line: 7)
    ... line 2
    ... line 3
    ... // ###sourceLocation(file: "fox.box", line: 11)
    ... line 5
    ... line 6
    ... ''')
    >>> target2.flush()
    >>> raw_output = NamedTemporaryFile()
    >>> target1_name, target2_name = target1.name, target2.name
    >>> raw_output.write('''A
    ... %(target1_name)s:2:111: error one
    ... B
    ... %(target1_name)s:4:222: error two
    ... C
    ... %(target1_name)s:8:333: error three
    ... D
    ... glitch in file %(target2_name)s:1 assert one
    ... E
    ... glitch in file %(target2_name)s, line 2 assert two
    ... glitch at %(target2_name)s, line 3 assert three
    ... glitch at %(target2_name)s:4 assert four
    ... glitch in [%(target2_name)s, line 5 assert five
    ... glitch in [%(target2_name)s:22 assert six
    ... ''' % locals())
    >>> raw_output.flush()
    >>> import subprocess
    >>> output = subprocess.check_output([__file__, target1.name, target2.name, '--', 'cat', raw_output.name])
    >>> print output.replace(target1.name,'TARGET1-NAME').replace(target2.name,'TARGET2-NAME') + 'EOF'
    A
    TARGET1-NAME:2:111: error one
    B
    foo.bar:20:222: error two
    C
    baz.txt:6:333: error three
    D
    glitch in file TARGET2-NAME:1 assert one
    E
    glitch in file foo.bar, line 7 assert two
    glitch at foo.bar, line 8 assert three
    glitch at foo.bar:9 assert four
    glitch in [fox.box, line 11 assert five
    glitch in [fox.box:28 assert six
    EOF
    """
    if len(sys.argv) <= 1:
        import doctest
        doctest.testmod()
    else:
        dashes = sys.argv.index('--')
        sources = sys.argv[1:dashes]

        command = subprocess.Popen(
            sys.argv[dashes + 1:],
            stderr=subprocess.STDOUT,
            stdout=subprocess.PIPE,
            universal_newlines=True
        )

        error_pattern = re.compile(
            '^(?P<file>' + '|'.join(re.escape(s) for s in sources) +
            '):(?P<line>[0-9]+):(?P<column>[0-9]+):(?P<tail>.*)')

        assertion_pattern = re.compile(
            '^(?P<head>.*( file | at |#[0-9]+: |[[]))(?P<file>' +
            '|'.join(re.escape(s) for s in sources) +
            ')(?P<middle>, line |:)(?P<line>[0-9]+)(?P<tail>.*)')

        while True:
            line = command.stdout.readline()
            if line == '':
                break
            l = line.rstrip('\n')
            m = error_pattern.match(l)
            if m:
                file, line_num = map_line(m.group('file'),
                                          int(m.group('line')))
                line = '%s:%s:%s:%s\n' % (
                    file, line_num, int(m.group(3)), m.group(4))
            else:
                m = assertion_pattern.match(l)
                if m:
                    file, line_num = map_line(m.group('file'),
                                              int(m.group('line')))
                    line = '%s%s%s%s%s\n' % (
                        m.group('head'), file, m.group('middle'), line_num,
                        m.group('tail'))
            sys.stdout.write(line)

        sys.exit(command.wait())

if __name__ == '__main__':
    run()
