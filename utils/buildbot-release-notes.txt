2013-08-28
----------

* Swift now supports unions. Unlike C unions, Swift's 'union' is type-safe
  and always knows what type it contains at runtime. Union members are labeled
  using 'case' declarations; each case may have a different set of
  types or no type:

    union MaybeInt {
      case Some(Int)
      case None
    }

    union HTMLTag {
      case A(href:String)
      case IMG(src:String, alt:String)
      case BR
    }

  Each 'case' with a type defines a static constructor function for the union
  type. 'case' declarations without types become static members:

    var br = HTMLTag.BR
    var a = HTMLTag.A(href:"http://www.apple.com/")
    // 'HTMLTag' scope deduced for '.IMG' from context
    var img : HTMLTag = .IMG(src:"http://www.apple.com/mac-pro.png",
                             alt:"The new Mac Pro")

  Cases can be pattern-matched using 'switch':

    switch tag {
    case .BR:
      println("<br>")
    case .IMG(var src, var alt):
      println("<img src=\"\(escape(src))\" alt=\"\(escape(alt))\">")
    case .A(var href):
      println("<a href=\"\(escape(href))\">")
    }

  Due to implementation limitations, unions cannot yet contain values of
  protocol type, weak reference type, or generic parameter type.

2013-08-14
----------

* Swift now supports weak references by applying the [weak] attribute to a
  variable declaration.

    (swift) var x = NSObject()
    // x : NSObject = <NSObject: 0x7f95d5804690>
    (swift) var [weak] w = x
    // w : NSObject = <NSObject: 0x7f95d5804690>
    (swift) w == nil
    // r2 : Bool = false
    (swift) x = NSObject()
    (swift) w == nil
    // r3 : Bool = true

  Swift also supports a special form of weak reference, called [unowned], for
  references that should never be nil but are required to be weak to break
  cycles, such as parent or sibling references. Accessing an [unowned]
  reference asserts that the reference is still valid and implicitly promotes
  the loaded reference to a strong reference, so it does not need to be loaded
  and checked for nullness before use like a true [weak] reference.

    class Parent {
      var children : Vector<Child>

      func addChild(c:Child) {
        c.parent = this
        children.append(c)
      }
    }

    class Child {
      var [unowned] parent : Parent
    }


2013-07-31
----------

* Numeric literals can now use underscores as separators. For example:

    var billion = 1_000_000_000
    var crore = 1_00_00_000
    var MAXINT = 0x7FFF_FFFF_FFFF_FFFF
    var SMALLEST_DENORM = 0x0.0000_0000_0000_1p-1022


* Types conforming to protocols now must always declare the conformance in
  their inheritance clause.


* The build process now produces serialized modules for the standard library,
  greatly improving build times.


2013-07-24
----------

* Arithmetic operators "+", "-", "*", and "/" on integer types now do
  overflow checking and trap on overflow. A parallel set of masking operators,
  "&+", "&-", "&*", and "&/", are defined to perform two's complement wrapping
  arithmetic for all signed and unsigned integer types.


* Debugger support. Swift has a "-g" command line switch that turns on
  debug info for the compiled output. Using the standard lldb debugger
  this will allow single-stepping through Swift programs, printing
  backtraces, and navigating through stack frames; all in sync with
  the corresponding Swift source code. An unmodified lldb cannot
  inspect any variables.

  Example session:
    $ echo 'println("Hello World")' >hello.swift
    $ swift hello.swift -c -g -o hello.o
    $ ld hello.o "-dynamic" "-arch" "x86_64" "-macosx_version_min" "10.9.0" \
         -framework Foundation lib/swift/libswift_stdlib_core.dylib \
         lib/swift/libswift_stdlib_posix.dylib -lSystem -o hello
    $ lldb hello
    Current executable set to 'hello' (x86_64).
    (lldb) b top_level_code
    Breakpoint 1: where = hello`top_level_code + 26 at hello.swift:1, addre...
    (lldb) r
    Process 38592 launched: 'hello' (x86_64)
    Process 38592 stopped
    * thread #1: tid = 0x1599fb, 0x0000000100000f2a hello`top_level_code + ...
        frame #0: 0x0000000100000f2a hello`top_level_code + 26 at hello.shi...
    -> 1         println("Hello World")
    (lldb) bt
    * thread #1: tid = 0x1599fb, 0x0000000100000f2a hello`top_level_code + ...
        frame #0: 0x0000000100000f2a hello`top_level_code + 26 at hello.shi...
        frame #1: 0x0000000100000f5c hello`main + 28
        frame #2: 0x00007fff918605fd libdyld.dylib`start + 1
        frame #3: 0x00007fff918605fd libdyld.dylib`start + 1

  Also try "s", "n", "up", "down".


2013-07-17
----------

* Swift now has a 'switch' statement, supporting pattern matching of
  multiple values with variable bindings, guard expressions, and range
  comparisons. For example:

    func classifyPoint(point:(Int, Int)) {
      switch point {
      case (0, 0):
        println("origin")

      case (_, 0):
        println("on the x axis")

      case (0, _):
        println("on the y axis")

      case (var x, var y) where x == y:
        println("on the y = x diagonal")

      case (var x, var y) where -x == y:
        println("on the y = -x diagonal")

      case (-10..10, -10..10):
        println("close to the origin")

      case (var x, var y):
        println("length \(sqrt(x*x + y*y))")
      }
    }


2013-07-10
----------

* Swift has a new closure syntax. The new syntax eliminates the use of
  pipes. Instead, the closure signature is written the same way as a
  function type and is separated from the body by the "in"
  keyword. For example:

    sort(fruits) { (lhs : String, rhs : String) -> Bool in
      return lhs > rhs 
    }

  When the types are omitted, one can also omit the parentheses, e.g.,

    sort(fruits) { lhs, rhs in lhs > rhs }

  Closures with no parameters or that use the anonymous parameters
  ($0, $1, etc.) don't need the 'in', e.g.,

    sort(fruits) { $0 > $1 }


* nil can now be used without explicit casting. Previously, 'nil' had
  type NSObject, so one would have to write (e.g.) 'nil as! NSArray'
  to create a nil NSArray. Now, 'nil' picks up the type of its
  context.


* POSIX.EnvironmentVariables and swift.CommandLineArguments global variables
  were merged into a swift.Process variable.  Now you can access command line
  arguments with Process.arguments.  In order to acces environment variables
  add "import POSIX" and use Process.environmentVariables.

