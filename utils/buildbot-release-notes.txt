2014-01-22
----------

* The swift binary no longer has an SDK set by default. Instead, you must do
  one of the following:
    - pass an explicit "-sdk /path/to/sdk"
    - set SDKROOT in your environment
    - run swift through xcrun, which sets SDKROOT for you

* 'let' declarations can now be used as struct/class properties.  A 'let' 
  property is mutable within init(), and immutable everywhere else.

    class C {
      let x = 42
      let y : Int
      init(y : Int) {
        self.y = y   // ok, self.y is mutable in init()
      }
      
      func test() {
        y = 42       // error: 'y' isn't mutable
      }
    }

* The immutability model for structs and enums is complete, and arguments are
  immutable by default.  This allows the compiler to reject mutations of
  temporary objects, catching common bugs.  For example, this is rejected:
  
    func setTo4(a : Double[]) {
      a[10] = 4.0     // error: 'a' isn't mutable
    }
    ...
    setTo4(someArray)

  since "a" is semantically a copy of the array passed into the function.  The
  proper fix in this case is to mark the argument is @inout, so the effect is
  visible in the caller:
  
    func setTo4(a : @inout Double[]) {
      a[10] = 4.0     // ok: 'a' is a mutable reference
    }
    ...
    setTo4(&someArray)

  Alternatively, if you really just want a local copy of the argument, you can
  mark it var.  The effects aren't visible in the caller, but this can be
  convenient in some cases:
  
    func doStringStuff(var s : String) {
      s += "foo"
      print(s)
    }

* Objective-C instance variables are no longer imported from headers written in
  Objective-C. Previously, they would appear as vars within the Objective-C
  class, but trying to access them would result in a crash. Additionally, their
  names can conflict with property names, which confuses the Swift compiler,
  and there are no patterns in our frameworks that expect you to access a
  parent or other class's instance variables directly. Use properties instead.


2014-01-15
----------

* Improved deallocation of Swift classes that inherit from Objective-C
  classes: Swift destructors are implemented as -dealloc methods that
  automatically call the superclass's -dealloc. Stored properties are
  released right before the object is deallocated (using the same
  mechanism as ARC), allowing properties to be safely used in
  destructors.

* Subclasses of NSManagedObject are now required to provide initial
  values for each of their stored properties. This permits
  initialization of these stored properties directly after +alloc to
  provide memory safety with CoreData's dynamic subclassing scheme.

* 'let' declarations are continuing to make slow progress. Curried
   and selector-style arguments are now immutable by default, and
   'let' declarations now get proper debug information.

2014-01-08
----------

* The "static" keyword changed to "type". One can now define "type
  functions" and "type variables" which are functions and variables
  defined on a type (rather than on an instance of the type), e.g.,

    class X {
      type func factory() -> X { ... }

      type var version: Int
    }

  The use of "static" was actively misleading, since type methods
  on classes are dynamically dispatched (the same as Objective-C
  "+" methods).

  Note that "type" is a context-sensitive keyword; it can still be
  used as an identifier.

* Strings have a new native UTF-16 representation that can be
  converted back and forth to NSString at minimal cost. String
  literals are emitted as UTF-16 for string types that support it
  (including Swift's String).

* Initializers can now delegate to other initializers within the same
  class by calling 'self.init'. For example:

    class A { }

    class B : A {
      var title: String

      init() {
        // note: cannot access self before delegating
        self.init(withTitle: "My Title")
      }

      init withTitle(title: String) {
        self.title = title
        super.init()
      }
    }


* Objective-C protocols no longer have the "Proto" suffix unless there
  is a collision with a class name. For example, UITableViewDelegate is
  now imported as "UITableViewDelegate" rather than
  "UITableViewDelegateProto". Where there is a conflict with a class,
  the protocol will be suffixed with "Proto", as in "NSObject" (the
  class) and "NSObjectProto" (the protocol).

2014-01-01
----------

* Happy New Year

* Division and remainder arithmetic now trap on overflow. Like with the other
  operators, one can use the "masking" alternatives to get non-trapping
  behavior. The behavior of the non-trapping masking operators is defined:
    x &/ 0 == 0
    x &% 0 == 0
    SIGNED_MIN_FOR_TYPE &/ -1 == -1 // i.e. Int8: -0x80 / -1 == -0x80
    SIGNED_MIN_FOR_TYPE &% -1 == 0

* Protocol conformance checking for @mutating methods is now implemented: an
  @mutating struct method only fulfills a protocol requirement if the protocol
  method was itself marked @mutating:

    protocol P {
      func nonmutating()
      @mutating
      func mutating()
    }
    
    struct S : P {
      // Error, @mutating method cannot implement non-@mutating requirement.
      @mutating
      func nonmutating() {}
      
      // Ok, mutating allowed, but not required.
      func mutating() {}
    }
    
  As before, class methods never need to be marked @mutating (and indeed, they
  aren't allowed to be marked as such).


2013-12-25
----------

* Merry Christmas

* The setters of properties on value types (structs/enums) are now @mutating by
  default.  To mark a setter non-mutating, use the @!mutating attribute.

* Compiler inserts calls to super.init() into the class initializers that do
  not call any initializers explicitly.

* A "map" method with the semantics of Haskell's "fmap" was added to
  Array<T>.  Map applies a function f: T->U to the values stored in
  the array and returns an Array<U>.  So,

    (swift) func names(x: Int[]) -> String[] {
              return x.map { "<" + String($0) + ">" }
            }
    (swift) names(Array<Int>())
    // r0 : String[] = []
    (swift) names([3, 5, 7, 9])
    // r1 : String[] = ["<3>", "<5>", "<7>", "<9>"]

2013-12-18
----------

* Global variables and static properties are now lazily initialized on first
  use. Where you would use dispatch_once to lazily initialize a singleton
  object in Objective-C, you can simply declare a global variable with an
  initializer in Swift. Like dispatch_once, this lazy initialization is thread
  safe.

  Unlike C++ global variable constructors, Swift global variables and
  static properties now never emit static constructors (and thereby don't
  raise B&I flags). Also unlike C++, lazy initialization naturally follows 
  dependency order, so global variable initializers that cross module
  boundaries don't have undefined behavior or fragile link order dependencies.

* Swift has the start of an immutability model for value types. As part of this,
  you can now declare immutable value bindings with a new 'let' declaration,
  which is semantically similar to defining a get-only property:

    let x = foo()
    print(x)        // ok
    x = bar()       // error: cannot modify an immutable value
    swap(&x, &y)    // error: cannot pass an immutable value as @inout parameter
    x.clear()       // error: cannot call mutating method on immutable value
    getX().clear()  // error: cannot mutate a temporary
  
  In the case of bindings of class type, the bound object itself is still
  mutable, but you cannot change the binding.
  
    let r = Rocket()
    r.blastOff()    // Ok, your rocket is mutable.
    r = Rocket()    // error: cannot modify an immutable binding.

  In addition to the 'let' declaration itself, 'self' on classes, and a few
  other minor things have switched to immutable bindings.
  
  A pivotal part of this is that methods of value types (structs and enums) need
  to indicate whether they can mutate self - mutating methods need to be
  disallowed on let values (and get-only property results, temporaries, etc) but
  non-mutating methods need to be allowed.  The default for a method is that it
  does not mutate 'self', though you can opt into mutating behavior with a new
  @mutating attribute:
  
    struct MyWeirdCounter {
      var count : Int
      
      func empty() -> Bool { return count == 0 }
      
      @mutating
      func reset() {
        count = 0
      }
      ...
    }

    let x = MyWeirdCounter()
    x.empty()   // ok
    x.reset()   // error, cannot mutate immutable 'let' value

   One missing piece is that the compiler does not yet reject mutations of self
   in a method that isn't marked @mutating.  That will be coming soon.  Related
   to methods are properties.  Getters and setters can be marked mutating as
   well:

   extension MyWeirdCounter {
      var myproperty : Int {
      get:
        return 42

      @mutating
      set:
        count = value*2
      }
    }

  The intention is for setters to default to mutating, but this has not been 
  implemented yet.  There is more to come here.

* A "map" method with the semantics of Haskell's "fmap" was added to
  Optional<T>.  Map applies a function f: T->U to any value stored in
  an Optional<T>, and returns an Optional<U>.  So,

    (swift) func nameOf(x: Int?) -> String? {
              return x.map { "<" + String($0) + ">" }
            }
   (swift)            
   (swift) var no = nameOf(.None) // Empty optional in...
   // no : String? = <unprintable value>
   (swift) no ? "yes" : "no"      // ...empty optional out
   // r0 : String = "no"
   (swift)
   (swift) nameOf(.Some(42))      // Non-empty in 
   // r1 : String? = <unprintable value>
   (swift) nameOf(.Some(42))!     // Non-empty out
   // r2 : String = "<42>"

* Cocoa types declared with the NS_OPTIONS macro are now available in Swift.
  Like NS_ENUM types, their values are automatically shortened based
  on the common prefix of the value names in Objective-C, and the name can
  be elided when type context provides it. They can be used in 'if' statements
  using the '&', '|', '^', and '~' operators as in C:

    var options: NSJSONWritingOptions = .PrettyPrinted
    if options & .PrettyPrinted {
      println("pretty-printing enabled")
    }

  We haven't yet designed a convenient way to author NS_OPTIONS-like types
  in Swift.

2013-12-11
----------

* Objective-C 'id' is now imported as 'AnyObject' (formerly known as
  'DynamicLookup'), Objective-C 'Class' is imported as 'AnyClass'.

* The casting syntax "x as T" now permits both implicit conversions
  (in which case it produces a value of type T) and for
  runtime-checked casts (in which case it produces a value of type T?
  that will be .Some(casted x) on success and .None on failure). An
  example:

    func f(x: AnyObject, y: NSControl) {
      var view = y as NSView                  // has type 'NSView'
      var maybeView = x as NSView             // has type NSView?
    }

* The precedence levels of binary operators has been redefined, with a much 
  simpler model than C's.  This is with a goal to define away classes of bugs
  such as those caught by Clang's -Wparentheses warnings, and to make it 
  actually possible for normal humans to reason about the precedence 
  relationships without having to look them up.
  
  We ended up with 6 levels, from tightest binding to loosest:
    exponentiative: <<, >>
    multiplicative: *, /, %, &
    additive: +, -, |, ^
    comparative: ==, !=, <, <=, >=, >
    conjunctive: &&
    disjunctive: ||

* The "Enumerable" protocol has been renamed "Sequence".

* The "Char" type has been renamed "UnicodeScalar".  The preferred
  unit of string fragments for users is called "Character".

* Initialization semantics for classes, structs and enums init methods are now
  properly diagnosed by the compiler.  Instance variables now follow the same
  initialization rules as local variables: they must be defined before use.  The
  initialization model requires that all properties with storage in the current
  class be initialized before super.init is called (or, in a root class, before 
  any method is called on self, and before the final return).

  For example, this will yield an error:
  
    class SomeClass : SomeBase {
      var x : Int
      
      init() {
        // error: property 'self.x' not initialized at super.init call
        super.init()
      }
    }
  
  A simple fix for this is to change the property definition to "var x = 0",
  or to explicitly assign to it before calling super.init().

* Relatedly, the compiler now diagnoses incorrect calls to super.init().  It
  validates that any path through an initializer calls super.init() exactly once,
  that all ivars are defined before the call to super.init, and that any uses 
  which require the entire object to be initialized come after the super.init 
  call.

* Type checker performance has improved considerably (but we still
  have much work to do here).

2013-12-04
----------

* The "slice" versus "array" subtlety is now dead. Slice<T> has been folded
  into Array<T> and T[] is just sugar for Array<T>.


2013-11-20
----------
* Unreachable code warning has been added:

    var y: Int = 1
    if y == 1 { // note: condition always evaluates to true
      return y
    } 
    return 1 // warning: will never be executed

* Overflows on integer type conversions are now detected at runtime and, when 
  dealing with constants, at compile time:

    var i: Int = -129
    var i8 = Int8(i) 
    // error: integer overflows when converted from 'Int' to 'Int8'

    var si = Int8(-1)
    var ui = UInt8(si) 
    // error: negative integer cannot be converted to unsigned type 'UInt8'

* 'def' keyword was changed back to 'func'.

2013-11-13
----------

* Objective-C-compatible protocols can now contain optional
  requirements, indicated by the @optional attribute:

    @class_protocol @objc protocol NSWobbling {
      @optional def wobble()
    }

  A class that conforms to the NSWobbling protocol above can (but does
  not have to) implement wobble. When referring to the 'wobble'
  method for a value of type NSWobbling (or a value of generic type
  that is bounded by NSWobbling), the result is an optional value
  indicating whether the underlying object actually responds to the
  given selector, using the same mechanism as messaging 'id'. One can
  use '!' to assume that the method is always there, '?' to chain the
  optional, or conditional branches to handle each case distinctly:

    def tryToWobble(w : NSWobbling) {
      w.wobble()   // error: cannot call a value of optional type
      w.wobble!()  // okay: calls -wobble, but fails at runtime if not there
      w.wobble?()  // okay: calls -wobble only if it's there, otherwise no-op
      if w.wobble {
        // okay: we know -wobble is there
      } else {
        // okay: we know -wobble is not there
      }
    }

* Enums from Cocoa that are declared with the NS_ENUM macro are now imported
  into Swift as Swift enums. Like all Swift enums, the constants of the Cocoa
  enum are scoped as members of the enum type, so the importer strips off the
  common prefix of all of the constant names in the enum when forming the Swift
  interface. For example, this Objective-C declaration:

    typedef NS_ENUM(NSInteger, NSComparisonResult) {
      NSOrderedAscending,
      NSOrderedSame,
      NSOrderedDescending,
    };

  shows up in Swift as:

    enum NSComparisonResult : Int {
      case Ascending, Same, Descending
    }

  The enum cases can then take advantage of type inference from context.
  In Objective-C, you would write:

    NSNumber *foo = [NSNumber numberWithInt: 1];
    NSNumber *bar = [NSNumber numberWithInt: 2];

    switch ([foo compare: bar]) {
    case NSOrderedAscending:
      NSLog(@"ascending\n");
      break;
    case NSOrderedSame:
      NSLog(@"same\n");
      break;
    case NSOrderedDescending:
      NSLog(@"descending\n");
      break;
    }

  In Swift, this becomes:

    var foo: NSNumber = 1
    var bar: NSNumber = 2

    switch foo.compare(bar) {
    case .Ascending:
      println("ascending")
    case .Same:
      println("same")
    case .Descending:
      println("descending")
    }

* Work has begun on implementing static properties. Currently they are supported
  for nongeneric structs and enums.

    struct Foo {
      static var foo: Int = 2
    }
    enum Bar {
      static var bar: Int = 3
    }
    println(Foo.foo)
    println(Bar.bar)

2013-11-06
----------

* 'func' keyword was changed to 'def'.

* Implicit conversions are now allowed from an optional type 'T?' to another
  optional type 'U?' if 'T' is implicitly convertible to 'U'. For example,
  optional subclasses convert to their optional base classes:

    class Base {}
    class Derived : Base {}

    var d: Derived? = Derived()
    var b: Base? = d

2013-10-30
----------

* Type inference for variables has been improved, allowing any
  variable to have its type inferred from its initializer, including
  global and instance variables:

    class MyClass {
      var size = 0 // inferred to Int
    }

    var name = "Swift"

  Additionally, the arguments of a generic type can also be inferred
  from the initializer:

    // infers Dictionary<String, Int>
    var dict: Dictionary = ["Hello": 1, "World": 2]


2013-10-23
----------

* Missing return statement from a non-Void function is diagnosed as an error.

* Vector<T> has been replaced with Array<T>. This is a complete rewrite to use
  value-semantics and copy-on-write behavior. The former means that you never
  need to defensively copy again (or remember to attribute a property as "copy")
  and the latter yields better performance than defensive copying. Dictionary<T>
  is next.

* 'switch' can now pattern-match into structs and classes, using the syntax
  'case Type(property1: pattern1, property2: pattern2, ...):'.
  
    struct Point { var x, y: Double }
    struct Size { var w, h: Double }
    struct Rect { var origin: Point; var size: Size }

    var square = Rect(Point(0, 0), Size(10, 10))

    switch square {
    case Rect(size: Size(w: var w, h: var h)) where w == h:
      println("square")
    case Rect(size: Size(w: var w, h: var h)) where w > h:
      println("long rectangle")
    default:
      println("tall rectangle")
    }
  
  Currently only stored properties ("ivars" in ObjC terminology) are
  supported by the implementation.

* Array and dictionary literals allow an optional trailing comma:

    var a = [ 1, 2, ]
    var d = [ "a": 1, "b": 2, ]

Release notes for older releases are available at 

