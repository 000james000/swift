2013-12-11
----------

* Objective-C 'id' is now imported as 'AnyObject' (formerly known as
  'DynamicLookup'), Objective-C 'Class' is imported as 'AnyClass'.

* The casting syntax "x as T" now permits both implicit conversions
  (in which case it produces a value of type T) and for
  runtime-checked casts (in which case it produces a value of type T?
  that will be .Some(casted x) on success and .None on failure). An
  example:

    func f(x: AnyObject, y: NSControl) {
      var view = y as NSView                  // has type 'NSView'
      var maybeView = x as NSView             // has type NSView?
    }

* The precedence levels of binary operators has been redefined, with a much 
  simpler model than C's.  This is with a goal to define away classes of bugs
  such as those caught by Clang's -Wparentheses warnings, and to make it 
  actually possible for normal humans to reason about the precedence 
  relationships without having to look them up.
  
  We ended up with 6 levels, from tightest binding to loosest:
    exponentiative: <<, >>
    multiplicative: *, /, %, &
    additive: +, -, |, ^
    comparative: ==, !=, <, <=, >=, >
    conjunctive: &&
    disjunctive: ||

* The "Enumerable" protocol has been renamed "Sequence".

* The "Char" type has been renamed "UnicodeScalar".  The preferred
  unit of string fragments for users is called "Character".

* Initialization semantics for classes, structs and enums init methods are now
  properly diagnosed by the compiler.  Instance variables now follow the same
  initialization rules as local variables: they must be defined before use.  The
  initialization model requires that all properties with storage in the current
  class be initialized before super.init is called (or, in a root class, before 
  any method is called on self, and before the final return).

  For example, this will yield an error:
  
    class SomeClass : SomeBase {
      var x : Int
      
      init() {
        // error: property 'self.x' not initialized at super.init call
        super.init()
      }
    }
  
  A simple fix for this is to change the property definition to "var x = 0",
  or to explicitly assign to it before calling super.init().

* Relatedly, the compiler now diagnoses incorrect calls to super.init().  It
  validates that any path through an initializer calls super.init() exactly once,
  that all ivars are defined before the call to super.init, and that any uses 
  which require the entire object to be initialized come after the super.init 
  call.

2013-12-04
----------

* The "slice" versus "array" subtlety is now dead. Slice<T> has been folded
  into Array<T> and T[] is just sugar for Array<T>.


2013-11-20
----------
* Unreachable code warning has been added:

    var y: Int = 1
    if y == 1 { // note: condition always evaluates to true
      return y
    } 
    return 1 // warning: will never be executed

* Overflows on integer type conversions are now detected at runtime and, when 
  dealing with constants, at compile time:

    var i: Int = -129
    var i8 = Int8(i) 
    // error: integer overflows when converted from 'Int' to 'Int8'

    var si = Int8(-1)
    var ui = UInt8(si) 
    // error: negative integer cannot be converted to unsigned type 'UInt8'

* 'def' keyword was changed back to 'func'.

2013-11-13
----------

* Objective-C-compatible protocols can now contain optional
  requirements, indicated by the @optional attribute:

    @class_protocol @objc protocol NSWobbling {
      @optional def wobble()
    }

  A class that conforms to the NSWobbling protocol above can (but does
  not have to) implement wobble. When referring to the 'wobble'
  method for a value of type NSWobbling (or a value of generic type
  that is bounded by NSWobbling), the result is an optional value
  indicating whether the underlying object actually responds to the
  given selector, using the same mechanism as messaging 'id'. One can
  use '!' to assume that the method is always there, '?' to chain the
  optional, or conditional branches to handle each case distinctly:

    def tryToWobble(w : NSWobbling) {
      w.wobble()   // error: cannot call a value of optional type
      w.wobble!()  // okay: calls -wobble, but fails at runtime if not there
      w.wobble?()  // okay: calls -wobble only if it's there, otherwise no-op
      if w.wobble {
        // okay: we know -wobble is there
      } else {
        // okay: we know -wobble is not there
      }
    }

* Enums from Cocoa that are declared with the NS_ENUM macro are now imported
  into Swift as Swift enums. Like all Swift enums, the constants of the Cocoa
  enum are scoped as members of the enum type, so the importer strips off the
  common prefix of all of the constant names in the enum when forming the Swift
  interface. For example, this Objective-C declaration:

    typedef NS_ENUM(NSInteger, NSComparisonResult) {
      NSOrderedAscending,
      NSOrderedSame,
      NSOrderedDescending,
    };

  shows up in Swift as:

    enum NSComparisonResult : Int {
      case Ascending, Same, Descending
    }

  The enum cases can then take advantage of type inference from context.
  In Objective-C, you would write:

    NSNumber *foo = [NSNumber numberWithInt: 1];
    NSNumber *bar = [NSNumber numberWithInt: 2];

    switch ([foo compare: bar]) {
    case NSOrderedAscending:
      NSLog(@"ascending\n");
      break;
    case NSOrderedSame:
      NSLog(@"same\n");
      break;
    case NSOrderedDescending:
      NSLog(@"descending\n");
      break;
    }

  In Swift, this becomes:

    var foo: NSNumber = 1
    var bar: NSNumber = 2

    switch foo.compare(bar) {
    case .Ascending:
      println("ascending")
    case .Same:
      println("same")
    case .Descending:
      println("descending")
    }

* Work has begun on implementing static properties. Currently they are supported
  for nongeneric structs and enums.

    struct Foo {
      static var foo: Int = 2
    }
    enum Bar {
      static var bar: Int = 3
    }
    println(Foo.foo)
    println(Bar.bar)

2013-11-06
----------

* 'func' keyword was changed to 'def'.

* Implicit conversions are now allowed from an optional type 'T?' to another
  optional type 'U?' if 'T' is implicitly convertible to 'U'. For example,
  optional subclasses convert to their optional base classes:

    class Base {}
    class Derived : Base {}

    var d: Derived? = Derived()
    var b: Base? = d

2013-10-30
----------

* Type inference for variables has been improved, allowing any
  variable to have its type inferred from its initializer, including
  global and instance variables:

    class MyClass {
      var size = 0 // inferred to Int
    }

    var name = "Swift"

  Additionally, the arguments of a generic type can also be inferred
  from the initializer:

    // infers Dictionary<String, Int>
    var dict: Dictionary = ["Hello": 1, "World": 2]


2013-10-23
----------

* Missing return statement from a non-Void function is diagnosed as an error.

* Vector<T> has been replaced with Array<T>. This is a complete rewrite to use
  value-semantics and copy-on-write behavior. The former means that you never
  need to defensively copy again (or remember to attribute a property as "copy")
  and the latter yields better performance than defensive copying. Dictionary<T>
  is next.

* 'switch' can now pattern-match into structs and classes, using the syntax
  'case Type(property1: pattern1, property2: pattern2, ...):'.
  
    struct Point { var x, y: Double }
    struct Size { var w, h: Double }
    struct Rect { var origin: Point; var size: Size }

    var square = Rect(Point(0, 0), Size(10, 10))

    switch square {
    case Rect(size: Size(w: var w, h: var h)) where w == h:
      println("square")
    case Rect(size: Size(w: var w, h: var h)) where w > h:
      println("long rectangle")
    default:
      println("tall rectangle")
    }
  
  Currently only stored properties ("ivars" in ObjC terminology) are
  supported by the implementation.

* Array and dictionary literals allow an optional trailing comma:

    var a = [ 1, 2, ]
    var d = [ "a": 1, "b": 2, ]

Release notes for older releases are available at 

