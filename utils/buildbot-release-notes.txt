Latest
----------

* Swift now supports a #elseif form for build configurations, e.g.:

    #if os(OSX)
      typealias SKColor = NSColor
    #elseif os(iOS)
      typealias SKColor = UIColor
    #else
      typealias SKColor = Green
    #endif

* You can now use the "true" and "false" constants in build configurations,
  allowing you to emulate the C idioms of "#if 0" (but spelled "#if false").

* 'break' now breaks out of switch statements.

* It is no longer possible to specify "@mutating" as an attribute, you may only
  use it as a keyword, e.g.:
  
    struct Pair {
      var x, y : Int
      mutating func nuke() { x = 0; y = 0 }
    }
  
  The former "@!mutating" syntax used to mark setters as non-mutating is now
  spelled with the "nonmutating" keyword.  Both mutating and nonmutating are
  context sensitive keywords.

* NSLog is now available from Swift code.

* 'Character' is the new character literal type:

    var x = 'a' // Infers 'Character' type

  You can force inference of UnicodeScalar like this:

    var scalar: UnicodeScalar = 'a'

  'Character' type represents a Unicode default grapheme cluster (to put it
  simply, a grapheme cluster is what users think of as a character: a base plus
  any combining marks, or other cases explained in Unicode Standard Annex #29).

2014-04-22
----------

* Loops and switch statements can now carry labels, and you can break/continue
  to those labels.  These use conventional C-style label syntax, and should be
  dedented relative to the code they are in.  An example:
  
    func breakContinue(x : Int) -> Int {
    Outer:
      for a in 0..1000 {

      Switch:
        switch x {
        case 42: break Outer
        case 97: continue Outer
        case 102: break Switch
        case 13: continue // continue always works on loops.
        case 139: break   // break will break out of the switch (but see below)
        }
      }
    }

* We are changing the behavior of 'break' to provide C-style semantics, to allow
  breaking out of a switch statement.  Previously, break completely ignored
  switches so that it would break out of the nearest loop. In the example above,
  'case 139' would break out of the "Outer" loop, not the "Switch".
  
  In order to avoid breaking existing code, we're making this a compile time
  error instead of a silent behavior change.  If you need a solution for the
  previous behavior, use labeled break.
  
  This error will be removed in a week or two.

* Cocoa methods and properties that are annotated with the
  NS_RETURNS_INNER_POINTER attribute, including -[NSData bytes] and
  -[{NS,UI}Color CGColor], are now safe to use and follow the same lifetime
  extension semantics as ARC.

2014-04-18
----------
* Enabling/disabling of asserts

  assert(condition, msg)

  is enabled/disabled dependent on the optimization level. In debug mode at
  "-O0" asserts are enabled. At higher optimization levels asserts are disabled
  and no code is generated for them. However, asserts are always type checked
  even at higher optimization levels.

  Alternatively, assertions can be disabled/enabled by using the frontend flag
  "-AssertConfig=Debug", or "-AssertConfig=Release".

* Added optimization flag "-Ofast". It disables all assertions (assert), and
  runtime overflow and type checks.

* The "selector-style" function and initializer declaration syntax is
  being phased out. For example, this:

    init withRed(red: CGFloat) green(CGFloat) blue(CGFloat) alpha(CGFloat)

  will now be written as:

    init(withRed red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)

  For each parameter, one can have both an argument API name (i.e.,
  "withRed", which comes first and is used at the call site) and an
  internal parameter name that follows it (i.e. "red", which comes
  second and is used in the implementation). When the two names are
  the same, one can simply write the name once and it will be used for
  both roles (as with "green", "blue", and "alpha" above). The
  underscore ("_") can be used to mean "no name", as when the
  following function/method:

    func murderInRoom(room:String) withWeapon(weapon: String)

  is translated to:

    func murderInRoom(_ room: String, withWeapon weapon: String)

  The compiler now complains when it sees the selector-style syntax
  and will provide Fix-Its to rewrite to the newer syntax.

  Note that the final form of selector syntax is still being hammered
  out, but only having one declaration syntax, which will be very
  close to this, is a known.

* Stored properties can now be marked with the @NSCopying attribute, which
  causes their setter to be synthesized with a copy to copyWithZone:.  This may
  only be used with types that conform to the NSCopying protocol, or option
  types thereof.  For example:
  
    @NSCopying var myURL : NSURL

  This fills the same niche as the (copy) attribute on Objective-C properties.


2014-04-16
----------

* Optional variables and properties are now default-initialized to nil:

    class MyClass {
      var cachedTitle: String?       // "= nil" is implied
    }

* @IBOutlet has been improved in a few ways:

  - IBOutlets can now be @unchecked optional.

  - An IBOutlet declared as non-optional, i.e.,

      @IBOutlet var button: NSButton

    will be treated as an @unchecked optional.  This is considered to
    be the best practice way to write an outlet, unless you want to explicitly
    handle the null case - in which case, use "NSButton?" as the type. Either 
    way, the "= nil" that was formerly required is now implicit.

* The precedence of 'is' and 'as' is now higher than comparisons, allowing the
  following sorts of things to be written without parens:

    if x is NSButton && y is NSButtonCell { ... }

    if 3/4 as Float == 6/8 as Float { ... }

* Objective-C blocks are now transparently bridged to Swift closures. You never
  have to write @objc_block when writing Objective-C-compatible methods anymore.
  Block parameters are now imported as unchecked optional closure types,
  allowing 'nil' to be passed.

2014-04-09
----------

* Dictionary changes:

  - Elements are now tuples, so you can write

    for (k, v) in d {
      // ...
    }

  - "keys" and "values" properties, which are Collections projecting
    the corresponding aspect of each element.  Dictionary indices are
    usable with their keys and values properties, so:

    for i in indices(d) {
      let (k, v) = d[i]
      assert(k == d.keys[i])
      assert(v == d.values[i])
    }

* Semicolon can be used as a single no-op statement in otherwise empty cases in
  switch statements:

  switch x {
  case 1, 2, 3:
    print("x is 1, 2 or 3")
  default:
    ;
  }

* 'override' is now a context sensitive keyword, instead of an attribute:

  class Base {
    var property: Int { return 0 }
    func instanceFunc() {}
    class func classFunc() {}
  }
  class Derived : Base {
    override var property: Int { return 1 }
    override func instanceFunc() {}
    override class func classFunc() {}
  }

2014-04-02
----------

* Prefix splitting for imported enums has been revised again due to feedback:
  - If stripping off a prefix would leave an invalid identifier (like "10_4"),
    leave one more word in the result than would otherwise be there
    ("Behavior10_4").
  - If all enumerators have a 'k' prefix (for "constant") and the enum doesn't,
    the 'k' should not be considered when finding the common prefix.
  - If the enum name is a plural (like "NSSomethingOptions") and the enumerator
    names use the singular form ("NSSomethingOptionMagic"), this is considered
    a matching prefix (but only if nothing follows the plural).

* Cocoa APIs that take pointers to plain C types as arguments now get imported
  as taking the new 'CMutablePointer<T>' and 'CConstPointer<T>' types instead
  of 'UnsafePointer<T>'. These new types allow implicit conversions from
  Swift 'inout' parameters and from Swift arrays:

    let rgb = CGColorSpaceCreateDeviceRGB()
    // CGColorRef CGColorCreate(CGColorSpaceRef, const CGFloat*);
    let white = CGColorCreate(rgb, [1.0, 1.0, 1.0])

    var s = 0.0, c = 0.0
    // void sincos(double, double*, double*);
    sincos(M_PI/2, &s, &c)

  Pointers to pointers to ObjC classes, such as 'NSError**', get imported as
  'ObjCMutablePointer<NSError?>'. This type doesn't work with arrays, but
  accepts inouts or 'nil':

    var error: NSError? = nil
    let words = NSString.stringWithContentsOfFile("/usr/share/dict/words",
      encoding: .UTF8StringEncoding,
      error: &error)

  Void pointer parameters can be passed an array or inout of any type:

    // + (NSData*)dataWithBytes:(const void*)bytes length:(NSUInteger)length;
    let data = NSData.dataWithBytes([1.5, 2.25, 3.125],
                                    length: sizeof(Double.self) * 3)
    var fromData = [0.0, 0.0, 0.0]
    // - (void)getBytes:(void*)bytes length:(NSUInteger)length;
    data.getBytes(&fromData, length: sizeof(Double.self) * 3)

  Note that we don't know whether an API reads or writes the C pointer, so
  you need to explicitly initialize values (like "s" and "c" above) even if
  you know that the API overwrites them.

  This pointer bridging only applies to arguments, and only works with well-
  behaved C and ObjC APIs that don't keep the pointers they receive as
  arguments around or do other dirty pointer tricks. Nonstandard use of pointer
  arguments still requires UnsafePointer.

* Objective-C pointer types now get imported by default as the '@unchecked T?'
  optional type.  Swift class types no longer implicitly include 'nil'.

  A value of '@unchecked T?' can be implicitly used as a value of 'T'.
  Swift will implicitly cause a reliable failure if the value is 'nil',
  rather than introducing undefined behavior (as in Objective-C ivar
  accesses or everything in C/C++) or silently ignoring the operation
  (as in Objective-C message sends).

  A value of '@unchecked T?' can also be implicitly used as a value of 'T?',
  allowing you explicitly handle the case of a 'nil' value.  For example,
  if you would like to just silently ignore a message send a la Objective-C,
  you can use the postfix '?' operator like so:

    fieldsForKeys[kHeroFieldKey]?.setEditable(true)
  
  This design allows you to isolate and handle 'nil' values in Swift code
  without requiring excessive "bookkeeping" boilerplate to use values that
  you expect to be non-nil.

  For now, we will continue to import C pointers as non-optional
  UnsafePointer and C*Pointer types; that will be evaluated separately.

  We intend to provide attributes for Clang to allow APIs to opt in to
  importing specific parameters, return types, etc. as either the
  explicit optional type 'T?' or the simple non-optional type 'T'.

* The "separated" call syntax, i.e.,

    NSColor.colorWithRed(r) green(g) blue(b) alpha(a)
    UIColor.init withRed(r) green(g) blue(b) alpha(a)

  is being removed. The compiler will now produce an error and provide
  Fix-Its to rewrite calls to the "keyword-argument" syntax:

    NSColor.colorWithRed(r, green: g, blue: b, alpha: a)
    UIColor(withRed: r, green:g, blue:b, alpha: a)

* The 'objc' attribute now optionally accepts a name, which can be
  used to provide the name for an entity as seen in Objective-C. For
  example:

    class MyType {
      var enabled: Bool {
        @objc(isEnabled) get {
          // ...
        }
      }
    }

  The @objc attribute can be used to name initializers, methods,
  getters, setters, classes, and protocols.

* Methods, properties and subscripts in classes can now be marked with the
  @final attribute.  This attribute prevents overriding the declaration in any
  subclass, and provides better performance (since dynamic dispatch is avoided
  in many cases).


2014-03-26
----------

* Attributes on declarations are no longer comma separated.

  Old syntax:
  
    @asmname("foo"), @objc func bar() {}

  New syntax:

    @asmname("foo") @objc
    

  The ',' was vestigial when the attribute syntax consisted of bracked lists.

* 'switch' now always requires a statement after a 'case' or 'default'.

  Old syntax:

    switch x {
    case .A:
    case .B(1):
      println(".A or .B(1)")
    default:
      // Ignore it.
    }

  New syntax:

    switch x {
    case .A, .B(1):
      println(".A or .B(1)")
    default:
      () // Ignore it.
    }

  The following syntax can be used to introduce guard expressions for patterns
  inside the 'case':

  switch x {
  case .A where isFoo(),
       .B(1) where isBar():
    ...
  }
  
* Observing properties can now @override properties in a base class, so you can
  observe changes that happen to them.

     class MyAwesomeView : SomeBasicView {
      @override
      var enabled : Bool {
        didSet {
          println("Something changed")
        }
      }
      ...
    }
    
  Observing properties still invoke the base class getter/setter (or storage)
  when accessed.


* An 'as' cast can now be forced using the postfix '!' operator without using
  parens:

    class B {}
    class D {}

    let b: B = D()

    // Before
    let d1: D = (b as D)!
    // After
    let d2: D = b as D!

  Casts can also be chained without parens:

    // Before
    let b2: B = (((D() as B) as D)!) as B
    // After
    let b3: B = D() as B as D! as B

* 'as' can now be used in 'switch' cases to match the result of a checked cast:

    func printHand(hand: Any) {
      switch hand {
      case 1 as Int:
        print("ace")
      case 11 as Int:
        print("jack")
      case 12 as Int:
        print("queen")
      case 13 as Int:
        print("king")
      case let numberCard as Int:
        print("\(numberCard)")
      case let (a, b) as (Int, Int) where a == b:
        print("two ")
        printHand(a)
        print("s")
      case let (a, b) as (Int, Int):
        printHand(a)
        print(" and a ")
        printHand(b)
      case let (a, b, c) as (Int, Int, Int) where a == b && b == c:
        print("three ")
        printHand(a)
        print("s")
      case let (a, b, c) as (Int, Int, Int):
        printHand(a)
        print(", ")
        printHand(b)
        print(", and a ")
        printHand(c)
      default:
        print("unknown hand")
      }
    }
    printHand(1, 1, 1) // prints "three aces"
    printHand(12, 13) // prints "queen and a king"

* Enums and option sets imported from C/Objective-C still strip common
  prefixes, but the name of the enum itself is now taken into consideration as
  well. This keeps us from dropping important parts of a name that happen to be
  shared by all members.

  // NSFileManager.h
  typedef NS_OPTIONS(NSUInteger, NSDirectoryEnumerationOptions) {
      NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1UL << 0,
      NSDirectoryEnumerationSkipsPackageDescendants      = 1UL << 1,
      NSDirectoryEnumerationSkipsHiddenFiles             = 1UL << 2
  } NS_ENUM_AVAILABLE(10_6, 4_0);

  // Swift
  let opts: NSDirectoryEnumerationOptions = .SkipsPackageDescendants

* Init methods in Objective-C protocols are now imported as
  initializers. To conform to NSCoding, you will now need to provide

    init withCoder(aDecoder: NSCoder) { ... }

  rather than

    func initWithCoder(aDecoder: NSCoder) { ... }


2014-03-19
----------

* When a class provides no initializers of its own but has default
  values for all of its stored properties, it will automatically
  inherit all of the initializers of its superclass. For example:

    class Document {
      var title: String

      init() -> Self {
        self.init(withTitle: "Default title")
      }

      init withTitle(title: String) { 
        self.title = title
      }
    }

    class VersionedDocument : Document {
      var version = 0

      // inherits 'init' and 'init withTitle:' from Document
    }

  When one does provide a designated initializer in a subclass, as in
  the following example:

    class SecureDocument : Document {
      var key: CryptoKey

      init withKey(key: CryptoKey) -> Self {
        self.init(withKey: key, title: "Default title")        
      }

      init withKey(key: CryptoKey) title(String) {
        self.key = key
        super.init(withTitle: title)        
      }
    }

  the compiler emits Objective-C method stubs for all of the
  designated initializers of the parent class that will abort at
  runtime if called, and which indicate which initializer needs to be
  implemented. This provides memory safety for cases where an
  Objective-C initializer (such as -[Document init] in this example)
  appears to be inherited, but isn't actually implemented. 

* 'nil' may now be used as a Selector value. This allows calls to  Cocoa methods that accept `nil` selectors.

* [] and [:] can now be used as the empty array and dictionary literal,
  respectively.  Because these carry no information about their element types,
  they may only be used in a context that provides this information through type
  inference (e.g. when passing a function argument).

* Properties defined in classes are now dynamically dispatched and can be 
  overriden with @override.  Currently @override only works with computed properties
  overriding other computed properties, but this will be enhanced in coming weeks.
  

2014-03-12
----------

* The 'didSet' accessor of an observing property now gets passed in the old value,
  so you can easily implement an action for when a property changes value.  For
  example:

     class MyAwesomeView : UIView {
      var enabled : Bool = false {
      didSet(oldValue): 
        if oldValue != enabled {
          self.needsDisplay = true
        }
      }
      ...
    }

* The implicit argument name for set and willSet property specifiers has been 
  renamed from "(value)" to "(newValue)".  For example:

    var i : Int {
      get {
        return 42
      }
      set {  // defaults to (newValue) instead of (value)
        print(newValue)
      }
    }

* The magic identifier __FUNCTION__ can now be used to get the name of the
  current function as a string. Like __FILE__ and __LINE__, if __FUNCTION__
  is used as a default argument, the function name of the caller is passed as
  the argument.

    func malkovich() {
      println(__FUNCTION__)
    }
    malkovich() // prints "malkovich"

    func nameCaller(name: String = __FUNCTION__) -> String {
      return name
    }

    func foo() {
      println(nameCaller()) // prints "foo"
    }

    func foo(x: Int) bar(y: Int) {
      println(nameCaller()) // prints "foo:bar:"
    }

  At top level, __FUNCTION__ gives the module name:

    println(nameCaller()) // prints your module name

* Selector-style methods can now be referenced without applying arguments
  using member syntax "foo.bar:bas:", for instance, to test for the availability
  of an optional protocol method:

    func getFrameOfObjectValueForColumn(ds: NSTableViewDataSource,
                                        tableView: NSTableView,
                                        column: NSTableColumn,
                                        row: Int) -> AnyObject? {
      if let getObjectValue = ds.tableView:objectValueForTableColumn:row: {
        return getObjectValue(tableView, column, row)
      }
      return nil
    }

 * The compiler now warns about cases where a variable is inferred to have
   AnyObject, AnyClass, or "()" type, since type inferrence can turn a simple 
   mistake (e.g. failing to cast an AnyObject when you meant to) into something 
   with ripple effects.  Here is a simple example:

    t.swift:4:5: warning: variable 'fn' inferred to have type '()', which may be unexpected
    var fn = abort()
        ^
    t.swift:4:5: note: add an explicit type annotation to silence this warning
    var fn = abort()
        ^
          : ()
 
   If you actually did intend to declare a variable of one of these types, you
   can silence this warning by adding an explicit type (indicated by the Fixit).
   See rdar://15263687 and rdar://16252090 for more rationale.

* 'x.type' has been renamed to 'x.dynamicType', and you can use 'type' as a
  regular identifier again.

2014-03-05
----------

* C macros that expand to a single constant string are now imported as global
  constants. Normal string literals are imported as CString; NSString literals
  are imported as String.

* All values now have a 'self' property, exactly equivalent to the value
  itself:

    let x = 0
    let x2 = x.self

  Types also have a 'self' property that is the type object for that
  type:

    let theClass = NSObject.self
    let theObj = theClass()

  References to type names are now disallowed outside of a constructor call
  or member reference; to get a type object as a value, "T.self" is required.
  This prevents the mistake of intending to construct an instance of a
  class but forgetting the parens and ending up with the class object instead:

    let x = MyObject // oops, I meant MyObject()...
    return x.description() // ...and I accidentally called +description
                           //    instead of -description

* Initializers are now classified as "designated initializers", which
  are responsible for initializing the current class object and
  chaining via 'super.init', and "convenience initializers", which
  delegate to another initializer and can be inherited. For example:

    class A {
      var str: String

      init() -> Self { // convenience initializer
        self.init(withString: "hello")
      }

      init withString(str: String) { // designated initializer
        self.str = str
      }
    }

  When a subclass overrides all of its superclass's designated
  initializers, the convenience initializers are inherited:

    class B {
      init withString(str: String) { // designated initializer
        super.init(withString: str)
      }

      // inherits A.init()
    }

  Objective-C classes that provide NS_DESIGNATED_INITIALIZER
  annotations will have their init methods mapped to designated
  initializers or convenience initializers as appropriate; Objective-C
  classes without NS_DESIGNATED_INITIALIZER annotations have all of
  their init methods imported as designated initializers, which is
  safe (but can be verbose for subclasses). Note that the syntax and
  terminology is still somewhat in flux.

* Initializers can now be marked as 'required' with an attribute,
  meaning that every subclass is required to provide that initializer
  either directly or by inheriting it from a superclass. To construct

    class View {
      @required init withFrame(frame: CGRect) { ... }
    }

    func buildView(subclassObj: View.Type, frame: CGRect) -> View {
      return subclassObj(withFrame: frame)
    }

    class MyView : View {
      @required init withFrame(frame: CGRect) { 
        super.init(withFrame: frame)
      }
    } 

    class MyOtherView : View {
      // error: must override init withFrame(CGRect).
    }

* Properties in Objective-C protocols are now correctly imported as properties.
  (Previously the getter and setter were imported as methods.)

* Simple enums with no payloads, including NS_ENUMs imported
  from Cocoa, now implicitly conform to the Equatable and Hashable protocols.
  This means they can be compared with the '==' and '!=' operators and can
  be used as Dictionary keys:

    enum Flavor {
      case Lemon, Banana, Cherry
    }

    assert(Flavor.Lemon == .Lemon)
    assert(Flavor.Banana != .Lemon)

    struct Profile {
      var sweet, sour: Bool
    }

    let flavorProfiles: Dictionary<Flavor, Profile> = [
      .Lemon:  Profile(sweet: false, sour: true ),
      .Banana: Profile(sweet: true,  sour: false),
      .Cherry: Profile(sweet: true,  sour: true ),
    ]
    assert(flavorProfiles[.Lemon].sour)

* 'val' has been removed.  Long live 'let'!

* Values whose names clash with Swift keywords, such as Cocoa methods or
  properties named "class", "protocol", "type", etc., can now be defined and
  accessed by wrapping reserved keywords in backticks to suppress their builtin
  meaning:

    let `class` = 0
    let `type` = 1
    let `protocol` = 2
    println(`class`)
    println(`type`)
    println(`protocol`)

    func foo(Int) `class`(Int) {}
    foo(0, `class`: 1)

2014-02-26
----------

* The 'override' attribute is now required when overriding a method,
  property, or subscript from a superclass. For example:

    class A {
      func foo() { }
    }

    class B : A {
      @override func foo() { } // 'override' is required here
    }

* We're renaming 'val' back to 'let'.  The compiler accepts both for this week,
  next week it will just accept 'let'.  Please migrate your code this week, sorry
  for the back and forth on this.

* Swift now supports "#if", "#else" and "#endif" blocks, along with target 
  configuration expressions, to allow for conditional compilation within
  declaration and statement contexts.

  Target configurations represent certain static information about the
  compile-time build environment.  They are implicit, hard-wired into the
  compiler, and can only be referenced within the conditional expression of an
  "#if" block.

  Target configurations are tested against their values via a pseudo-function
  invocation expression, taking a single argument expressed as an identitifer.
  The argument represents certain static build-time information.

  There are currently two supported target configurations:
    "os", which can have the values OSX or iOS
    "arch", which can have the values i386, x86_64, arm and arm64

  Within the context of an "#if" block's conditional expression, a target
  configuration expression can evaluate to either 'true' or 'false'.

  For example:

    #if arch(x86_64)
      println("Building for x86_64") 
    #else
      println("Not building for x86_64")
    #endif

    class C {
    #if os(OSX)
      func foo() {
        // OSX stuff goes here
      }
    #else
      func foo() {
        // non-OSX stuff goes here
      }
    #endif
    } 

  The conditional expression of an "#if" block can be composed of one or more of
  the following expression types:
    - A unary expression, using '!'
    - A binary expression, using '&&' or '||'
    - A parenthesized expression
    - A target configuration expression

  For example:

    #if os(iOS) && !arch(I386)
    ...
    #endif

  Note that #if/#else/#endif blocks do not constitute a preprocessor, and must
  form valid and complete expressions or statements. Hence, the following
  produces a parser error:

    class C {

    #if os(iOS)
      func foo() {}
    }
    #else
      func bar() {}
      func baz() {}
    }
    #endif

  Also note that "active" code will be parsed, typechecked and emitted, while
  "inactive" code will only be parsed.  This is why code in an inactive #if or 
  #else block will produce parser errors for malformed code.  This allows the
  compiler to detect basic errors in inactive regions.

  This is the first step to getting functionality parity with the important
  subset of the C preprocessor.  Further refinements are planned for later.

* Swift now has both fully-closed ranges, which include their endpoint, and
  half-open ranges, which don't.

    (swift) for x in 0...5 { print(x) } ; print('\n') // half-open range
    01234
    (swift) for x in 0..5 { print(x) } ; print('\n')  // fully-closed range
    012345

* Property accessors have a new brace-based syntax, instead of using the former
  "label like" syntax.  The new syntax is:

  var computedProperty: Int {
    get {
      return _storage
    }
    set {
      _storage = value
    }
  }

  var implicitGet: Int {    // This form still works.
    return 42
  }

  var storedPropertyWithObservingAccessors: Int = 0 {
    willSet { ... }
    didSet { ... }
  }

* Properties and subscripts now work in protocols, allowing you to do things
  like:

    protocol Subscriptable {
      subscript(idx1: Int, idx2: Int) -> Int { get set }
      var prop: Int { get }
    }

    func foo(s: Subscriptable) {
      return s.prop + s[42, 19]
    }

  These can be used for generic algorithms now as well.

* The syntax for referring to the type of a type, 'T.metatype', has been
  changed to 'T.Type'. The syntax for getting the type of a value, 'typeof(x)',
  has been changed to 'x.type'.

* 'DynamicSelf' is now called 'Self'; the semantics are unchanged.

* 'destructor' has been replaced with 'deinit', to emphasize that it
  is related to 'init'. We will refer to these as
  'deinitializers'. We've also dropped the parentheses, i.e.:

    class MyClass {
      deinit {
        // release any resources we might have acquired, etc.
      }
    }

* Class methods defined within extensions of Objective-C classes can
  now refer to 'self', including using 'instancetype' methods. As a
  result, NSMutableString, NSMutableArray, and NSMutableDictionary
  objects can now be created with their respective literals, i.e.,

    var dict: NSMutableDictionary = ["a" : 1, "b" : 2]


2014-02-19
----------

* The "Stream" protocol has been renamed back to "Generator," which is
  precedented in other languages and causes less confusion with I/O
  streaming.

* The "type" keyword was split into two: "static" and "class".  One can define
  static functions and static properties in structs and enums like this:

    struct S {
      static func foo() {}
      static var bar: Int = 0
    }
    enum E {
      static func foo() {}
    }

  "class" keyword allows one to define class properties and class methods in
  classes and protocols:

    class C {
      class func foo() {}
      class var bar: Int = 0
    }
    protocol P {
      class func foo() {}
      class var bar: Int = 0
    }

  When using "class" and "static" in the extension, the choice of keyword
  depends on the type being extended:

    extension S {
      static func baz() {}
    }
    extension C {
      class func baz() {}
    }

* The 'let' keyword is no longer recognized.  Please move to 'val'.

* The standard library has been renamed to 'Swift' (instead of 'swift') to be
  more consistent with other modules on our platforms.

* 'NSInteger' and other types that are layout-compatible with Swift standard
  library types are now imported directly as those standard library types.

* Optional types now support a convenience method named "cache" to cache the
  result of a closure. For example:

  class Foo {
    var _lazyProperty: Int?
    var property: Int {
      return _lazyProperty.cache { computeLazyProperty() }
    }
  }

2014-02-12
----------

* We are experimenting with a new message send syntax. For example:

    SKAction.colorizeWithColor(SKColor.whiteColor()) colorBlendFactor(1.0) duration(0.0)

  When the message send is too long to fit on a single line, subsequent lines 
  must be indented from the start of the statement or declaration. For
  example, this is a single message send:

    SKAction.colorizeWithColor(SKColor.whiteColor()) 
             colorBlendFactor(1.0) 
             duration(0.0)

  while this is a message send to colorizeWithColor: followed by calls
  to 'colorBlendFactor' and 'duration' (on self or to a global function):

    SKAction.colorizeWithColor(SKColor.whiteColor()) 
    colorBlendFactor(1.0) // call to 'colorBlendFactor'
    duration(0.0) // call to 'duration'

* We are renaming the 'let' keyword to 'val'.  The 'let' keyword didn't work
  out primarily because it is not a noun, so "defining a let" never sounded 
  right.  We chose 'val' over 'const' and other options because 'var' and 'val
  have similar semantics (making syntactic similarity useful), because 'const' 
  has varied and sordid connotations in C that we don't want to bring over, and 
  because we don't want to punish the "preferred" case with a longer keyword.

  For migration purposes, the compiler now accepts 'let' and 'val' as synonyms,
  'let' will be removed next week.

* Selector arguments in function arguments with only a type are now implicitly
  named after the selector chunk that contains them.  For example, instead of:
  
    func addIntsWithFirst(first : Int) second(second : Int) -> Int {
      return first+second
    }
  
  you can now write:
  
    func addIntsWithFirst(first : Int) second(Int) -> Int {
      return first+second
    }
    
  if you want to explicitly want to ignore an argument, it is recommended that
  you continue to use the "_" to discard it, as in:
  
    func addIntsWithFirst(first : Int) second(_ : Int) -> Int {...}

* The @inout attribute in argument lists has been promoted to a 
  context-sensitive keyword.  Where before you might have written:

    func swap<T>(a : @inout T, b : @inout T) {
      (a,b) = (b,a)
    }

  You are now required to write:
    func swap<T>(inout a : T, inout b : T) {
      (a,b) = (b,a)
    }

  We made this change because "inout" is a fundamental part of the type
  system, which attributes are a poor match for.  The inout keyword is
  also orthogonal to the var and let keywords (which may be specified in
  the same place), so it fits naturally there.

* The "@mutating" attribute (which can be used on functions in structs,
  enums, and protocols) has been promoted to a context-sensitive keyword.
  Mutating struct methods are now written as:
    struct SomeStruct {
      mutating func f() {}
    }

* Half-open ranges (those that don't include their endpoint) are now
  spelled with three '.'s instead of two, for consistency with Ruby.

    (swift) for x in 0...5 { print(x) } ; print('\n') // new syntax
    01234
  
  Next week, we'll introduce a fully-closed range which does include 
  its endpoint.  This will provide:

    (swift) for x in 0..5 { print(x) } ; print('\n')  // coming soon
    012345
  
  These changes are being released separately so that users have a
  chance to update their code before its semantics changes.

* Objective-C properties with custom getters/setters are now imported
  into Swift as properties. For example, the Objective-C property

    @property (getter=isEnabled) BOOL enabled;

  was previously imported as getter (isEnabled) and setter
  (setEnabled) methods. Now, it is imported as a property (enabled).

* didSet/willSet properties may now have an initial value specified:

     class MyAwesomeView : UIView {
      var enabled : Bool = false {       // Initial value.
      didSet: self.needsDisplay = true
      }
      ...
    }

  they can also be used as non-member properties now, e.g. as a global
  variable or a local variable in a function.

* Objective-C instancetype methods are now imported as methods that
  return Swift's "DynamicSelf" type. While DynamicSelf is not
  generally useful for defining methods in Swift, importing to it
  eliminates the need for casting with the numerous instancetype APIs,
  e.g.,

    let tileNode: SKSpriteNode = SKSpriteNode.spriteNodeWithTexture(tileAtlas.textureNamed("tile\(tileNumber).png"))!

  becomes

    let tileNode = SKSpriteNode.spriteNodeWithTexture(tileAtlas.textureNamed("tile\(tileNumber).png"))

  DynamicSelf will become more interesting in the coming weeks.

2014-02-05
----------

* 'if' and 'while' statements can now conditionally bind variables. If the
  condition of an 'if' or 'while' statement is a 'let' declaration, then the
  right-hand expression is evaluated as an Optional value, and control flow
  proceeds by considering the binding to be true if the Optional contains a
  value, or false if it is empty, and the variables are available in the true
  branch. This allows for elegant testing of dynamic types, methods, nullable
  pointers, and other Optional things:

    class B : NSObject {}
    class D : B {
      func foo() { println("we have a D") }
    }
    var b: B = D()
    if let d = b as D {
      d.foo()
    }
    var id: AnyObject = D()
    if let foo = id.foo {
      foo()
    }

* When referring to a member of an 'AnyObject' (or 'AnyClass') object
  and using it directly (such as calling it, subscripting, or
  accessing a property on it), one no longer has to write the '?' or
  '!'. The run-time check will be performed implicitly. For example:

    func doSomethingOnViews(views: NSArray) {
      for view in views {
          view.updateLayer() // no '!' needed
      }
    }

  Note that one can still test whether the member is available at
  runtime using '?', testing the optional result, or conditionally
  binding a variable to the resulting member.

* The "swift" command line tool can now create executables and libraries
  directly, just like Clang. Use "swift main.swift" to create an executable and
  "swift -emit-library -o foo.dylib foo.swift" to create a library.

* Object files emitted by Swift are not debuggable on their own, even if you
  compiled them with the "-g" option. This was already true if you had multiple
  files in your project. To produce a debuggable Swift binary from the command
  line, you must compile and link in a single step with "swift", or pass object
  files AND swiftmodule files back into "swift" after compilation.
  (Or use Xcode.)

* 'import' will no longer import other source files, only built modules.

* The current directory is no longer implicitly an import path. Use "-I ." if
  you have modules in your current directory.


2014-01-29
----------

* Properties in structs and classes may now have "willSet:" and "didSet:"
  observing accessors defined on them:

  For example, where before you may have written something like this in a class:
  
    class MyAwesomeView : UIView {
      var _enabled : Bool  // storage
      var enabled : Bool { // computed property
      get:
        return _enabled
      set: 
        _enabled = value
        self.needDisplay = true
      }
      ...
    }

  you can now simply write:

    class MyAwesomeView : UIView {
      var enabled : Bool {  // Has storage & observing methods
      didSet: self.needDisplay = true
      }
      ...
    }

  Similarly, if you want notification before the value is stored, you can use
  willSet, which gets the incoming value before it is stored:
  
    var x : Int {
    willSet(value):  // value is the default and may be elided, as with set:
      println("changing from \(x) to \(value)")
    didSet:
      println("we've got a value of \(x) now.\n")
    }
    
  The willSet/didSet observers are triggered on any store to the property,
  except stores from init(), destructors, or from within the observers
  themselves.
    
  Overall, a property now may either be "stored" (the default), "computed" 
  (have a get: and optionally a set: specifier), or a observed 
  (willSet/didSet) property.  It is not possible to have a custom getter 
  or setter on a observed property, since they have storage.

  Two known-missing bits are:
   <rdar://problem/15920332> didSet/willSet variables need to allow initializers
   <rdar://problem/15922884> support non-member didset/willset properties
   
  Because of the first one, for now, you need to explicitly store an initial
  value to the property in your init() method.

* Objective-C properties with custom getter or setter names are (temporarily)
  not imported into Swift; the getter and setter will be imported individually
  as methods instead. Previously, they would appear as properties within the
  Objective-C class, but attempting to use the accessor with the customized
  name would result in a crash.

  The long-term fix is tracked as <rdar://problem/15877160>.

* Computed 'type' properties (that is, properties of types, rather
  than of values of the type) are now permitted on classes, on generic
  structs and enums, and in extensions.  Stored 'type' properties in
  these contexts remain unimplemented.

  The implementation of stored 'type' properties is tracked as
  <rdar://problem/15915785> (for classes) and <rdar://problem/15915867>
  (for generic types).

* The following command-line flags have been deprecated in favor of new
  spellings. The old spellings will be removed in the following week's build:

  -emit-llvm              ->  -emit-ir
  -triple                 ->  -target
  -serialize-diagnostics  ->  -serialize-diagnostics-path

* Imported NS_OPTIONS types now have a default initializer which produces a
  value with no options set. They can also be initialized to the empty set with
  'nil'. These are equivalent:

    var x = NSMatchingOptions()
    var y: NSMatchingOptions = nil


Release notes for older releases are available at

