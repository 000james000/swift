2013-09-24
----------

* The 'union' keyword has been replaced with 'enum'.  Unions and enums
  are semantically identical in swift (the former just has data 
  associated with its discriminators) and 'enum' is the vastly more
  common case.  For more rationale, please see docs/proposals/Enums.rst
  in the Swift source tree.

* The Optional type 'T?' is now represented as an enum:

    enum Optional<T> {
      case None
      case Some(T)
    }

  This means that, in addition to the existing Optional APIs, it can be
  pattern-matched with switch:

    var x : X?, y : Y?
    switch (x, y) {
    // Both are present
    case (.Some(var a), .Some(var b)):
      println("both")

    // One is present
    case (.Some, .None):
    case (.None, .Some):
      println("one")

    // Neither is present
    case (.None, .None):
      println("neither")
    }

* The Objective-C 'id' and 'Class' types now support referring to
  methods declared in any class or protocol without a downcast. For
  example, given a variable "sender" of type "id", one can refer to
  -isEqual: with:

    sender.isEqual

  The actual object may or may not respond to -isEqual, so this
  expression returns result of optional type whose value is determined via a
  compiler-generated -respondsToSelector send. When it succeeds, the
  optional contains the method; when it fails, the optional is empty. 

  To safely test the optional, one can use, e.g.,

    var senderIsEqual = sender.isEqual
    if senderIsEqual {
      // this will never trigger an "unrecognized selector" failure
      var equal = senderIsEqual!()(other)
    } else {
      // sender does not respond to -isEqual:
    }

  When you *know* that the method is there, you can use postfix '!' to
  force unwrapping of the optional, e.g.,

   sender.isEqual!(other)

  This will fail at runtime if in fact sender does not respond to  -isEqual:.
  We have some additional syntactic optimizations planned for testing
  an optional value and handling both the success and failure cases
  concisely. Watch this space.

2013-09-17
----------

* Constructor syntax has been improved to align better with
  Objective-C's init methods. The "constructor" keyword has been
  replaced with "init", and the selector style of declaration used for
  func declarations is now supported. For example:

    class Y : NSObject {
      init withInt(i : Int) string(s : String) {
        super.init() // call superclass initializer
      }
    }

  One can use this constructor to create a Y object with, e.g.,

    Y(withInt:17, string:"Hello")

  Additionally, the rules regarding the selector corresponding to such
  a declaration have been revised. The selector for the above
  initializer is "initWithInt:string:"; the specific rules are
  described in the documentation. 

  Finally, Swift initializers now introduce Objective-C entry points,
  so a declaration such as:

    class X : NSObject {
      init() {
        super.init()
      }
    }

  Overrides NSObject's '-init' method (which it calls first) as well
  as introducing the 'allocating' entry point so that one can create a
  new 'X' instance with the syntax 'X()'.

* Variables in top-level code (i.e. scripts, but not global variables in
  libraries) that lack an initializer now work just like local variables:
  they must be explicitly assigned-to sometime before any use, instead of
  being default constructed.  Instance variables are still on the TODO 
  list.

* Generic unions with a single payload case and any number of empty cases
  are now implemented, for example:

    union Maybe<T> {
      case Some(T)
      case None
    }

    union Tristate<T> {
      case Initialized(T)
      case Initializing
      case Uninitialized
    }

  Generic unions with multiple payload cases are still not yet implemented.

2013-09-11
----------

* The implementation now supports partial application of class and struct
  methods:

    (swift) class B { func foo() { println("B") } }
    (swift) class D : B { func foo() { println("D") } }
    (swift) var foo = B().foo
    // foo : () -> () = <unprintable value>
    (swift) foo()
    B
    (swift) foo = D().foo
    (swift) foo()
    D

  Support for partial application of Objective-C class methods and methods in
  generic contexts is still incomplete.

2013-09-04
----------

* Local variable declarations without an initializer are no longer implicitly
  constructed.  The compiler now verifies that they are initialized on all
  paths leading to a use of the variable.  This means that constructs like this
  are now allowed:
  
    var p : SomeProtocol
    if whatever {
      p = foo()
    } else {
      p = bar()
    }
  
  where before, the compiler would reject the definition of "p" saying that it
  needed an initializer expression.
  
  Since all local variables must be initialized before use, simple things like
  this are now rejected as well:
  
    var x : Int
    print(x)

  The fix is to initialize the value on all paths, or to explicitly default
  initialize the value in the declaration, e.g. with "var x = 0" or with
  "var x = Int()" (which works for any default-constructible type).

* The implementation now supports unions containing protocol types and weak
  reference types.

* The type annotation syntax, 'x as T', has been removed from the language.
  The checked cast operations 'x as! T' and 'x is T' still remain.


2013-08-28
----------

* 'this' has been renamed to 'self'.  Similarly, 'This' has been renamed to
  'Self'.

* Swift now supports unions. Unlike C unions, Swift's 'union' is type-safe
  and always knows what type it contains at runtime. Union members are labeled
  using 'case' declarations; each case may have a different set of
  types or no type:

    union MaybeInt {
      case Some(Int)
      case None
    }

    union HTMLTag {
      case A(href:String)
      case IMG(src:String, alt:String)
      case BR
    }

  Each 'case' with a type defines a static constructor function for the union
  type. 'case' declarations without types become static members:

    var br = HTMLTag.BR
    var a = HTMLTag.A(href:"http://www.apple.com/")
    // 'HTMLTag' scope deduced for '.IMG' from context
    var img : HTMLTag = .IMG(src:"http://www.apple.com/mac-pro.png",
                             alt:"The new Mac Pro")

  Cases can be pattern-matched using 'switch':

    switch tag {
    case .BR:
      println("<br>")
    case .IMG(var src, var alt):
      println("<img src=\"\(escape(src))\" alt=\"\(escape(alt))\">")
    case .A(var href):
      println("<a href=\"\(escape(href))\">")
    }

  Due to implementation limitations, recursive unions are not yet supported.


* Swift now supports autolinking, so importing frameworks or Swift libraries
  should no longer require adding linker flags or modifying your project file.


* The xcplugin in the Swift repository has been removed, as it is incompatible
  with the work done in the IDELanguageSupport repository. The best support for
  now is to build Xcode yourself with the IDELanguageSupport project included,
  but for simple parity with the old xcplugin, follow the instructions in
  utils/xcode.txt.


2013-08-14
----------

* Swift now supports weak references by applying the [weak] attribute to a
  variable declaration.

    (swift) var x = NSObject()
    // x : NSObject = <NSObject: 0x7f95d5804690>
    (swift) var [weak] w = x
    // w : NSObject = <NSObject: 0x7f95d5804690>
    (swift) w == nil
    // r2 : Bool = false
    (swift) x = NSObject()
    (swift) w == nil
    // r3 : Bool = true

  Swift also supports a special form of weak reference, called [unowned], for
  references that should never be nil but are required to be weak to break
  cycles, such as parent or sibling references. Accessing an [unowned]
  reference asserts that the reference is still valid and implicitly promotes
  the loaded reference to a strong reference, so it does not need to be loaded
  and checked for nullness before use like a true [weak] reference.

    class Parent {
      var children : Vector<Child>

      func addChild(c:Child) {
        c.parent = this
        children.append(c)
      }
    }

    class Child {
      var [unowned] parent : Parent
    }


2013-07-31
----------

* Numeric literals can now use underscores as separators. For example:

    var billion = 1_000_000_000
    var crore = 1_00_00_000
    var MAXINT = 0x7FFF_FFFF_FFFF_FFFF
    var SMALLEST_DENORM = 0x0.0000_0000_0000_1p-1022


* Types conforming to protocols now must always declare the conformance in
  their inheritance clause.


* The build process now produces serialized modules for the standard library,
  greatly improving build times.


2013-07-24
----------

* Arithmetic operators "+", "-", "*", and "/" on integer types now do
  overflow checking and trap on overflow. A parallel set of masking operators,
  "&+", "&-", "&*", and "&/", are defined to perform two's complement wrapping
  arithmetic for all signed and unsigned integer types.


* Debugger support. Swift has a "-g" command line switch that turns on
  debug info for the compiled output. Using the standard lldb debugger
  this will allow single-stepping through Swift programs, printing
  backtraces, and navigating through stack frames; all in sync with
  the corresponding Swift source code. An unmodified lldb cannot
  inspect any variables.

  Example session:
    $ echo 'println("Hello World")' >hello.swift
    $ swift hello.swift -c -g -o hello.o
    $ ld hello.o "-dynamic" "-arch" "x86_64" "-macosx_version_min" "10.9.0" \
         -framework Foundation lib/swift/libswift_stdlib_core.dylib \
         lib/swift/libswift_stdlib_posix.dylib -lSystem -o hello
    $ lldb hello
    Current executable set to 'hello' (x86_64).
    (lldb) b top_level_code
    Breakpoint 1: where = hello`top_level_code + 26 at hello.swift:1, addre...
    (lldb) r
    Process 38592 launched: 'hello' (x86_64)
    Process 38592 stopped
    * thread #1: tid = 0x1599fb, 0x0000000100000f2a hello`top_level_code + ...
        frame #0: 0x0000000100000f2a hello`top_level_code + 26 at hello.shi...
    -> 1         println("Hello World")
    (lldb) bt
    * thread #1: tid = 0x1599fb, 0x0000000100000f2a hello`top_level_code + ...
        frame #0: 0x0000000100000f2a hello`top_level_code + 26 at hello.shi...
        frame #1: 0x0000000100000f5c hello`main + 28
        frame #2: 0x00007fff918605fd libdyld.dylib`start + 1
        frame #3: 0x00007fff918605fd libdyld.dylib`start + 1

  Also try "s", "n", "up", "down".


2013-07-17
----------

* Swift now has a 'switch' statement, supporting pattern matching of
  multiple values with variable bindings, guard expressions, and range
  comparisons. For example:

    func classifyPoint(point:(Int, Int)) {
      switch point {
      case (0, 0):
        println("origin")

      case (_, 0):
        println("on the x axis")

      case (0, _):
        println("on the y axis")

      case (var x, var y) where x == y:
        println("on the y = x diagonal")

      case (var x, var y) where -x == y:
        println("on the y = -x diagonal")

      case (-10..10, -10..10):
        println("close to the origin")

      case (var x, var y):
        println("length \(sqrt(x*x + y*y))")
      }
    }


2013-07-10
----------

* Swift has a new closure syntax. The new syntax eliminates the use of
  pipes. Instead, the closure signature is written the same way as a
  function type and is separated from the body by the "in"
  keyword. For example:

    sort(fruits) { (lhs : String, rhs : String) -> Bool in
      return lhs > rhs 
    }

  When the types are omitted, one can also omit the parentheses, e.g.,

    sort(fruits) { lhs, rhs in lhs > rhs }

  Closures with no parameters or that use the anonymous parameters
  ($0, $1, etc.) don't need the 'in', e.g.,

    sort(fruits) { $0 > $1 }


* nil can now be used without explicit casting. Previously, 'nil' had
  type NSObject, so one would have to write (e.g.) 'nil as! NSArray'
  to create a nil NSArray. Now, 'nil' picks up the type of its
  context.


* POSIX.EnvironmentVariables and swift.CommandLineArguments global variables
  were merged into a swift.Process variable.  Now you can access command line
  arguments with Process.arguments.  In order to acces environment variables
  add "import POSIX" and use Process.environmentVariables.

