%{
#//===--- Mirrors.gyb ------------------------------------------*- swift -*-===//
#//
#// This source file is part of the Swift.org open source project
#//
#// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
#// Licensed under Apache License v2.0 with Runtime Library Exception
#//
#// See http://swift.org/LICENSE.txt for license information
#// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
#//
#//===----------------------------------------------------------------------===//
# This file contains boilerplate that is common among all the Mirrors in the
# Swift Standard Library. It is meant to be used as a template to be included
# in other .gyb files to generate actual Mirror implementations, by only typing
# as little code as necessary
# Instructions:
# Load the file as a gyb template
# When you want to generate a Mirror, execute this template. Locals are as follows:
# - introspecteeType: the base name of the type to be reflected by your Mirror
# - genericArgs: a list of names of generic argument types that you need for your Mirror
# - genericConstraints: a dictionary that contains constraints on generic argument types
# - disposition: a valid disposition for your Mirror
# You still need to provide count, subscript, summary and quickLookObject manually when using
# this template, which is probably reasonable since those are "the meat" of every Mirror
}%

%{
if not ('genericArgs' in locals()):
  genericArgString = ''
  genericConstraintString = ''
else:
  genericArgString = ''
  first = True
  for arg in genericArgs:
    if not first:
      genericArgString  = genericArgString + ','
    first = False
    genericArgString = genericArgString + arg
  if not ('genericConstraints' in locals()):
    genericConstraintString = genericArgString
  else:
    genericConstraintString = ''
    first = True
    for arg in genericArgs:
      if not first:
        genericConstraintString = genericConstraintString + ','
      first = False
      genericConstraintString = genericConstraintString + arg
      if arg in genericConstraints:
        cons = genericConstraints[arg]
        genericConstraintString = genericConstraintString + ' : ' + cons
  genericArgString = '<' + genericArgString + '>'
  genericConstraintString = '<' + genericConstraintString + '>'
if not ('disposition' in locals()):
  disposition = '.Aggregate'
else:
  if disposition[0] != '.':
    disposition = '.' + disposition
}%

extension ${introspecteeType} : Reflectable {
  @public func getMirror() -> Mirror {
    return _${introspecteeType}Mirror(self)
  }
}

@internal struct _${introspecteeType}Mirror${genericConstraintString} : Mirror {
  var _value: ${introspecteeType}${genericArgString}

  init(_ x: ${introspecteeType}${genericArgString}) {
    _value = x
  }

  @public var value: Any { return _value }

  @public var valueType: Any.Type { return (_value as Any).dynamicType }

  @public var objectIdentifier: ObjectIdentifier? { return .None }

  @public var disposition: MirrorDisposition { return ${disposition} }
