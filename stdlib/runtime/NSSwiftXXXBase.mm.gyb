//===--- NSSwiftXXXBase.mm.gyb - Cocoa container buffer bases -*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// This file defines:
//
//    _NSSwiftArrayBase, _NSSwiftDictionaryBase, _NSSwiftStringBase
//
// To optimize bridging between Swift containers and their Cocoa
// counterparts, we derive Swift containers' buffers from the
// corresponding Cocoa classes; that way we can just hand a buffer off
// to Cocoa when it holds bridged types.  
//
//===----------------------------------------------------------------------===//

#import <Foundation/Foundation.h>
#include <objc/NSObject.h>
#include <objc/runtime.h>
#if __has_include(<objc/objc-internal.h>)
#include <objc/objc-internal.h>
#endif
#include "swift/Runtime/HeapObject.h"
#include "swift/Runtime/Metadata.h"
#include "swift/Runtime/ObjCBridge.h"
#include "llvm/ADT/DenseMap.h"
#include "Private.h"
#include <stdio.h>
#include <stdlib.h>
#include <mutex>

// Redeclare these just we check them.
extern "C" id _objc_rootAutorelease(id);

using namespace swift;

% for Class in ('Array', 'Dictionary', 'String', 'Enumerator'):
@interface _NSSwift${Class}Base : NS${Class}
{
  SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;
}
@end

@implementation _NSSwift${Class}Base
+ (void)load {
  // Poke this class into the superclass chain for _NSSwift${Class}
  auto subclassName = "_NSSwift${Class}";
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

  // Compute the mangled name of the subclass
  char subclassMangledName[64];
  snprintf(
    subclassMangledName, sizeof(subclassMangledName),
    "_TtCSs%d%s",
    (int)strlen(subclassName), subclassName);

  auto subclass = objc_getClass(subclassMangledName);
  auto selfClass = [_NSSwift${Class}Base class];
  class_setSuperclass(subclass, selfClass);
#pragma clang diagnostic pop
}

- (id)retain {
  auto SELF = reinterpret_cast<HeapObject *>(self);
  swift_retain(SELF);
  return self;
}
- (oneway void)release {
  auto SELF = reinterpret_cast<HeapObject *>(self);
  swift_release(SELF);
}
- (id)autorelease {
  return _objc_rootAutorelease(self);
}

- (BOOL)_tryRetain {
  auto SELF = reinterpret_cast<HeapObject *>(self);
  return (bool)swift_tryRetain(SELF);
}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wobjc-missing-super-calls"
- (void)dealloc {
  _swift_deallocClassInstance(reinterpret_cast<HeapObject *>(self));
}
#pragma clang diagnostic pop

@end
% end

extern "C" bool swift_stdlib_NSObject_isEqual(NSObject *lhs, NSObject *rhs) {
  bool Result = [lhs isEqual:rhs];
  swift_unknownRelease(lhs);
  swift_unknownRelease(rhs);
  return Result;
}

extern "C" int32_t
swift_stdlib_compareNSStringDeterministicUnicodeCollation(NSString *lhs,
                                                          NSString *rhs) {
  // 'kCFCompareNonliteral' actually means "normalize to NFD".
  int Result = CFStringCompare((__bridge CFStringRef)lhs,
                               (__bridge CFStringRef)rhs, kCFCompareNonliteral);
  swift_unknownRelease(lhs);
  swift_unknownRelease(rhs);
  return Result;
}

extern "C" size_t swift_stdlib_NSStringNFDHashValue(NSString *str) {
  int Result = str.decomposedStringWithCanonicalMapping.hash;
  swift_unknownRelease(str);
  return Result;
}

extern "C" bool swift_stdlib_NSStringHasPrefixNFD(NSString *theString,
                                                  NSString *prefix) {
  auto Length = CFStringGetLength((__bridge CFStringRef)theString);
  int Result = CFStringFindWithOptions(
      (__bridge CFStringRef)theString, (__bridge CFStringRef)prefix,
      CFRangeMake(0, Length), kCFCompareAnchored | kCFCompareNonliteral,
      nullptr);
  swift_unknownRelease(theString);
  swift_unknownRelease(prefix);
  return Result;
}

extern "C" bool swift_stdlib_NSStringHasSuffixNFD(NSString *theString,
                                                  NSString *suffix) {
  auto Length = CFStringGetLength((__bridge CFStringRef)theString);
  int Result = CFStringFindWithOptions(
      (__bridge CFStringRef)theString, (__bridge CFStringRef)suffix,
      CFRangeMake(0, Length),
      kCFCompareAnchored | kCFCompareBackwards | kCFCompareNonliteral, nullptr);
  swift_unknownRelease(theString);
  swift_unknownRelease(suffix);
  return Result;
}

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
