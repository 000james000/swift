//===--- Filter.swift.gyb -------------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// The `GeneratorType` used by `FilterSequenceView` and
/// `FilterCollectionView`
public struct FilterGenerator<
  Base: GeneratorType
> : GeneratorType, SequenceType {
  /// Advance to the next element and return it, or `nil` if no next
  /// element exists.
  ///
  /// Requires: `next()` has not been applied to a copy of `self`
  /// since the copy was made, and no preceding call to `self.next()`
  /// has returned `nil`.
  public mutating func next() -> Base.Element? {
    var n: Base.Element?
    for/*ever*/;; {
      n = _base.next()
      if n != nil ? _include(n!) : true {
        return n
      }
    }
  }

  /// `FilterGenerator` is also a `SequenceType`, so it `generate`'s
  /// a copy of itself
  public func generate() -> FilterGenerator {
    return self
  }

  var _base: Base
  var _include: (Base.Element)->Bool
}

/// The lazy `SequenceType` returned by `filter(c)` where `c` is a
/// `SequenceType`
public struct FilterSequenceView<Base : SequenceType> : SequenceType {
  /// Return a *generator* over the elements of this *sequence*.
  ///
  /// - complexity: O(1)
  public func generate() -> FilterGenerator<Base.Generator> {
    return FilterGenerator(_base: _base.generate(), _include: _include)
  }

  var _base: Base
  var _include: (Base.Generator.Element)->Bool
}

/// The `Index` used for subscripting a `FilterCollectionView`
public struct FilterCollectionViewIndex<
  Base: CollectionType
> : ForwardIndexType {
  /// Returns the next consecutive value after `self`.
  ///
  /// Requires: the next value is representable.
  public func successor() -> FilterCollectionViewIndex {
    for nextPos in _pos.successor()..<_end {
      if _include(_base[nextPos]) {
        return FilterCollectionViewIndex(
          _pos: nextPos, _end: _end,
          _base: _base, _include: _include)
      }
    }
    return FilterCollectionViewIndex(
      _pos: _end, _end: _end, _base: _base, _include: _include)
  }
  var _pos: Base.Index
  var _end: Base.Index
  var _base: Base
  var _include: (Base.Generator.Element)->Bool
}

public func == <Base: CollectionType>(
  lhs: FilterCollectionViewIndex<Base>,
  rhs: FilterCollectionViewIndex<Base>
) -> Bool {
  return lhs._pos == rhs._pos
}

/// A lazy `CollectionType` wrapper that includes the elements of an
/// underlying collection that satisfy a predicate.  Not
/// automatically returned by `filter(x)` for two reasons:
///
/// * The O(1) guarantee of our `Index` would be iffy at best, since
///   it advances an underlying `Index` until the predicate is
///   satisfied.  Be aware that a `FilterCollectionView` may not offer
///   the expected efficiency for this reason.
///
/// * Constructing an `Array` from a `CollectionType` measures the length
///   of the collection before traversing it to read the elements.
///   This causes the filter predicate to be called twice for each
///   element of the underlying collection, which is surprising.
public struct FilterCollectionView<Base : CollectionType> : CollectionType {

  /// A type that represents a valid position in the collection.
  ///
  /// Valid indices consist of the position of every element and a
  /// "past the end" position that's not valid for use as a subscript.
  public typealias Index = FilterCollectionViewIndex<Base>

  /// Construct an instance containing the elements of `base` that
  /// satisfy `predicate`.
  public init(
    _ base: Base,
    includeElement predicate: (Base.Generator.Element)->Bool
  ) {
    self._base = base
    self._include = predicate
  }

  /// The position of the first element in a non-empty collection.
  ///
  /// In an empty collection, `startIndex == endIndex`.
  ///
  /// - complexity: O(N), where N is the ratio between unfiltered and
  ///   filtered collection counts.
  public var startIndex: Index {
    var first = _base.startIndex
    while first != _base.endIndex {
      if _include(_base[first]) {
        break
      }
      ++first
    }
    return FilterCollectionViewIndex(
      _pos: first, _end: _base.endIndex, _base: _base, _include: _include)
  }

  /// The collection's "past the end" position.
  ///
  /// `endIndex` is not a valid argument to `subscript`, and is always
  /// reachable from `startIndex` by zero or more applications of
  /// `successor()`.
  ///
  /// - complexity: O(1)
  public var endIndex: Index {
    return FilterCollectionViewIndex(
      _pos: _base.endIndex, _end: _base.endIndex,
      _base: _base, _include: _include)
  }

  /// Access the element at `position`.
  ///
  /// Requires: `position` is a valid position in `self` and
  /// `position != endIndex`.
  public subscript(position: Index) -> Base.Generator.Element {
    return _base[position._pos]
  }

  /// Return a *generator* over the elements of this *sequence*.
  ///
  /// - complexity: O(1)
  public func generate() -> FilterGenerator<Base.Generator> {
    return FilterGenerator(_base: _base.generate(), _include: _include)
  }

  var _base: Base
  var _include: (Base.Generator.Element)->Bool
}

/// Return an `Array` containing the elements of `source`,
/// in order, that satisfy the predicate `includeElement`.
public func filter<S : SequenceType>(
  source: S, _ includeElement: (S.Generator.Element) -> Bool
) -> [S.Generator.Element] {
  // FIXME(prext): remove this function when protocol extensions land.
  return source._prext_filter(includeElement)
}

% traversals = ('Forward', 'Bidirectional', 'RandomAccess')
% for Self in ['LazySequence'] + [ 'Lazy%sCollection' % t for t in traversals ]:
extension ${Self} {
  /// Return a lazy SequenceType containing the elements `x` of `source` for
  /// which `includeElement(x)` is `true`
  public
  func filter(
    includeElement: (S.Generator.Element)->Bool
  ) -> LazySequence<FilterSequenceView<S>> {
    return LazySequence<FilterSequenceView<S>>(
      FilterSequenceView(_base: self._base, _include: includeElement))
  }
}

% end

/*
// No overload for collections; see the comment on
// FilterCollectionView for an explanation.

/// Return a lazy CollectionType containing the elements `x` of `source` for
/// which `includeElement(x)` is `true`
public func filter<C : CollectionType>(
  source: C, _ includeElement: (C.Generator.Element)->Bool
) -> FilterCollectionView<C> {
  // FIXME(prext): remove this function when protocol extensions land.
  return FilterCollectionView(_base: source, _include: includeElement)
}
*/

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
