//===--- Reverse.swift.gyb - Lazy sequence reversal -----------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


/// Return an `Array` containing the elements of `source` in reverse
/// order.
@available(*, unavailable, message="call the 'reverse()' method on the collection")
public func reverse<C:CollectionType where C.Index: BidirectionalIndexType>(
  source: C
) -> [C.Generator.Element] {
  fatalError("unavailable function can't be called")
}

% for traversal in ('Bidirectional', 'RandomAccess'):
%   View = '%sReverseView' % traversal
%   Self = 'Lazy%sCollection' % traversal
%   Index = 'Reverse%sIndex' % traversal
%   IndexProtocol = '%sIndexType' % traversal

/// A wrapper for a `${IndexProtocol}` that reverses its
/// direction of traversal.
public struct ${Index}<I : ${IndexProtocol}> : ${IndexProtocol} {
  var _base: I

  init(_ _base: I) { self._base = _base }

  /// Returns the next consecutive value after `self`.
  ///
  /// - Requires: The next value is representable.
  public func successor() -> ${Index} {
    return ${Index}(_base.predecessor())
  }

  /// Returns the previous consecutive value before `self`.
  ///
  /// - Requires: The previous value is representable.
  public func predecessor() -> ${Index} {
    return ${Index}(_base.successor())
  }

  /// A type that can represent the number of steps between pairs of
  /// `${Self}` values where one value is reachable from the other.
  typealias Distance = I.Distance

%   if traversal == 'RandomAccess':
  /// Return the minimum number of applications of `successor` or
  /// `predecessor` required to reach `other` from `self`.
  ///
  /// - Complexity: O(1).
  public func distanceTo(other: ${Index}) -> Distance {
    return other._base.distanceTo(_base)
  }

  /// Return `self` offset by `n` steps.
  ///
  /// - Returns: If `n > 0`, the result of applying `successor` to
  ///   `self` `n` times.  If `n < 0`, the result of applying
  ///   `predecessor` to `self` `-n` times. Otherwise, `self`.
  ///
  /// - Complexity: O(1).
  public func advancedBy(amount: Distance) -> ${Index} {
    return ${Index}(_base.advancedBy(-amount))
  }
%   end
}

public func == <I> (lhs: ${Index}<I>, rhs: ${Index}<I>) -> Bool {
  return lhs._base == rhs._base
}

/// The lazy `CollectionType` returned by `reverse(c)` where `c` is a
/// `CollectionType` with an `Index` conforming to `${IndexProtocol}`.
public struct ${View}<
  T : CollectionType where T.Index : ${IndexProtocol}
> : CollectionType {
  /// A type that represents a valid position in the collection.
  ///
  /// Valid indices consist of the position of every element and a
  /// "past the end" position that's not valid for use as a subscript.
  public typealias Index = ${Index}<T.Index>

  /// A type whose instances can produce the elements of this
  /// sequence, in order.
  public typealias Generator = IndexingGenerator<${View}>

  init(_ _base: T) {
    self._base = _base
  }

  /// The position of the first element in a non-empty collection.
  ///
  /// In an empty collection, `startIndex == endIndex`.
  public var startIndex: Index {
    return ${Index}(_base.endIndex)
  }

  /// The collection's "past the end" position.
  ///
  /// `endIndex` is not a valid argument to `subscript`, and is always
  /// reachable from `startIndex` by zero or more applications of
  /// `successor()`.
  public var endIndex: Index {
    return ${Index}(_base.startIndex)
  }

  /// Access the element at `position`.
  ///
  /// - Requires: `position` is a valid position in `self` and
  ///   `position != endIndex`.
  public subscript(position: Index) -> T.Generator.Element {
    return _base[position._base.predecessor()]
  }

  var _base: T
}

extension ${Self} {
  /// Return a `${View}` over this `${Self}`.  The elements of
  /// the result are computed lazily, each time they are read, by
  /// calling `transform` function on a base element.
  public func reverse() -> LazyBidirectionalCollection<${View}<Base>> {
    return LazyBidirectionalCollection<${View}<Base>>(
      ${View}<Base>(self._base)
    )
  }
}

% end

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
