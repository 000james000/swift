//===--- LowLevelInt.swift.gyb --------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
%{
#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)

# Number of bits in the Builtin.Word type
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8

# Number of bits in integer literals.
builtinIntLiteralBits = 2048

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

fixedBitWidths = [2**x for x in range(3, 8)]
minFixedBits = fixedBitWidths[0]
maxFixedBits = fixedBitWidths[-1]

# Enumerate all the builtin operations that apply to integers
builtinBinaryOperations = [
  'add',  'and',  'ashr',  'lshr',  'or',  'mul',  'sdiv',  'sdiv_exact',
  'shl', 'srem',  'sub',  'udiv',  'udiv_exact',  'urem',  'xor']

builtinBinaryOperationsWithOverflow = [
  'sadd_with_overflow', 'uadd_with_overflow',  'ssub_with_overflow',
  'usub_with_overflow',  'smul_with_overflow', 'umul_with_overflow']
  
builtinUnaryOperations = ['assumeNonNegative']
  
builtinBinaryPredicates = [
  'cmp_eq',  'cmp_ne',  'cmp_sle',  'cmp_slt',  'cmp_sge',  'cmp_sgt',
  'cmp_ule',  'cmp_ult',  'cmp_uge',  'cmp_ugt']

builtinSILOperations = ['gep']

builtinMiscOperations = ['atomicrmw']  
}%

/// A low-level 2's complement integer.
public protocol _LowLevelInteger : Equatable {
  /// A _LowLevelInt type that accomodates more bits of precision than
  /// any instance of `Self`.
  typealias Extended

  /// A _LowLevelInt type that accomodates fewer bits of precision than
  /// any instance of `Self`.
  typealias Truncated
  
  /// A Builtin type used as `Self`'s representation
  typealias Storage

  /// Creates an instance with value 0
  init()
  
  /// Creates an instance with the given storage representation
  init(_: Storage)

  /// The number of bits `Self` can store
  static var bitWidth : Swift.Int { get }
  
  /// The entire storage of `self`'s value.  
  var storage: Storage { get set }

% for operation in builtinBinaryOperations:
  func ${operation}(rhs: Self) -> Self
% end

% for operation in builtinBinaryOperationsWithOverflow:
  func ${operation}(rhs: Self, overflowIsError: Bool) -> (Self, Bool)
% end

  func isLessThanSigned(rhs: Self) -> Bool
  func isLessThanUnsigned(rhs: Self) -> Bool
  
  /// Returns `self` while informing the optimizer that the high bit
  /// is not set.
  ///
  /// - Requires: the high bit is not set.
  var assumingNonNegative : Self { get }

  /// Returns `self`, trapping if the high bit is set
  func checkingNonNegative() -> Self
  
#if false
  var maxUnsetBit : Swift.Int { get }
  var maxSetBit : Swift.Int { get }
#endif
  var signExtended : Extended { get }
  var zeroExtended : Extended { get }
  
  var truncated : Truncated { get }
}

extension _LowLevelInteger {
  public init(_ other: Self) {
    self.init()
    self.storage = other.storage
  }
}

// Only needed outside the stdlib
% for bits in fixedBitWidths:
%   # Until we have BitInt, the widest Int sign-extends into itself.
%   extendedBits = bits * 2 if bits != maxFixedBits else bits
%   narrowedBits = bits / 2 if bits != minFixedBits else bits
public struct _LowLevelInt${bits} : _LowLevelInteger {
  public typealias Self_ = _LowLevelInt${bits}
  public typealias Extended = _LowLevelInt${extendedBits}
  public typealias Narrowed = _LowLevelInt${narrowedBits}
  public typealias Storage = Builtin.Int${bits}

  public init() {
    let zero: Builtin.Int${bits} = Builtin.zeroInitializer()
    self.storage = zero
  }

  public init(_ storage: Storage) {
    self.storage = storage
  }
  
  public var storage: Storage
  
  public static var bitWidth : Swift.Int { return ${word_bits} }
  
% for operation in builtinBinaryOperations:
  public func ${operation}(rhs: Self_) -> Self_ {
    return Self_(Builtin.${operation}_Int${bits}(storage, rhs.storage))
  }
% end

% for operation in builtinBinaryOperationsWithOverflow:
  public func ${operation}(rhs: Self_, overflowIsError: Bool) -> (Self_, Bool) {
    let r = Builtin.${operation}_Int${bits}(
      storage, rhs.storage, overflowIsError.value)
    return (Self_(r.0), Bool(r.1))
  }
% end
  
% for sz in 'sign', 'zero':
  public var ${sz}Extended: Extended {
    return Extended(
      Builtin.${sz[0]}extOrBitCast_Int${bits}_Int${extendedBits}(storage)
    )
  }
% end

% for (srcSigned, srcS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  public func isLessThan${srcSigned}(rhs: Self_) -> Bool {
    return Bool(
      Builtin.cmp_${srcS}lt_Int${bits}(
        self.storage, rhs.storage))
  }
  
  % for (dstSigned, dstS) in ((x, x[0].lower()) for x in ['Signed', 'Unsigned']):
  public func checkingNarrow${srcSigned}To${dstSigned}() -> Narrowed {
    let (result, error) 
      = Builtin.${srcS}_to_${dstS}_checked_trunc_Int${bits}_Int${narrowedBits}(
          storage)
    Builtin.condfail(error)
    return Narrowed(result)
  }
  % end
% end
  
  public var assumingNonNegative : Self_ {
    return Self_(Builtin.assumeNonNegative_Int${bits}(storage))
  }
  
  public func checkingNonNegative() -> Self_ {
    let (result, error) = Builtin.s_to_u_checked_conversion_Int${bits}(storage)
    Builtin.condfail(error)
    return Self_(result)
  }

  public var truncated: Narrowed {
    return Narrowed(
      Builtin.truncOrBitCast_Int${bits}_Int${narrowedBits}(storage)
    )
  }
}

public func == (lhs: _LowLevelInt${bits}, rhs: _LowLevelInt${bits}) -> Bool {
  return Bool(Builtin.cmp_eq_Int${bits}(lhs.storage, rhs.storage))
}

% end
