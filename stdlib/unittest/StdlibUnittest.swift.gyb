//===--- StdlibUnittest.swift.gyb -----------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Darwin

public struct SourceLoc {
  let file: String
  let line: UWord
  let comment: String?

  public
  init(_ file: String, _ line: UWord, comment: String? = nil) {
    self.file = file
    self.line = line
    self.comment = comment
  }

  public
  func withCurrentLoc(
      file: String = __FILE__, line: UWord = __LINE__
  ) -> SourceLocStack {
    return SourceLocStack(self).with(SourceLoc(file, line))
  }
}

public struct SourceLocStack {
  let locs: [SourceLoc] = []

  public
  init() {}

  init(_ loc: SourceLoc) {
    locs = [ loc ]
  }

  init(_locs: [SourceLoc]) {
    locs = _locs
  }

  var isEmpty: Bool {
    return locs.isEmpty
  }

  func with(loc: SourceLoc) -> SourceLocStack {
    var locs = self.locs
    locs.append(loc)
    return SourceLocStack(_locs: locs)
  }

  public
  func withCurrentLoc(
      file: String = __FILE__, line: UWord = __LINE__
  ) -> SourceLocStack {
    return with(SourceLoc(file, line))
  }
}

internal func _printStackTrace(stackTrace: SourceLocStack?) {
  if let s = stackTrace {
    println("stacktrace:")
    for i in 0..<s.locs.count {
      let loc = s.locs[s.locs.count - i - 1]
      let comment = (loc.comment != nil) ? " ; \(loc.comment!)" : ""
      println("  #\(i): \(loc.file):\(loc.line)\(comment)")
    }
  }
}

// FIXME: this variable should be atomic, since multiple threads can call
// `expect*()` functions.
var _anyExpectFailed = false

public func expectEqual<T : Equatable>(
    expected: T, actual: T,
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  expectEqual(expected, actual, {$0 == $1},
    stackTrace: stackTrace, collectMoreInfo,
    file: file, line: line)
}

public func expectEqual<T>(
    expected: T, actual: T, equal: (T,T)->Bool,
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !equal(expected, actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected: \"\(expected)\" (of type \(_stdlib_getDemangledTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(expected)))")
    if collectMoreInfo != nil { println(collectMoreInfo!()) }
    println()
  }
}

public func expectNotEqual<T : Equatable>(
    expected: T, actual: T,
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected == actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("unexpected value: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    println()
  }
}

// Can not write a sane set of overloads using generics because of:
// <rdar://problem/17015923> Array->NSArray implicit conversion insanity
public func expectOptionalEqual<T : Equatable>(
    expected: T, actual: T?,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if (actual == nil) || expected != actual! {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\" (of type \(_stdlib_getDemangledTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    println()
  }
}

// Array<T> is not Equatable if T is.  Provide additional overloads.
// Same for Dictionary.
%for (Generic, EquatableType) in [
%    ('<T : Equatable>', 'ContiguousArray<T>'),
%    ('<T : Equatable>', 'Slice<T>'),
%    ('<T : Equatable>', 'Array<T>'),
%    ('<T, U : Equatable>', 'Dictionary<T, U>'),
%    ('<T : ForwardIndexType>', 'T')]:

public func expectEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  expectEqual(
    expected, actual,
    // FIXME: Simpler closures don't work here due to
    // <rdar://problem/17716712> and <rdar://problem/17717618>
    { (x: ${EquatableType}, y: ${EquatableType})->Bool in  x == y },
    stackTrace: stackTrace, collectMoreInfo, 
    file: file, line: line)
}


func _expectNotEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected == actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("unexpected value: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    println()
  }
}

%end

%for ComparableType in ['Int']:

public func expectLE(
    expected: ${ComparableType}, actual: ${ComparableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !(expected <= actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\"")
    println("actual: \"\(actual)\"")
    println()
  }
}

public func expectGE(
    expected: ${ComparableType}, actual: ${ComparableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !(expected >= actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\"")
    println("actual: \"\(actual)\"")
    println()
  }
}

%end

public struct AssertionResult : Printable, BooleanType {
  init(isPass: Bool) {
    self._isPass = isPass
  }

  public var boolValue: Bool {
    return _isPass
  }

  public func withDescription(description: String) -> AssertionResult {
    var result = self
    result.description += description
    return result
  }

  let _isPass: Bool

  public var description: String = ""
}

public func assertionSuccess() -> AssertionResult {
  return AssertionResult(isPass: true)
}

public func assertionFailure() -> AssertionResult {
  return AssertionResult(isPass: false)
}

%for BoolType in ['Bool', 'AssertionResult']:

public func expectTrue(
    actual: ${BoolType},
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected: true")
    println("actual: \(actual)")
    println()
  }
}

public func expectFalse(
    actual: ${BoolType},
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected: false")
    println("actual: \(actual)")
    println()
  }
}

%end

public func expectEmpty<T>(
    value: Optional<T>,
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if value != nil {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected optional to be empty")
    println("actual: \"\(value)\"")
    println()
  }
}

public func expectNotEmpty<T>(
    value: Optional<T>,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if value == nil {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected optional to be non-empty")
    println()
  }
}

func _defaultTestCaseFailedCallback() {
  abort()
}

var _testCaseFailedCallback: () -> () = _defaultTestCaseFailedCallback

public func _setTestCaseFailedCallback(callback: () -> ()) {
  _testCaseFailedCallback = callback
}

public struct TestCase {
  public init(_ name: String) {
    self.name = name
  }

  public mutating func testXFailSkip(
    name: String, xfail: [TestRunPredicate], skip: [TestRunPredicate],
    _ testFunction: () -> ()
  ) {
    _tests.append(
      _Test(name: name, xfail: xfail, skip: skip, code: testFunction))
  }

  public mutating func testXFail(
    name: String, xfail: [TestRunPredicate], _ testFunction: () -> ()
  ) {
    testXFailSkip(name, xfail: xfail, skip: [], testFunction)
  }

  public mutating func testSkip(
    name: String, skip: [TestRunPredicate], _ testFunction: () -> ()
  ) {
    testXFailSkip(name, xfail: [], skip: skip, testFunction)
  }

  public mutating func test(name: String, _ testFunction: () -> ()) {
    testXFailSkip(name, xfail: [], skip: [], testFunction)
  }

  public mutating func run() {
    var uxpassedTests = [String]()
    var failedTests = [String]()
    var skippedTests = [String]()
    for t in _tests {
      let fullTestName = "\(name).\(t.name)"
      let activeSkips = t.getActiveSkipPredicates()
      if !activeSkips.isEmpty {
        skippedTests += [ t.name ]
        println("[ SKIP     ] \(fullTestName) (skip: \(activeSkips))")
        continue
      }

      let activeXFails = t.getActiveXFailPredicates()
      let expectXFail = !activeXFails.isEmpty
      let activeXFailsText = expectXFail ? " (XFAIL: \(activeXFails))" : ""
      println("[ RUN      ] \(fullTestName)\(activeXFailsText)")
      _anyExpectFailed = false
      t.code()
      switch (_anyExpectFailed, expectXFail) {
      case (false, false):
        println("[       OK ] \(fullTestName)")
      case (false, true):
        uxpassedTests += [ t.name ]
        println("[   UXPASS ] \(fullTestName)")
      case (true, false):
        failedTests += [ t.name ]
        println("[     FAIL ] \(fullTestName)")
      case (true, true):
        println("[    XFAIL ] \(fullTestName)")
      default:
        preconditionFailure("unreachable")
      }
    }
    if !uxpassedTests.isEmpty || !failedTests.isEmpty {
      println("\(name): Some tests failed, aborting")
      println("UXPASS: \(uxpassedTests)")
      println("FAIL: \(failedTests)")
      println("SKIP: \(skippedTests)")
      _testCaseFailedCallback()
    } else {
      println("\(name): All tests passed")
    }
  }

  struct _Test {
    let name: String
    let xfail: [TestRunPredicate]
    let skip: [TestRunPredicate]
    let code: () -> ()

    func getActiveXFailPredicates() -> [TestRunPredicate] {
      return xfail.filter { $0.evaluate() }
    }

    func getActiveSkipPredicates() -> [TestRunPredicate] {
      return skip.filter { $0.evaluate() }
    }
  }

  var name: String
  var _tests: [_Test] = []
}

@asmname("swift_stdlib_getSystemVersionPlistProperty")
func _stdlib_getSystemVersionPlistPropertyImpl(
  propertyName: UnsafePointer<CChar>) -> UnsafePointer<CChar>

func _stdlib_getSystemVersionPlistProperty(propertyName: String) -> String? {
  return String.fromCString(
    _stdlib_getSystemVersionPlistPropertyImpl(propertyName))
}

public enum OSVersion : Printable {
  case OSX(major: Int, minor: Int, bugFix: Int)
  case iOS(major: Int, minor: Int, bugFix: Int)
  case iOSSimulator

  public var description: String {
    switch self {
    case OSX(var major, var minor, var bugFix):
      return "OS X \(major).\(minor).\(bugFix)"
    case iOS(var major, var minor, var bugFix):
      return "iOS \(major).\(minor).\(bugFix)"
    case iOSSimulator:
      return "iOSSimulator"
    }
  }
}

func _parseDottedVersion(s: String) -> [Int] {
  return s._split(".").map { $0.toInt()! }
}

func _parseDottedVersionTriple(s: String) -> (Int, Int, Int) {
  var array = _parseDottedVersion(s)
  if array.count >= 4 {
    fatalError("unexpected version")
  }
  return (
    array.count >= 1 ? array[0] : 0,
    array.count >= 2 ? array[1] : 0,
    array.count >= 3 ? array[2] : 0)
}

func _getOSVersion() -> OSVersion {
#if os(iOS) && (arch(i386) || arch(x86_64))
  // On simulator, the plist file that we try to read turns out to be host's
  // plist file, which indicates OS X.
  //
  // FIXME: how to get the simulator version *without* UIKit?
  return .iOSSimulator
#else
  let productName = _stdlib_getSystemVersionPlistProperty("ProductName")!
  let productVersion = _stdlib_getSystemVersionPlistProperty("ProductVersion")!
  let (major, minor, bugFix) = _parseDottedVersionTriple(productVersion)
  switch productName {
  case "Mac OS X":
    return .OSX(major: major, minor: minor, bugFix: bugFix)
  case "iPhone OS":
    return .iOS(major: major, minor: minor, bugFix: bugFix)
  default:
    fatalError("could not determine OS version")
  }
#endif
}

var _runningOSVersion: OSVersion = _getOSVersion()
var _overrideOSVersion: OSVersion? = nil

/// Override the OS version for testing.
public func _setOverrideOSVersion(v: OSVersion) {
  _overrideOSVersion = v
}

func _getRunningOSVersion() -> OSVersion {
  // Allow overriding the OS version for testing.
  return _overrideOSVersion ?? _runningOSVersion
}

public enum TestRunPredicate : Printable {
  case Custom(() -> Bool, reason: String)

  case OSXAny(/*reason:*/ String)
  case OSXMajor(Int, reason: String)
  case OSXMinor(Int, Int, reason: String)
  case OSXMinorRange(Int, Range<Int>, reason: String)
  case OSXBugFix(Int, Int, Int, reason: String)
  case OSXBugFixRange(Int, Int, Range<Int>, reason: String)

  case iOSAny(/*reason:*/ String)
  case iOSMajor(Int, reason: String)
  case iOSMinor(Int, Int, reason: String)
  case iOSMinorRange(Int, Range<Int>, reason: String)
  case iOSBugFix(Int, Int, Int, reason: String)
  case iOSBugFixRange(Int, Int, Range<Int>, reason: String)

  case iOSSimulatorAny(/*reason:*/ String)

  public var description: String {
    switch self {
    case Custom(_, let reason):
      return "Custom(reason: \(reason))"
    case OSXAny(let reason):
      return "OSX(*, reason: \(reason))"
    case OSXMajor(let major, let reason):
      return "OSX(\(major).*, reason: \(reason))"
    case OSXMinor(let major, let minor, let reason):
      return "OSX(\(major).\(minor), reason: \(reason))"
    case OSXMinorRange(let major, let minorRange, let reason):
      return "OSX(\(major).[\(minorRange)], reason: \(reason))"
    case OSXBugFix(let major, let minor, let bugFix, let reason):
      return "OSX(\(major).\(minor).\(bugFix), reason: \(reason))"
    case OSXBugFixRange(let major, let minor, let bugFixRange, let reason):
      return "OSX(\(major).\(minor).[\(bugFixRange)], reason: \(reason))"

    case iOSAny(let reason):
      return "iOS(*, reason: \(reason))"
    case iOSMajor(let major, let reason):
      return "iOS(\(major).*, reason: \(reason))"
    case iOSMinor(let major, let minor, let reason):
      return "iOS(\(major).\(minor), reason: \(reason))"
    case iOSMinorRange(let major, let minorRange, let reason):
      return "iOS(\(major).[\(minorRange)], reason: \(reason))"
    case iOSBugFix(let major, let minor, let bugFix, let reason):
      return "iOS(\(major).\(minor).\(bugFix), reason: \(reason))"
    case iOSBugFixRange(let major, let minor, let bugFixRange, let reason):
      return "iOS(\(major).\(minor).[\(bugFixRange)], reason: \(reason))"

    case iOSSimulatorAny(let reason):
      return "iOSSimulatorAny(*, reason: \(reason))"
    }
  }

  public func evaluate() -> Bool {
    switch self {
    case Custom(let predicate, _):
      return predicate()

    case OSXAny:
      switch _getRunningOSVersion() {
      case .OSX:
        return true
      default:
        return false
      }

    case OSXMajor(let major, _):
      switch _getRunningOSVersion() {
      case .OSX(major, _, _):
        return true
      default:
        return false
      }

    case OSXMinor(let major, let minor, _):
      switch _getRunningOSVersion() {
      case .OSX(major, minor, _):
        return true
      default:
        return false
      }

    case OSXMinorRange(let major, let minorRange, _):
      switch _getRunningOSVersion() {
      case .OSX(major, let runningMinor, _):
        return contains(minorRange, runningMinor)
      default:
        return false
      }

    case OSXBugFix(let major, let minor, let bugFix, _):
      switch _getRunningOSVersion() {
      case .OSX(major, minor, bugFix):
        return true
      default:
        return false
      }

    case OSXBugFixRange(let major, let minor, let bugFixRange, _):
      switch _getRunningOSVersion() {
      case .OSX(major, minor, let runningBugFix):
        return contains(bugFixRange, runningBugFix)
      default:
        return false
      }

    case iOSAny:
      switch _getRunningOSVersion() {
      case .iOS:
        return true
      default:
        return false
      }

    case iOSMajor(let major, _):
      switch _getRunningOSVersion() {
      case .iOS(major, _, _):
        return true
      default:
        return false
      }

    case iOSMinor(let major, let minor, _):
      switch _getRunningOSVersion() {
      case .iOS(major, minor, _):
        return true
      default:
        return false
      }

    case iOSMinorRange(let major, let minorRange, _):
      switch _getRunningOSVersion() {
      case .iOS(major, let runningMinor, _):
        return contains(minorRange, runningMinor)
      default:
        return false
      }

    case iOSBugFix(let major, let minor, let bugFix, _):
      switch _getRunningOSVersion() {
      case .iOS(major, minor, bugFix):
        return true
      default:
        return false
      }

    case iOSBugFixRange(let major, let minor, let bugFixRange, _):
      switch _getRunningOSVersion() {
      case .iOS(major, minor, let runningBugFix):
        return contains(bugFixRange, runningBugFix)
      default:
        return false
      }

    case iOSSimulatorAny:
      switch _getRunningOSVersion() {
      case .iOSSimulator:
        return true
      default:
        return false
      }
    }
  }
}

// These APIs don't really belong in a unittesting library, but are useful
// in tests, and stdlib does not have such facilities yet.

public func asHex(a: [UInt8]) -> String {
  return "[ " + ", ".join(a.map { "0x" + String($0, radix: 16) }) + " ]"
}

public func asHex(a: [UInt32]) -> String {
  return "[ " + ", ".join(a.map { "0x" + String($0, radix: 16) }) + " ]"
}

//
// Helpers that verify invariants of various stdlib types.
//

public func checkHashable<T : Hashable>(
  expectedEqual: Bool, lhs: T, rhs: T, stackTrace: SourceLocStack,
  _ collectMoreInfo: (()->String)? = nil
) {
  // Test operator '==' that is found through witness tables.
  expectEqual(
    expectedEqual, lhs == rhs, stackTrace: stackTrace, collectMoreInfo)
  expectEqual(
    !expectedEqual, lhs != rhs, stackTrace: stackTrace, collectMoreInfo)

  // Test 'hashValue'.
  //
  // If objects are not equal, then the hash value can be different or it can
  // collide.
  if expectedEqual {
    expectEqual(lhs.hashValue, rhs.hashValue)
  }
}

public func checkHashable<T : Hashable>(
  expectedEqual: Bool, lhs: T, rhs: T,
  _ collectMoreInfo: (()->String)? = nil,
  file: String = __FILE__, line: UWord = __LINE__
) {
  checkHashable(
    expectedEqual, lhs, rhs, SourceLocStack(SourceLoc(file, line)),
    collectMoreInfo)
}

public enum ExpectedComparisonResult {
  case LT, EQ, GT

  public func isLT() -> Bool {
    return self == .LT
  }

  public func isEQ() -> Bool {
    return self == .EQ
  }

  public func isGT() -> Bool {
    return self == .GT
  }

  public func isLE() -> Bool {
    return isLT() || isEQ()
  }

  public func isGE() -> Bool {
    return isGT() || isEQ()
  }

  public func isNE() -> Bool {
    return !isEQ()
  }

  public func flip() -> ExpectedComparisonResult {
    switch self {
    case .LT:
      return .GT
    case .EQ:
      return .EQ
    case .GT:
      return .LT
    }
  }
}

public func checkComparable<T : Comparable>(
  expected: ExpectedComparisonResult,
  lhs: T, rhs: T, stackTrace: SourceLocStack
) {
  expectEqual(expected.isLT(), lhs < rhs, stackTrace: stackTrace)
  expectEqual(expected.isLE(), lhs <= rhs, stackTrace: stackTrace)
  expectEqual(expected.isGE(), lhs >= rhs, stackTrace: stackTrace)
  expectEqual(expected.isGT(), lhs > rhs, stackTrace: stackTrace)
}

public func checkComparable<T : Comparable>(
  expected: ExpectedComparisonResult,
  lhs: T, rhs: T,
  file: String = __FILE__, line: UWord = __LINE__
) {
  checkComparable(expected, lhs, rhs, SourceLocStack(SourceLoc(file, line)))
}

public
func checkGenerator<
    Element : Equatable, G : GeneratorType
    where G.Element == Element>(
    expected: [Element], generator: G, stackTrace: SourceLocStack) {

  // Copying a `GeneratorType` is allowed.
  var mutableGen = generator
  var actual: [Element] = []
  while let e = mutableGen.next() {
    actual.append(e)
  }
  expectEqual(expected, actual, stackTrace: stackTrace.withCurrentLoc())

  // Having returned `.None` once, a `GeneratorType` should not generate more
  // elements.
  for i in 0..<10 {
    expectEmpty(mutableGen.next(), stackTrace: stackTrace.withCurrentLoc())
  }
}

public
func checkSequence<
    Element : Equatable, S : SequenceType
    where S.Generator.Element == Element>(
    expected: [Element], sequence: S, stackTrace: SourceLocStack) {
  checkGenerator(expected, sequence.generate(), stackTrace.withCurrentLoc())
  expectGE(expected.count, underestimateCount(sequence))
}

public
func checkCollection<
    Element : Equatable, C : CollectionType
    where C.Generator.Element == Element>(
    expected: [Element], collection: C, stackTrace: SourceLocStack) {
  // A `CollectionType` is a multi-pass `SequenceType`.
  for i in 0..<3 {
    checkSequence(expected, collection, stackTrace.withCurrentLoc())
  }

  expectEqual(expected.count.toIntMax(), countElements(collection).toIntMax(),
      stackTrace: stackTrace.withCurrentLoc())

  for i in 0..<3 {
    let startIndex = collection.startIndex
    let endIndex = collection.endIndex

    var actual: [Element] = []
    var index = collection.startIndex
    while index != collection.endIndex {
      // Iteration should not change `startIndex` or `endIndex`.
      expectEqual(startIndex, collection.startIndex)
      expectEqual(endIndex, collection.endIndex)

      actual.append(collection[index])
      ++index
    }

    expectEqual(expected, actual, stackTrace: stackTrace.withCurrentLoc())
  }
}

public
func checkSliceableWithBidirectionalIndex<
    Element : Equatable, S : Sliceable
    where S.Generator.Element == Element,
    S.SubSlice.Generator.Element == Element,
    S.Index : BidirectionalIndexType>(
    expected: [Element], sliceable: S, stackTrace: SourceLocStack) {
  // A `Sliceable` is a `CollectionType`.
  checkCollection(expected, sliceable, stackTrace.withCurrentLoc())

  var start = sliceable.startIndex
  for startNumericIndex in 0...expected.count {
    if start != sliceable.endIndex {
      ++start
      --start
      ++start
      --start
    }
    var end = start
    for endNumericIndex in startNumericIndex...expected.count {
      if end != sliceable.endIndex {
        ++end
        --end
        ++end
        --end
      }
      let expectedSlice: [Element] =
          Array(expected[startNumericIndex..<endNumericIndex])
      let slice = sliceable[start..<end]
      checkCollection(expectedSlice, slice, stackTrace.withCurrentLoc())

      if end != sliceable.endIndex {
        ++end
      }
    }
    if start != sliceable.endIndex {
      ++start
    }
  }
}

public func nthIndex<C: CollectionType>(x: C, n: Int) -> C.Index {
  return advance(x.startIndex, numericCast(n))
}

public func nth<C: CollectionType>(x: C, n: Int) -> C.Generator.Element {
  return x[nthIndex(x, n)]
}

public func checkRangeReplaceable<
  C: RangeReplaceableCollectionType,
  N: CollectionType
where
  C.Generator.Element: Equatable, C.Generator.Element == N.Generator.Element
>(
  makeCollection: ()->C,
  makeNewValues: (Int)->N
) {
  typealias A = C

  // First make an independent copy of the array that we can use for
  // comparison later.
  var source = ContiguousArray<A.Generator.Element>()
  for x in makeCollection() {
    source.append(x)
  }
  
  for (ix, i) in enumerate(indices(source)) {
    for (jx_, j) in enumerate(i..<source.endIndex) {
      let jx = jx_ + ix
      
      let oldCount = jx - ix
      for newCount in 0..<(2 * oldCount) {
        let newValues = makeNewValues(newCount)

        func reportFailure(inout a: A, message: String) {
          println("\(message) when replacing indices \(ix)...\(jx)")
          println("  in \(Array(source)) with \(Array(newValues))")
          println("  yielding \(Array(a))")
          println("====================================")
          expectTrue(false)
        }

        var a = makeCollection()
     
        a.replaceRange(nthIndex(a, ix)..<nthIndex(a, jx), with: newValues)
        let growth = newCount - oldCount
        
        let expectedCount = source.count + growth
        let actualCount = numericCast(countElements(a)) as Int
        if actualCount != expectedCount {
          reportFailure(
            &a, "\(actualCount) != expected count \(expectedCount)")
        }
        
        for (kx, k) in enumerate(indices(a)) {
          let expectedValue = kx < ix ? nth(source, kx)
          : kx < jx + growth ? nth(newValues, kx - ix)
          : nth(source, kx - growth)

          if a[k] != expectedValue {
            reportFailure(
              &a,
              // FIXME: why do we need to break this string into two parts?
              "a[\(kx)] = "
              + "\(a[k]) != expected value \(expectedValue)")
          }
        }
      }
    }
  }
}

public func expectEqualSequence<
  Expected: SequenceType,
  Actual: SequenceType
  where Expected.Generator.Element == Actual.Generator.Element, 
     Expected.Generator.Element: Equatable
>(
    expected: Expected, actual: Actual,
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  expectEqualSequence(
    expected, actual, { $0 == $1 },
    stackTrace: stackTrace, collectMoreInfo: collectMoreInfo,
    file: file, line: line)
}

public func expectEqualSequence<
  Expected: SequenceType,
  Actual: SequenceType
  where Expected.Generator.Element == Actual.Generator.Element
>(
    expected: Expected, actual: Actual,
    sameValue: (Expected.Generator.Element, Expected.Generator.Element)->Bool,
    stackTrace: SourceLocStack? = nil,
    collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !equal(expected, actual, sameValue) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected elements: \"\(expected)\"")
    println("actual: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    if collectMoreInfo != nil { println(collectMoreInfo!()) }
    println()
  }
}

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
