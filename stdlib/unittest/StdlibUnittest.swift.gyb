%# -*- mode: swift -*-

%# Ignore the following admonition; it applies to the resulting .swift file only
//// Automatically Generated From StdlibUnittest.swift.gyb.  Do Not Edit Directly
//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Darwin

var _anyExpectFailed = false

@public func expectEqual<T : Equatable>(
    expected: T, actual: T,
    extraLoc: SourceLoc? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected != actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    if let el = extraLoc {
      println("extra loc: \(el.file), line \(el.line)")
    }
    println("expected: \"\(expected)\" (of type \(_stdlib_getTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getTypeName(expected)))")
    println()
  }
}

@public func expectEqual<T : Equatable>(
    expected: T, actual: T,
    extraLoc: SourceLoc? = nil,
    collectMoreInfo: () -> String,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected != actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    if let el = extraLoc {
      println("extra loc: \(el.file), line \(el.line)")
    }
    println("expected: \"\(expected)\" (of type \(_stdlib_getTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getTypeName(expected)))")
    println(collectMoreInfo())
    println()
  }
}

@public func expectNotEqual<T : Equatable>(
    expected: T, actual: T,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected == actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("unexpected value: \"\(actual)\" (of type \(_stdlib_getTypeName(actual)))")
    println()
  }
}

// Can not write a sane set of overloads using generics because of:
// <rdar://problem/17015923> Array->NSArray implicit conversion insanity
@public func expectOptionalEqual<T : Equatable>(
    expected: T, actual: T?,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !actual || expected != actual! {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\" (of type \(_stdlib_getTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getTypeName(actual)))")
    println()
  }
}

// Array<T> is not Equatable if T is.  Provide additional overloads.
// Same for Dictionary.
%for (Generic, EquatableType) in [
%    ('<T : Equatable>', 'ContiguousArray<T>'),
%    ('<T : Equatable>', 'Slice<T>'),
%    ('<T : Equatable>', 'Array<T>'),
%    ('<T, U : Equatable>', 'Dictionary<T, U>'),
%    ('<T : ForwardIndex>', 'T')]:

@public func expectEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    extraLoc: SourceLoc? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected != actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    if let el = extraLoc {
      println("extra loc: \(el.file), line \(el.line)")
    }
    println("expected: \"\(expected)\" (of type \(_stdlib_getTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getTypeName(actual)))")
    println()
  }
}

@public func expectEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    extraLoc: SourceLoc? = nil,
    collectMoreInfo: () -> String,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected != actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    if let el = extraLoc {
      println("extra loc: \(el.file), line \(el.line)")
    }
    println("expected: \"\(expected)\" (of type \(_stdlib_getTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getTypeName(actual)))")
    println(collectMoreInfo())
    println()
  }
}


func _expectNotEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected == actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("unexpected value: \"\(actual)\" (of type \(_stdlib_getTypeName(actual)))")
    println()
  }
}

%end

%for ComparableType in ['Int']:

@public func expectLE(
    expected: ${ComparableType}, actual: ${ComparableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !(expected <= actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\"")
    println("actual: \"\(actual)\"")
    println()
  }
}

@public func expectGE(
    expected: ${ComparableType}, actual: ${ComparableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !(expected >= actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\"")
    println("actual: \"\(actual)\"")
    println()
  }
}

%end

@public struct AssertionResult : Printable, LogicValue {
  init(isPass: Bool) {
    self._isPass = isPass
  }

  func getLogicValue() -> Bool {
    return _isPass
  }

  func withDescription(description: String) -> AssertionResult {
    var result = self
    result.description += description
    return result
  }

  let _isPass: Bool
  var description: String = ""
}

@public func assertionSuccess() -> AssertionResult {
  return AssertionResult(isPass: true)
}

@public func assertionFailure() -> AssertionResult {
  return AssertionResult(isPass: false)
}

@public struct SourceLoc {
  let file: String
  let line: UWord

  init(_ file: String, _ line: UWord) {
    self.file = file
    self.line = line
  }
}

%for BoolType in ['Bool', 'AssertionResult']:

@public func expectTrue(
    actual: ${BoolType},
    extraLoc: SourceLoc? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    if let el = extraLoc {
      println("extra loc: \(el.file), line \(el.line)")
    }
    println("expected: true")
    println("actual: \(actual)")
    println()
  }
}

@public func expectFalse(
    actual: ${BoolType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: false")
    println("actual: \(actual)")
    println()
  }
}

%end

@public func expectEmpty<T>(
    value: Optional<T>,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if value {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected optional to be empty")
    println("actual: \"\(value)\"")
    println()
  }
}

@public func expectNotEmpty<T>(
    value: Optional<T>,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !value {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected optional to be non-empty")
    println()
  }
}

@public struct TestCase {
  @public init(_ name: String) {
    self.name = name
  }

  @public mutating func test(name: String, testFunction: () -> ()) {
    _tests.append(_Test(name: name, code: testFunction))
  }

  @public mutating func run() {
    var anyTestFailed = false
    for t in _tests {
      var fullTestName = "\(name).\(t.name)"
      println("[ RUN      ] \(fullTestName)")
      _anyExpectFailed = false
      t.code()
      if _anyExpectFailed {
        anyTestFailed = true
        println("[     FAIL ] \(fullTestName)")
      } else {
        println("[       OK ] \(fullTestName)")
      }
    }
    if anyTestFailed {
      println("Some tests failed, aborting")
      abort()
    } else {
      println("\(name): All tests passed")
    }
  }

  struct _Test {
    var name: String
    var code: () -> ()
  }

  var name: String
  var _tests: _Test[] = []
}

// These APIs don't really belong in a unittesting library, but are useful
// in tests, and stdlib does not have such facilities yet.

@public func asHex(a: UInt8[]) -> String {
  return "[ " + ", ".join(a.map { "0x" + String($0, radix: 16) }) + " ]"
}

@public func asHex(a: UInt32[]) -> String {
  return "[ " + ", ".join(a.map { "0x" + String($0, radix: 16) }) + " ]"
}

