//===--- StdlibUnittest.swift.gyb -----------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Darwin

public struct SourceLoc {
  let file: String
  let line: UWord
  let comment: String?

  public
  init(_ file: String, _ line: UWord, comment: String? = nil) {
    self.file = file
    self.line = line
    self.comment = comment
  }

  public
  func withCurrentLoc(
      file: String = __FILE__, line: UWord = __LINE__
  ) -> SourceLocStack {
    return SourceLocStack(self).with(SourceLoc(file, line))
  }
}

public struct SourceLocStack {
  let locs: [SourceLoc] = []

  public
  init() {}

  init(_ loc: SourceLoc) {
    locs = [ loc ]
  }

  init(_locs: [SourceLoc]) {
    locs = _locs
  }

  var isEmpty: Bool {
    return locs.isEmpty
  }

  func with(loc: SourceLoc) -> SourceLocStack {
    var locs = self.locs
    locs.append(loc)
    return SourceLocStack(_locs: locs)
  }

  public
  func withCurrentLoc(
      file: String = __FILE__, line: UWord = __LINE__
  ) -> SourceLocStack {
    return with(SourceLoc(file, line))
  }
}

internal func _printStackTrace(stackTrace: SourceLocStack?) {
  if let s = stackTrace {
    println("stacktrace:")
    for i in 0..<s.locs.count {
      let loc = s.locs[s.locs.count - i - 1]
      let comment = (loc.comment != nil) ? " ; \(loc.comment!)" : ""
      println("  #\(i): \(loc.file):\(loc.line)\(comment)")
    }
  }
}

var _anyExpectFailed = false

public func expectEqual<T : Equatable>(
    expected: T, actual: T,
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  expectEqual(expected, actual, {$0 == $1},
    stackTrace: stackTrace, collectMoreInfo,
    file: file, line: line)
}

public func expectEqual<T>(
    expected: T, actual: T, equal: (T,T)->Bool,
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !equal(expected, actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected: \"\(expected)\" (of type \(_stdlib_getDemangledTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(expected)))")
    if collectMoreInfo != nil { println(collectMoreInfo!()) }
    println()
  }
}

public func expectNotEqual<T : Equatable>(
    expected: T, actual: T,
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected == actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("unexpected value: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    println()
  }
}

// Can not write a sane set of overloads using generics because of:
// <rdar://problem/17015923> Array->NSArray implicit conversion insanity
public func expectOptionalEqual<T : Equatable>(
    expected: T, actual: T?,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if (actual == nil) || expected != actual! {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\" (of type \(_stdlib_getDemangledTypeName(expected)))")
    println("actual: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    println()
  }
}

// Array<T> is not Equatable if T is.  Provide additional overloads.
// Same for Dictionary.
%for (Generic, EquatableType) in [
%    ('<T : Equatable>', 'ContiguousArray<T>'),
%    ('<T : Equatable>', 'Slice<T>'),
%    ('<T : Equatable>', 'Array<T>'),
%    ('<T, U : Equatable>', 'Dictionary<T, U>'),
%    ('<T : ForwardIndexType>', 'T')]:

public func expectEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  expectEqual(
    expected, actual,
    // FIXME: Simpler closures don't work here due to
    // <rdar://problem/17716712> and <rdar://problem/17717618>
    { (x: ${EquatableType}, y: ${EquatableType})->Bool in  x == y },
    stackTrace: stackTrace, collectMoreInfo, 
    file: file, line: line)
}


func _expectNotEqual${Generic}(
    expected: ${EquatableType}, actual: ${EquatableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if expected == actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("unexpected value: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    println()
  }
}

%end

%for ComparableType in ['Int']:

public func expectLE(
    expected: ${ComparableType}, actual: ${ComparableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !(expected <= actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\"")
    println("actual: \"\(actual)\"")
    println()
  }
}

public func expectGE(
    expected: ${ComparableType}, actual: ${ComparableType},
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !(expected >= actual) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected: \"\(expected)\"")
    println("actual: \"\(actual)\"")
    println()
  }
}

%end

public struct AssertionResult : Printable, BooleanType {
  init(isPass: Bool) {
    self._isPass = isPass
  }

  public var boolValue: Bool {
    return _isPass
  }

  public func withDescription(description: String) -> AssertionResult {
    var result = self
    result.description += description
    return result
  }

  let _isPass: Bool
  
  public
  var description: String = ""
}

public func assertionSuccess() -> AssertionResult {
  return AssertionResult(isPass: true)
}

public func assertionFailure() -> AssertionResult {
  return AssertionResult(isPass: false)
}

%for BoolType in ['Bool', 'AssertionResult']:

public func expectTrue(
    actual: ${BoolType},
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected: true")
    println("actual: \(actual)")
    println()
  }
}

public func expectFalse(
    actual: ${BoolType},
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if actual {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected: false")
    println("actual: \(actual)")
    println()
  }
}

%end

public func expectEmpty<T>(
    value: Optional<T>,
    stackTrace: SourceLocStack? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if value != nil {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected optional to be empty")
    println("actual: \"\(value)\"")
    println()
  }
}

public func expectNotEmpty<T>(
    value: Optional<T>,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if value == nil {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    println("expected optional to be non-empty")
    println()
  }
}

public struct TestCase {
  public init(_ name: String) {
    self.name = name
  }

  public mutating func test(name: String, testFunction: () -> ()) {
    _tests.append(_Test(name: name, code: testFunction))
  }

  public mutating func run() {
    var anyTestFailed = false
    for t in _tests {
      var fullTestName = "\(name).\(t.name)"
      println("[ RUN      ] \(fullTestName)")
      _anyExpectFailed = false
      t.code()
      if _anyExpectFailed {
        anyTestFailed = true
        println("[     FAIL ] \(fullTestName)")
      } else {
        println("[       OK ] \(fullTestName)")
      }
    }
    if anyTestFailed {
      println("Some tests failed, aborting")
      abort()
    } else {
      println("\(name): All tests passed")
    }
  }

  struct _Test {
    var name: String
    var code: () -> ()
  }

  var name: String
  var _tests: [_Test] = []
}

// These APIs don't really belong in a unittesting library, but are useful
// in tests, and stdlib does not have such facilities yet.

public func asHex(a: [UInt8]) -> String {
  return "[ " + ", ".join(a.map { "0x" + String($0, radix: 16) }) + " ]"
}

public func asHex(a: [UInt32]) -> String {
  return "[ " + ", ".join(a.map { "0x" + String($0, radix: 16) }) + " ]"
}

//
// Helpers that verify invariants of various stdlib types.
//

public func checkHashable<T : Hashable>(
  expectedEqual: Bool, lhs: T, rhs: T, stackTrace: SourceLocStack,
  _ collectMoreInfo: (()->String)? = nil
) {
  // Test operator '==' that is found through witness tables.
  expectEqual(
    expectedEqual, lhs == rhs, stackTrace: stackTrace, collectMoreInfo)
  expectEqual(
    !expectedEqual, lhs != rhs, stackTrace: stackTrace, collectMoreInfo)

  // Test 'hashValue'.
  //
  // If objects are not equal, then the hash value can be different or it can
  // collide.
  if expectedEqual {
    expectEqual(lhs.hashValue, rhs.hashValue)
  }
}

public func checkHashable<T : Hashable>(
  expectedEqual: Bool, lhs: T, rhs: T,
  _ collectMoreInfo: (()->String)? = nil,
  file: String = __FILE__, line: UWord = __LINE__
) {
  checkHashable(
    expectedEqual, lhs, rhs, SourceLocStack(SourceLoc(file, line)),
    collectMoreInfo)
}

public enum ExpectedComparisonResult {
  case LT, EQ, GT

  public func isLT() -> Bool {
    return self == .LT
  }

  public func isEQ() -> Bool {
    return self == .EQ
  }

  public func isGT() -> Bool {
    return self == .GT
  }

  public func isLE() -> Bool {
    return isLT() || isEQ()
  }

  public func isGE() -> Bool {
    return isGT() || isEQ()
  }

  public func isNE() -> Bool {
    return !isEQ()
  }

  public func flip() -> ExpectedComparisonResult {
    switch self {
    case .LT:
      return .GT
    case .EQ:
      return .EQ
    case .GT:
      return .LT
    }
  }
}

public func checkComparable<T : Comparable>(
  expected: ExpectedComparisonResult,
  lhs: T, rhs: T, stackTrace: SourceLocStack
) {
  expectEqual(expected.isLT(), lhs < rhs, stackTrace: stackTrace)
  expectEqual(expected.isLE(), lhs <= rhs, stackTrace: stackTrace)
  expectEqual(expected.isGE(), lhs >= rhs, stackTrace: stackTrace)
  expectEqual(expected.isGT(), lhs > rhs, stackTrace: stackTrace)
}

public func checkComparable<T : Comparable>(
  expected: ExpectedComparisonResult,
  lhs: T, rhs: T,
  file: String = __FILE__, line: UWord = __LINE__
) {
  checkComparable(expected, lhs, rhs, SourceLocStack(SourceLoc(file, line)))
}

public
func checkGenerator<
    Element : Equatable, G : GeneratorType
    where G.Element == Element>(
    expected: [Element], generator: G, stackTrace: SourceLocStack) {

  // Copying a `GeneratorType` is allowed.
  var mutableGen = generator
  var actual: [Element] = []
  while let e = mutableGen.next() {
    actual.append(e)
  }
  expectEqual(expected, actual, stackTrace: stackTrace.withCurrentLoc())

  // Having returned `.None` once, a `GeneratorType` should not generate more
  // elements.
  for i in 0..<10 {
    expectEmpty(mutableGen.next(), stackTrace: stackTrace.withCurrentLoc())
  }
}

public
func checkSequence<
    Element : Equatable, S : SequenceType
    where S.Generator.Element == Element>(
    expected: [Element], sequence: S, stackTrace: SourceLocStack) {
  checkGenerator(expected, sequence.generate(), stackTrace.withCurrentLoc())
  expectGE(expected.count, underestimateCount(sequence))
}

public
func checkCollection<
    Element : Equatable, C : CollectionType
    where C.Generator.Element == Element>(
    expected: [Element], collection: C, stackTrace: SourceLocStack) {
  // A `CollectionType` is a multi-pass `SequenceType`.
  for i in 0..<3 {
    checkSequence(expected, collection, stackTrace.withCurrentLoc())
  }

  expectEqual(expected.count.toIntMax(), countElements(collection).toIntMax(),
      stackTrace: stackTrace.withCurrentLoc())

  for i in 0..<3 {
    let startIndex = collection.startIndex
    let endIndex = collection.endIndex

    var actual: [Element] = []
    var index = collection.startIndex
    while index != collection.endIndex {
      // Iteration should not change `startIndex` or `endIndex`.
      expectEqual(startIndex, collection.startIndex)
      expectEqual(endIndex, collection.endIndex)

      actual.append(collection[index])
      ++index
    }

    expectEqual(expected, actual, stackTrace: stackTrace.withCurrentLoc())
  }
}

public
func checkSliceableWithBidirectionalIndex<
    Element : Equatable, S : Sliceable
    where S.Generator.Element == Element,
    S.SubSlice.Generator.Element == Element,
    S.Index : BidirectionalIndexType>(
    expected: [Element], sliceable: S, stackTrace: SourceLocStack) {
  // A `Sliceable` is a `CollectionType`.
  checkCollection(expected, sliceable, stackTrace.withCurrentLoc())

  var start = sliceable.startIndex
  for startNumericIndex in 0...expected.count {
    if start != sliceable.endIndex {
      ++start
      --start
      ++start
      --start
    }
    var end = start
    for endNumericIndex in startNumericIndex...expected.count {
      if end != sliceable.endIndex {
        ++end
        --end
        ++end
        --end
      }
      let expectedSlice: [Element] =
          Array(expected[startNumericIndex..<endNumericIndex])
      let slice = sliceable[start..<end]
      checkCollection(expectedSlice, slice, stackTrace.withCurrentLoc())

      if end != sliceable.endIndex {
        ++end
      }
    }
    if start != sliceable.endIndex {
      ++start
    }
  }
}

public func nthIndex<C: CollectionType>(x: C, n: Int) -> C.Index {
  return advance(x.startIndex, numericCast(n))
}

public func nth<C: CollectionType>(x: C, n: Int) -> C.Generator.Element {
  return x[nthIndex(x, n)]
}

public func checkRangeReplaceable<
  C: RangeReplaceableCollectionType,
  N: CollectionType
where
  C.Generator.Element: Equatable, C.Generator.Element == N.Generator.Element
>(
  makeCollection: ()->C,
  makeNewValues: (Int)->N
) {
  typealias A = C

  // First make an independent copy of the array that we can use for
  // comparison later.
  var source = ContiguousArray<A.Generator.Element>()
  for x in makeCollection() {
    source.append(x)
  }
  
  for (ix, i) in enumerate(indices(source)) {
    for (jx_, j) in enumerate(i..<source.endIndex) {
      let jx = jx_ + ix
      
      let oldCount = jx - ix
      for newCount in 0..<(2 * oldCount) {
        let newValues = makeNewValues(newCount)

        func reportFailure(inout a: A, message: String) {
          println("\(message) when replacing indices \(ix)...\(jx)")
          println("  in \(Array(source)) with \(Array(newValues))")
          println("  yielding \(Array(a))")
          println("====================================")
          expectTrue(false)
        }

        var a = makeCollection()
     
        a.replaceRange(nthIndex(a, ix)..<nthIndex(a, jx), with: newValues)
        let growth = newCount - oldCount
        
        let expectedCount = source.count + growth
        let actualCount = numericCast(countElements(a)) as Int
        if actualCount != expectedCount {
          reportFailure(
            &a, "\(actualCount) != expected count \(expectedCount)")
        }
        
        for (kx, k) in enumerate(indices(a)) {
          let expectedValue = kx < ix ? nth(source, kx)
          : kx < jx + growth ? nth(newValues, kx - ix)
          : nth(source, kx - growth)

          if a[k] != expectedValue {
            reportFailure(
              &a,
              // FIXME: why do we need to break this string into two parts?
              "a[\(kx)] = "
              + "\(a[k]) != expected value \(expectedValue)")
          }
        }
      }
    }
  }
}

public func expectEqualSequence<
  Expected: SequenceType,
  Actual: SequenceType
  where Expected.Generator.Element == Actual.Generator.Element, 
     Expected.Generator.Element: Equatable
>(
    expected: Expected, actual: Actual,
    stackTrace: SourceLocStack? = nil,
    _ collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  expectEqualSequence(
    expected, actual, { $0 == $1 },
    stackTrace: stackTrace, collectMoreInfo: collectMoreInfo,
    file: file, line: line)
}

public func expectEqualSequence<
  Expected: SequenceType,
  Actual: SequenceType
  where Expected.Generator.Element == Actual.Generator.Element
>(
    expected: Expected, actual: Actual,
    sameValue: (Expected.Generator.Element, Expected.Generator.Element)->Bool,
    stackTrace: SourceLocStack? = nil,
    collectMoreInfo: (()->String)? = nil,
    file: String = __FILE__, line: UWord = __LINE__
) {
  if !equal(expected, actual, sameValue) {
    _anyExpectFailed = true
    println("check failed at \(file), line \(line)")
    _printStackTrace(stackTrace)
    println("expected elements: \"\(expected)\"")
    println("actual: \"\(actual)\" (of type \(_stdlib_getDemangledTypeName(actual)))")
    if collectMoreInfo != nil { println(collectMoreInfo!()) }
    println()
  }
}

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
