//===--- Reverse.swift.gyb - Lazy sequence reversal -----------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


/// Return an `Array` containing the elements of `source` in reverse
/// order.
public func reverse<C:Collection where C.IndexType: BidirectionalIndex>(
  source: C
) -> [C.GeneratorType.Element] {
  return lazy(source).reverse().array
}


% for traversal in ('Bidirectional', 'RandomAccess'):
%   View = '%sReverseView' % traversal
%   Self = 'Lazy%sCollection' % traversal
%   Index = 'Reverse%sIndex' % traversal
%   IndexProtocol = '%sIndex' % traversal

/// A wrapper for a `${IndexProtocol}` that reverses its
/// direction of traversal
public struct ${Index}<I: ${IndexProtocol}> : ${IndexProtocol} {
  var _base: I

  init(_ _base: I) { self._base = _base }

  public func successor() -> ${Index} {
    return ${Index}(_base.predecessor())
  }
  
  public func predecessor() -> ${Index} {
    return ${Index}(_base.successor())
  }
  
  typealias DistanceType = I.DistanceType
  
%   if traversal == 'RandomAccess':
  public func distanceTo(other: ${Index}) -> DistanceType {
    return other._base.distanceTo(_base)
  }
  
  public func advancedBy(amount: DistanceType) -> ${Index} {
    return ${Index}(_base.advancedBy(-amount))
  }
%   end
}

public func == <I> (lhs: ${Index}<I>, rhs: ${Index}<I>) -> Bool {
  return lhs._base == rhs._base
}

/// The lazy `Collection` returned by `reverse(c)` where `c` is a
/// `Collection` with an `IndexType` conforming to `${IndexProtocol}`
public struct ${View}<
  T: Collection where T.IndexType: ${IndexProtocol}
> : Collection {
  public typealias IndexType = ${Index}<T.IndexType>
  public typealias GeneratorType = IndexingGenerator<${View}>

  init(_ _base: T) {
    self._base = _base 
  }

  public func generate() -> IndexingGenerator<${View}> {
    return IndexingGenerator(self)
  }
  
  public var startIndex: IndexType {
    return ${Index}(_base.endIndex)
  }
  
  public var endIndex: IndexType {
    return ${Index}(_base.startIndex)
  }

  public subscript(i: IndexType) -> T.GeneratorType.Element {
    return _base[i._base.predecessor()]
  }
  
  var _base: T
}

extension ${Self} {
  /// Return a `${View}` over this `${Self}`.  The elements of
  /// the result are computed lazily, each time they are read, by
  /// calling `transform` function on a base element.
  public
  func reverse() -> LazyBidirectionalCollection<${View}<S>> {
    return LazyBidirectionalCollection<${View}<S>>(
      ${View}<S>(self._base)
    )
  }
}

% end

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
