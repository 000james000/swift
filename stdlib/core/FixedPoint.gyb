@# -*- mode: swift -*-

@# Ignore the following admonition; it applies to the resulting .swift file only
//// Automatically Generated From FixedPoint.gyb.  Do Not Edit Directly ////
//// To regenerate:                                                     ////
////         ../../utils/gyb FixedPoint.gyb -o FixedPoint.swift         ////
@{
#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)


# Bit counts for all int types
#allBits = [8, 16, 32, 64, 'Word']
allBits = [8, 16, 32, 64]

# Number of bits in the biggest int type
maxBits = max(allBits)

# Number of bits in an Int
intBits = 64

# Number of bits in integer literals.
builtinIntLiteralBits = 2048

assert(intBits in allBits)

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

def allInts():
    for bits in allBits:
        for signed in False, True:
            yield bits,signed

def baseIntName(bits):
    return 'Word' if bits == 'Word' else ('Int' + str(bits))

def intName(bits, signed):
    return ('' if signed else 'U') + baseIntName(bits)

def otherIntName(bits, signed):
    return ('U' if signed else '') + baseIntName(bits)
}@

@ for (bits, signed) in allInts():
@   sign = 's' if signed else 'u'
@   Self = intName(bits, signed)
@   OtherSelf = otherIntName(bits, signed)
@   LLVMName = 'Word' if bits == 'Word' else baseIntName(bits)
@   ArrayBound = 'ArrayBound, ' if bits <= 64 or bits == 'Word' else ''

struct ${Self} : BuiltinIntegerLiteralConvertible, IntegerLiteralConvertible,
                ${ArrayBound}ReplPrintable {
  var value: Builtin.${LLVMName}

  @@transparent
  init() {
    var maxWidthZero: Int${str(maxBits)} = 0
    value = ${'maxWidthZero.value' if bits == maxBits else ('Builtin.trunc_Int%d_%s(maxWidthZero.value)' % (maxBits, LLVMName) )}
  }

  @@transparent
  init(v: Builtin.${LLVMName}) {
    value = v
  }

  @@transparent
  type func _convertFromBuiltinIntegerLiteral(val: Builtin.Int${builtinIntLiteralBits}) -> ${Self} {
    return ${Self}(Builtin.s_to_${sign}_checked_trunc_Int${builtinIntLiteralBits}_${LLVMName}(val).0)
  }

  @@transparent
  type func convertFromIntegerLiteral(value: ${Self}) -> ${Self} {
    return value
  }
@ if ArrayBound:
  @@transparent
  func _getBuiltinArrayBoundValue() -> Builtin.Word {
    return Word(self).value
  }

  typealias ArrayBoundType = ${Self}
  func getArrayBoundValue() -> ${Self} {
    return self
  }
@ else:

@ end
  func replPrint() {
    print(${
      'self' if bits == 64
      else (('String' if bits > 64 else 'Int64' if signed else 'UInt64') + '(self)')})
  }

@ if bits != 'Word':
@   max = maskBits((bits - 1) if signed else bits)
  @@transparent
  type var max: ${Self} { return ${max} }
  @@transparent
  type var min: ${Self} { return ${'-%s-1' % max if signed else '0'} }
@ else:
  @@transparent
  type var max: ${Self} { return ${'~(1 << (sizeof(Int) * 8 - 1))' if signed else '~0'} }
  @@transparent
  type var min: ${Self} { return ${'-(1 << (sizeof(Int) * 8 - 1))' if signed else '0'} }
@ end
}

extension ${Self} : Hashable {
  func hashValue() -> Int {
@ if Self == 'Int' or Self == 'Int64':  # hack! remove when Int == Word
    return self
@ elif bits != 'Word' and bits <= 32:
    return Int(self)
@ else:
    if sizeof(self) <= sizeof(Int) {
      return Int(self)
    }
    var result: Int = 0

    for var i = 0; i < (sizeof(self) * 8); i += sizeof(Int) * 8 {
      result ^= Int(self >> ${Self}(i)) & ~0
    }
    return result
@ end
  }
}

@@transparent
extension ${Self} : RandomAccessIndex {
  @@transparent
  func succ() -> ${Self} {
    return self + 1
  }
  @@transparent
  func pred() -> ${Self} {
    return self - 1
  }
  typealias DistanceType = ${Self}
  @@transparent
  type func sub(lhs: ${Self}, rhs: ${Self}, reportOverflow: Bool) -> (DistanceType, Bool) {
    var tmp = Builtin.${sign}sub_with_overflow_${LLVMName}(lhs.value, rhs.value, reportOverflow.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }
  @@transparent
  type func add(lhs: ${Self}, rhs: DistanceType, reportOverflow: Bool) -> (${Self}, Bool) {
    var tmp = Builtin.${sign}add_with_overflow_${LLVMName}(lhs.value, rhs.value, reportOverflow.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }
  @@transparent
  type func mul(lhs: ${Self}, rhs: ${Self}, reportOverflow: Bool) -> (${Self}, Bool) {
    var tmp = Builtin.${sign}mul_with_overflow_${LLVMName}(lhs.value, rhs.value, reportOverflow.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }
  @@transparent
  type func div(lhs: ${Self}, rhs: ${Self}, reportOverflow: Bool) -> (${Self}, Bool) {
    if rhs == 0 {
      return (0, true)
    }
@ if signed:
    if lhs == ${Self}.min && rhs == -1 {
      return (lhs, true)
    }
@ end
    var tmp = Builtin.${sign}div_${LLVMName}(lhs.value, rhs.value)
    return (${Self}(tmp), false)
  }
  @@transparent
  type func rem(lhs: ${Self}, rhs: ${Self}, reportOverflow: Bool) -> (${Self}, Bool) {
    if rhs == 0 {
      return (0, true)
    }
@ if signed:
    if lhs == ${Self}.min && rhs == -1 {
      return (0, true)
    }
@ end
    var tmp = Builtin.${sign}rem_${LLVMName}(lhs.value, rhs.value)
    return (${Self}(tmp), false)
  }

  @@transparent
  type func sub(lhs: ${Self}, rhs: ${Self}) -> (DistanceType, Bool) {
    return sub(lhs, rhs, true)
  }
  @@transparent
  type func add(lhs: ${Self}, rhs: DistanceType) -> (${Self}, Bool) {
    return add(lhs, rhs, true)
  }
  @@transparent
  type func mul(lhs: ${Self}, rhs: ${Self}) -> (${Self}, Bool) {
    return mul(lhs, rhs, true)
  }
  @@transparent
  type func div(lhs: ${Self}, rhs: ${Self}) -> (${Self}, Bool) {
    return div(lhs, rhs, true)
  }
  @@transparent
  type func rem(lhs: ${Self}, rhs: ${Self}) -> (${Self}, Bool) {
    return rem(lhs, rhs, true)
  }
}

@ if signed:
@@transparent
extension ${Self} : SignedNumber {
  @@transparent
  type func negate(rhs: ${Self}) -> (${Self}, Bool) {
    return ${Self}.sub(0, rhs)
  }
  @@transparent
  type func abs(rhs: ${Self}) -> (${Self}, Bool) {
    return rhs.isNegative() ? ${Self}.negate(rhs) : (rhs, false)
  }
  @@transparent
  func isNegative() -> Bool { return self < 0 }
}
@ end

// construction from other integer types
@@transparent
extension ${Self} {
@ for (srcBits, srcSigned) in allInts():
@    That = intName(srcBits, srcSigned)
@    ThatLLVMName = 'Word' if srcBits == 'Word' else baseIntName(srcBits)
@    srcSign = 's' if srcSigned else 'u'
@    if Self != That:
  init(v: ${That}) {
@      if bits == srcBits:
    var tmp = Builtin.${srcSign}_to_${sign}_checked_conversion_${LLVMName}(v.value)
    Builtin.condfail(tmp.1)
    value = tmp.0
@      end
@      if srcBits > bits:
    var tmp = Builtin.${srcSign}_to_${sign}_checked_trunc_${ThatLLVMName}_${LLVMName}(v.value)
    Builtin.condfail(tmp.1)
    value = tmp.0
@      end
@      if srcBits < bits:
@         if srcSigned and not signed:
    var tmp = Builtin.s_to_u_checked_conversion_Int${srcBits}(v.value)
    Builtin.condfail(tmp.1)
    value = Builtin.zext_Int${srcBits}_${LLVMName}(tmp.0)
@         else:
    value = Builtin.${
    ('sext' if srcSigned else 'zext')
    }_Int${srcBits}_${LLVMName}(v.value)
@         end
@      end
  }
@    end
@ end
  func as${'Unsigned' if signed else 'Signed'}() -> ${OtherSelf} {
    return ${OtherSelf}(value)
  }
}

// Operations with masking and non-masking versions
@ for op,method in ('+','add'), ('*','mul'), ('-','sub'):
@@transparent
func &${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  return ${Self}.${method}(lhs, rhs, false).0
}
@@transparent
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  var tmp = ${Self}.${method}(lhs, rhs)
  Builtin.condfail(tmp.1.value)
  return tmp.0
}
@ end

// Bitwise negate
@@transparent @@prefix
func ~(rhs: ${Self}) -> ${Self} {
  let mask = ${Self}.sub(0, 1).0
  return ${Self}(Builtin.xor_${LLVMName}(rhs.value, mask.value))
}

@ for op, name in (
@  ('==','eq'), ('!=','ne'),
@  ('<',sign+'lt'), ('<=',sign+'le'),
@  ('>',sign+'gt'), ('>=',sign+'ge')):
@@transparent
func ${op} (lhs: ${Self}, rhs: ${Self}) -> Bool {
  return Bool(Builtin.cmp_${name}_${LLVMName}(lhs.value, rhs.value))
}
@ end

@ for op, name in (
@  ('<<','shl'), ('>>','ashr' if signed else 'lshr'),
@  ('&','and'), ('^','xor'), ('|','or')):
@@transparent
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  return ${Self}(Builtin.${name}_${LLVMName}(lhs.value, rhs.value))
}
@ end

// bitwise operations
@@transparent
extension ${Self} : BitwiseOperations {
  type func allZeros() -> ${Self} { return 0 }
}

// Compound assignments
@ for op in '+', '-', '*', '<<', '>>', '&', '|', '^':
@@transparent @@assignment
func ${op}=(lhs: @@inout ${Self}, rhs: ${Self}) {
  lhs = lhs ${op} rhs
}
@ end
@ end  # for bits in allInts
