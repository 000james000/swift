@# -*- mode: swift -*-

@# Ignore the following admonition; it applies to the resulting .swift file only
//// Automatically Generated From FixedPoint.gyb.  Do Not Edit Directly ////
//// To regenerate:                                                     ////
////         ../../utils/gyb FixedPoint.gyb -o FixedPoint.swift         ////
@{
#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)


# Bit counts for all int types
allBits = [8, 16, 32, 64]

# Number of bits in the biggest int type
maxBits = max(allBits)

# Number of bits in an Int
intBits = 64

# Number of bits in integer literals.
builtinIntLiteralBits = 2048

assert(intBits in allBits)

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

def allInts():
    for bits in allBits:
        for signed in False, True:
            yield bits,signed

def intName(bits, signed):
    return ('' if signed else 'U') + 'Int' + str(bits)
}@

@ for (bits, signed) in allInts():
@   sign = 's' if signed else 'u'
@   Self = intName(bits, signed)
@   ArrayBound = 'ArrayBound, ' if bits > 8 and bits < 128 else ''

struct ${Self} : BuiltinIntegerLiteralConvertible, IntegerLiteralConvertible,
                ${ArrayBound}ReplPrintable {
  var value: Builtin.Int${bits}

  @@transparent
  init() {
    var maxWidthZero: Int${str(maxBits)} = 0
    value = ${'maxWidthZero.value' if bits == maxBits else ('Builtin.trunc_Int%d_Int%d(maxWidthZero.value)' % (maxBits, bits) )}
  }

  @@transparent
  init(v: Builtin.Int${bits}) {
    value = v
  }

  @@transparent
  static func _convertFromBuiltinIntegerLiteral(val: Builtin.Int${builtinIntLiteralBits}) -> ${Self} {
    return ${Self}(Builtin.s_to_${sign}_checked_trunc_Int${builtinIntLiteralBits}_Int${bits}(val).0)
  }

  @@transparent
  static func convertFromIntegerLiteral(value: ${Self}) -> ${Self} {
    return value
  }
@ if ArrayBound:
  @@transparent
  func _getBuiltinArrayBoundValue() -> Builtin.Int${bits} {
    return value
  }

  typealias ArrayBoundType = ${Self}
  func getArrayBoundValue() -> ${Self} {
    return self
  }
@ else:

@ end
  func replPrint() {
    print(${
      'self' if bits == 64
      else (('String' if bits > 64 else 'Int64' if signed else 'UInt64') + '(self)')})
  }

@ max = maskBits((bits - 1) if signed else bits)
  // FIXME: these should be static vars when supported
  static func max() -> ${Self} { return ${max} }
  static func min() -> ${Self} { return ${'-%s-1' % max if signed else '0'} }
}

extension ${Self} : Hashable {
  func hashValue() -> Int {
@{
if bits <= intBits:
    hashValue = 'Int(self)'
else:
    # count of ints needed to represent this type
    ints = (bits + intBits - 1) / intBits

    # accumulate the high word
    i = ints - 1
    hashValue = 'Int(self >> %s)' % (i * intBits)

    # accumulate middle words; these require shift + mask
    while i > 1:
        i = i-1
        hashValue += ' ^ Int((self >> %d) & %s)' % (
                      intBits * i, maskBits(intBits))

    # accumulate the low word; requires only a mask
    hashValue += ' ^ Int(self & %s)' % maskBits(intBits)
}@
    return ${hashValue}
  }
}

@@transparent
extension ${Self} : RandomAccessIndex {
  func __equal__(rhs: ${Self}) -> Bool {
    return Bool(Builtin.cmp_eq_Int${bits}(value, rhs.value))
  }
  func __less__(rhs: ${Self}) -> Bool {
    return Bool(Builtin.cmp_${sign}lt_Int${bits}(value, rhs.value))
  }
  func succ() -> ${Self} {
    return self + 1
  }
  func pred() -> ${Self} {
    return self - 1
  }
  typealias DistanceType = ${Self}
  static func sub(lhs: ${Self}, rhs: ${Self}, reportOverflow: Bool) -> (DistanceType, Bool) {
    var tmp = Builtin.${sign}sub_with_overflow_Int${bits}(lhs.value, rhs.value, reportOverflow.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }
  static func add(lhs: ${Self}, rhs: DistanceType, reportOverflow: Bool) -> (${Self}, Bool) {
    var tmp = Builtin.${sign}add_with_overflow_Int${bits}(lhs.value, rhs.value, reportOverflow.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }
  static func mul(lhs: ${Self}, rhs: ${Self}, reportOverflow: Bool) -> (${Self}, Bool) {
    var tmp = Builtin.${sign}mul_with_overflow_Int${bits}(lhs.value, rhs.value, reportOverflow.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }

  static func sub(lhs: ${Self}, rhs: ${Self}) -> (DistanceType, Bool) {
    return sub(lhs, rhs, true)
  }
  static func add(lhs: ${Self}, rhs: DistanceType) -> (${Self}, Bool) {
    return add(lhs, rhs, true)
  }
  static func mul(lhs: ${Self}, rhs: ${Self}) -> (${Self}, Bool) {
    return mul(lhs, rhs, true)
  }
}

@ if signed:
extension ${Self} : SignedNumber {
  static func negate(rhs: ${Self}) -> (${Self}, Bool) { return ${Self}.sub(0, rhs) }
  func isNegative() -> Bool { return self < 0 }
}
@ end

// construction from other integer types
@@transparent
extension ${Self} {
@ for (srcBits, srcSigned) in allInts():
@    That = intName(srcBits, srcSigned)
@    srcSign = 's' if srcSigned else 'u'
@    if Self != That:
  init(v: ${That}) {
@      if bits == srcBits:
    var tmp = Builtin.${srcSign}_to_${sign}_checked_conversion_Int${bits}(v.value)
    Builtin.condfail(tmp.1)
    value = tmp.0
@      end
@      if srcBits > bits:
    var tmp = Builtin.${srcSign}_to_${sign}_checked_trunc_Int${srcBits}_Int${bits}(v.value)
    Builtin.condfail(tmp.1)
    value = tmp.0
@      end
@      if srcBits < bits:
@         if srcSigned and not signed:
    var tmp = Builtin.s_to_u_checked_conversion_Int${srcBits}(v.value)
    Builtin.condfail(tmp.1)
    value = Builtin.zext_Int${srcBits}_Int${bits}(tmp.0)
@         else:
    value = Builtin.${
    ('sext' if srcSigned else 'zext')
    }_Int${srcBits}_Int${bits}(v.value)
@         end
@      end
  }
@    end
@ end
  func as${'Unsigned' if signed else 'Signed'}() -> ${'U' if signed else ''}Int${bits} {
    return ${'U' if signed else ''}Int${bits}(value)
  }
}

// Unary plus
@@transparent @@prefix
func +(rhs: ${Self}) -> ${Self} { return rhs }

// Operations with masking and non-masking versions
@ for op,method in ('+','add'), ('*','mul'), ('-','sub'):
@@transparent
func &${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  return ${Self}.${method}(lhs, rhs, false).0
}
@@transparent
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  var tmp = ${Self}.${method}(lhs, rhs)
  Builtin.condfail(tmp.1.value)
  return tmp.0
}
@ end

// Bitwise negate
@@transparent @@prefix
func ~(rhs: ${Self}) -> ${Self} {
  var mask = ${'Builtin.trunc_Int%d_Int%d(%s.value)' % (maxBits, bits, maskBits(bits))
             if maxBits != bits else
               'UInt64(%s).value' % (maskBits(bits))}
  return ${Self}(Builtin.xor_Int${bits}(rhs.value, mask))
}

@ for op, name in (
@  ('==','eq'), ('!=','ne'),
@  ('<',sign+'lt'), ('<=',sign+'le'),
@  ('>',sign+'gt'), ('>=',sign+'ge')):
@@transparent
func ${op} (lhs: ${Self}, rhs: ${Self}) -> Bool {
  return Bool(Builtin.cmp_${name}_Int${bits}(lhs.value, rhs.value))
}
@ end

@ for op, name in (
@  ('/',sign+'div'), ('%',sign+'rem'),
@  ('<<','shl'), ('>>','ashr' if signed else 'lshr'),
@  ('&','and'), ('^','xor'), ('|','or')):
@@transparent
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  return ${Self}(Builtin.${name}_Int${bits}(lhs.value, rhs.value))
}
@ end

// Compound assignments
@ for op in '+', '-', '*', '/', '%', '<<', '>>', '&', '|', '^':
@@transparent @@assignment
func ${op}=(lhs: @@inout ${Self}, rhs: ${Self}) {
  lhs = lhs ${op} rhs
}
@ end
@ end  # for bits in allInts

// FIXME: rdar://14897572
// hack to make non-x86 architectures build at a reasonable speed
struct Hack14897572 { }
extension UInt32 {
  init(_: Hack14897572) {
    value = UInt32(0).value
  }
}
