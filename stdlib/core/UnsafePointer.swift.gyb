//===--- UnsafePointer.swift.gyb ------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%import gyb
%TMirrorDecl = gyb.parseTemplate("../common/MirrorDecl.gyb")
%TMirrorConformance = gyb.parseTemplate("../common/MirrorConformance.gyb")
%TMirrorBoilerplate = gyb.parseTemplate("../common/MirrorBoilerplate.gyb")

% for mutable in (True, False):
%  Self = 'UnsafeMutablePointer' if mutable else 'UnsafePointer'
%  a_Self = 'an `UnsafeMutablePointer`' if mutable else 'an `UnsafePointer`'
%  MirrorConformance = gyb.executeTemplate(TMirrorConformance,introspecteeType=Self,genericArgs=['T'],disposition='Struct')
%  MirrorDecl = gyb.executeTemplate(TMirrorDecl,introspecteeType=Self,genericArgs=['T'],disposition='Struct')
%  MirrorBoilerplate = gyb.executeTemplate(TMirrorBoilerplate,introspecteeType=Self,genericArgs=['T'],disposition='Struct')

/// A pointer to an object of type `T`.  This type provides no automated
/// memory management, and therefore the user must take care to allocate
/// and free memory appropriately.
///
/// The pointer can be in one of the following states:
///
/// - memory is not allocated (for example, pointer is null, or memory has
/// been deallocated previously);
///
/// - memory is allocated, but value has not been initialized;
///
/// - memory is allocated and value is initialized.
public struct ${Self}<T>
  : RandomAccessIndexType, Hashable,
    NilLiteralConvertible, _PointerType {

  /// The underlying raw (untyped) pointer.
  var value : Builtin.RawPointer

  /// Construct a null pointer.
  @transparent
  public init() {
    self.value = Builtin.inttoptr_Word(0.value)
  }

  /// Construct ${a_Self} from a builtin raw pointer.
  @transparent
  public init(_ value : Builtin.RawPointer) {
    self.value = value
  }

  /// Convert from an opaque C pointer to a typed pointer
  ///
  /// This is a fundamentally unsafe conversion.
  @transparent
  public init(_ other : COpaquePointer) {
    value = other.value
  }

  /// Construct ${a_Self} from a given address in memory.
  ///
  /// This is a fundamentally unsafe conversion.
  @transparent
  public init(bitPattern: Word) {
    self.value = Builtin.inttoptr_Word(bitPattern.value)
  }

  /// Construct ${a_Self} from a given address in memory.
  ///
  /// This is a fundamentally unsafe conversion.
  @transparent
  public init(bitPattern: UWord) {
    self.value = Builtin.inttoptr_Word(bitPattern.value)
  }

  /// Return ${a_Self}\ `<U>` that points the same memory address
  /// as `self`.  Requires: `self` is properly aligned for an object
  /// of type `U`.
  ///
  /// This is a fundamentally unsafe conversion.
  @transparent
  public func asPointerTo<U>(_: U.Type) -> ${Self}<U> {
    _debugPrecondition(
      unsafeBitCast(self.value, UInt.self) % UInt(alignof(U.self)) == 0,
      "Attempt to create pointer to improperly-aligned address"
    )
    return ${Self}<U>(self.value)
  }

  // Make nil work with ${Self}.
  @transparent public
  static func convertFromNilLiteral() -> ${Self}<T> {
    return .null()
  }

  @transparent
  public static func null() -> ${Self} {
    return ${Self}()
  }

%  if mutable:
  /// Allocate memory for `num` objects of type `T`.
  ///
  /// Postcondition: the memory is allocated, but not initialized.
  public static func alloc(num: Int) -> ${Self} {
    // Don't bother with overflow checking.
    var size = strideof(T.self) * num
    return ${Self}(Builtin.allocRaw(size.value, Builtin.alignof(T.self)))
  }

  /// Deallocate `num` objects.
  ///
  /// :param: num number of objects to deallocate.  Should match exactly
  /// the value that was passed to `alloc()` (partial deallocations are not
  /// possible).
  ///
  /// Precondition: the memory is not initialized.
  ///
  /// Postcondition: the memory has been deallocated.
  public func dealloc(num: Int) {
    // Overflow checking is actually not required here.
    var size = strideof(T.self) * num
    Builtin.deallocRaw(value, size.value, Builtin.alignof(T.self))
  }
%  end

  /// Access the underlying raw memory, getting and
  /// setting values.
  public var memory : T {
    @transparent get {
      return Builtin.load(value)
    }
%  if mutable:
    @transparent nonmutating set {
      Builtin.assign(newValue, value)
    }
%  end
  }

%  if mutable:
  /// Initialize the value the pointer points to, to construct
  /// an object where there was no object previously stored.
  ///
  /// Precondition: the memory is not initialized.
  ///
  /// Postcondition: the memory is initalized; the value should eventually
  /// be destroyed or moved from to avoid leaks.
  public func initialize(newvalue: T) {
    Builtin.initialize(newvalue, value)
  }

  /// Retrieve the value the pointer points to, moving it away
  /// from the location referenced in memory.
  ///
  /// Equivalent to reading `memory` property and calling `destroy()`,
  /// but more efficient.
  ///
  /// Precondition: the memory is initialized.
  ///
  /// Postcondition: the value has been destroyed and the memory must
  /// be initialized before being used again.
  public func move() -> T {
    return Builtin.take(value)
  }

  /// Move count values beginning at source into uninitialized memory,
  /// transforming the source values into raw memory, proceeding from
  /// the last value to the first.  Use this for copying ranges into
  /// later memory that may overlap with the source range.
  ///
  /// Requires: either `source` precedes `self` or follows `self + count`.
  public func moveInitializeBackwardFrom(source: ${Self}, count: Int) {
    _debugPrecondition(
      count >= 0, "${Self}.moveInitializeBackwardFrom with negative count")
    _debugPrecondition(
      source <= self || source > self + count,
      "${Self}.moveInitializeBackwardFrom non-preceding overlapping range; use moveInitializeFrom instead")
    var src = source + count
    var dst = self + count
    while dst != self {
      (--dst).initialize((--src).move())
    }
  }

  /// Assign from count values beginning at source into initialized
  /// memory, transforming the source values into raw memory.
  public func moveAssignFrom(source: ${Self}, count: Int) {
    _debugPrecondition(
      count >= 0, "moveAssignFrom with negative count")
    _debugPrecondition(
      source > self || source < self - count,
      "moveAssignFrom non-following overlapping range")
    for i in 0..<count {
      self[i] = (source + i).move()
    }
  }

  /// Assign from `count` values beginning at source into initialized
  /// memory, proceeding from the first element to the last.
  public func assignFrom(source: ${Self}, count: Int) {
    _debugPrecondition(
      count >= 0, "moveAssignFrom with negative count")
    _debugPrecondition(
      source > self || source < self - count,
      "moveAssignFrom non-following overlapping range; use assignBackwardFrom")
    for i in 0..<count {
      self[i] = source[i]
    }
  }

  /// Assign from `count` values beginning at `source` into
  /// initialized memory, proceeding from the last value to the first.
  /// Use this for assigning ranges into later memory that may overlap
  /// with the source range.
  ///
  /// Requires: either `source` precedes `self` or follows `self + count`.
  public func assignBackwardFrom(source: ${Self}, count: Int) {
    _debugPrecondition(
      count >= 0, "${Self}.assignBackwardFrom with negative count")
    _debugPrecondition(
      source <= self || source > self + count,
      "${Self}.assignBackwardFrom non-preceding overlapping range; use assignFrom instead")
    for var i = count; --i >= 0; {
      self[i] = source[i]
    }
  }

  /// Move count values beginning at source into raw memory,
  /// transforming the source values into raw memory.
  public func moveInitializeFrom(source: ${Self}, count: Int) {
    _debugPrecondition(
      count >= 0, "${Self}.moveInitializeFrom with negative count")
    _debugPrecondition(
      source >= self || source < self - count,
      "${Self}.moveInitializeFrom non-following overlapping range; use moveInitializeBackwardFrom")
    for i in 0..<count {
      (self + i).initialize((source + i).move())
    }
  }

  /// Copy count values beginning at source into raw memory.
  ///
  /// Precondition: the memory is not initialized.
  public func initializeFrom(source: ${Self}, count: Int) {
    _debugPrecondition(
      count >= 0, "${Self}.initializeFrom with negative count")
    _debugPrecondition(
      source >= self || source < self - count,
      "${Self}.initializeFrom non-following overlapping range")
    for i in 0..<count {
      (self + i).initialize(source[i])
    }
  }

  /// Copy the elements of `C` into raw memory.
  ///
  /// Precondition: the memory is not initialized.
  public func initializeFrom<
    C: CollectionType where C._Element == T
  >(
    source: C
  ) {
    var p = self
    for x in source {
      // FIXME: <rdar://problem/16951692> We should be able to use a
      // C.Generator.Element == T constraint here, because C._Element ==
      // C.Generator.Element in all cases, but doing so crashes the
      // type-checker.
      p++.initialize(unsafeBitCast(x, T.self))
    }
  }

  /// Destroy the object the pointer points to.
  ///
  /// Precondition: the memory is initialized.
  ///
  /// Postcondition: the value has been destroyed and the memory must
  /// be initialized before being used again.
  public func destroy() {
    Builtin.destroy(T.self, value)
  }

  /// Destroy the `count` objects the pointer points to.
  /// Precondition: the memory is initialized.
  ///
  /// Postcondition: the value has been destroyed and the memory must
  /// be initialized before being used again.
  public func destroy(count: Int) {
    _debugPrecondition(count >= 0, "${Self}.destroy with negative count")
    Builtin.destroyArray(T.self, value, count.value)
  }
%  end

  @transparent public
  var _isNull : Bool {
    return self == ${Self}.null()
  }

  public subscript (i : Int) -> T {
    @transparent
    get {
      return (self + i).memory
    }
%  if mutable:
    @transparent
    nonmutating set {
      (self + i).memory = newValue
    }
%  end
  }

% if mutable:
  /// If self was converted from nil, writes the result of invoking body into 
  /// the pointee
  public
  func _setIfNonNil(body: () -> T) {
    if self != nil {
      memory = body()
    }
  }

  /// Return the result of invoking body.  If self was converted from
  /// nil, passes nil as the argument.  Otherwise, passes the address
  /// of a T which is written into buffer before this method returns
  @transparent public
  func _withBridgeObject<U: AnyObject, R>(
    inout buffer: U?, body: (AutoreleasingUnsafeMutablePointer<U?>)->R
  ) -> R {
    return self != nil ? body(&buffer) : body(nil)
  }

  /// Return the result of invoking body.  If self was converted from
  /// nil, passes nil as the argument.  Otherwise, passes the address
  /// of buffer
  @transparent public
  func _withBridgeValue<U, R>(
    inout buffer: U, body: (UnsafeMutablePointer<U>)->R
  ) -> R {
    return self != nil ? body(&buffer) : body(nil)
  }
% end

  //
  // Protocol conformance
  //
  public var hashValue: Int {
    return Int(Builtin.ptrtoint_Word(value))
  }
  public func successor() -> ${Self} {
    return self + 1
  }
  public func predecessor() -> ${Self} {
    return self - 1
  }
  public func distanceTo(x: ${Self}) -> Int {
    return x - self
  }
  public func advancedBy(n: Int) -> ${Self} {
    return self + n
  }
}

extension ${Self} : DebugPrintable {
  public var debugDescription: String {
    return _rawPointerToString(value)
  }
}

${MirrorDecl} {
  ${MirrorBoilerplate}
  
  var count: Int { return 1 }
  
  func _getPointerValue() -> UInt64 {
    return UInt64(Int(Builtin.ptrtoint_Word(_value.value)))
  }

  subscript(i: Int) -> (String, MirrorType) {
    switch i {
    case 0: return ("pointerValue",reflect(_getPointerValue()))
    default: _preconditionFailure("cannot extract this child index")
    }
  }

  var summary: String {
    let selfType = "${Self}"
    let ptrValue = _getPointerValue()
    if ptrValue == 0 { return "\(selfType)(nil)" }
    return "\(selfType)(0x\(_uint64ToString(ptrValue, radix:16, uppercase:true)))"
  }

  var quickLookObject: QuickLookObject? { return .Some(.Text(summary)) }
}

${MirrorConformance}

@transparent public
func == <T> (lhs: ${Self}<T>, rhs: ${Self}<T>) -> Bool {
  return Bool(Builtin.cmp_eq_RawPointer(lhs.value, rhs.value))
}

@transparent public
func < <T>(lhs: ${Self}<T>, rhs: ${Self}<T>) -> Bool {
  return Bool(Builtin.cmp_ult_RawPointer(lhs.value, rhs.value))
}

@transparent public
func + <T>(lhs: ${Self}<T>, rhs: Int) -> ${Self}<T> {
  return ${Self}(
    Builtin.gep_Word(lhs.value, (rhs &* strideof(T.self)).value))
}

@transparent public
func + <T>(lhs: Int,
           rhs: ${Self}<T>) -> ${Self}<T> {
  return rhs + lhs
}

@transparent public
func - <T>(lhs: ${Self}<T>, rhs: Int) -> ${Self}<T> {
  return lhs + -rhs
}

@transparent public
func - <T>(lhs: ${Self}<T>, rhs: ${Self}<T>) -> Int {
  return
    Int(Builtin.sub_Word(Builtin.ptrtoint_Word(lhs.value),
                         Builtin.ptrtoint_Word(rhs.value)))
    / strideof(T.self)
}

@transparent public
func += <T>(inout lhs: ${Self}<T>, rhs: Int) {
  lhs = lhs + rhs
}

@transparent public
func -= <T>(inout lhs: ${Self}<T>, rhs: Int) {
  lhs = lhs - rhs
}
% end # for mutable

extension UnsafeMutablePointer {  
  /// An `UnsafePointer<T>` that points the same memory address
  /// as `self`.  This conversion is fundamentally safe.
  public var asImmutablePointer: UnsafePointer<T> {
    return UnsafePointer(self.value)
  }
}

extension UnsafePointer {
  /// An `UnsafeMutablePointer<T>` that points the same memory address
  /// as `self`.
  ///
  /// This is a fundamentally unsafe conversion.  In particular, if
  /// this property is misused to break immutability guarantees such
  /// as those conferred by `let`, the effects are undefined.
  public var asMutablePointer: UnsafeMutablePointer<T> {
    return UnsafeMutablePointer(self.value)
  }
}

extension UnsafeMutablePointer : SinkType {
  public mutating func put(x: T) {
    self.memory = x
    ++self
  }
}

/// A byte-sized thing that isn't designed to interoperate with
/// any other types; it makes a decent parameter to UnsafeMutablePointer when
/// you just want to do bytewise pointer arithmetic.
public struct RawByte {
  let _inaccessible: UInt8
}

@availability(*,unavailable,message="it has been renamed 'UnsafePointer'; the old 'UnsafePointer' was renamed 'UnsafeMutablePointer''")
public struct ConstUnsafePointer<T> {
}

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
