//===--- Filter.swift - Lazily filter the elements of a Sequence ----------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// The `Generator` used by `FilterSequenceView` and
/// `FilterCollectionView`
@public struct FilterGenerator<Base: Generator> : Generator, Sequence {
  @public mutating func next() -> Base.Element? {
    var n: Base.Element?
    for/*ever*/;; {
      n = _base.next()
      if n ? _include(n!) : true {
        return n
      }
    }
  }
  
  @public func generate() -> FilterGenerator {
    return self
  }

  var _base: Base
  var _include: (Base.Element)->Bool
}

/// The lazy `Sequence` returned by `filter(c)` where `c` is a
/// `Sequence`
@public struct FilterSequenceView<Base: Sequence> : Sequence {
  @public func generate() -> FilterGenerator<Base.GeneratorType> {
    return FilterGenerator(_base: _base.generate(), _include: _include)
  }

  var _base: Base
  var _include: (Base.GeneratorType.Element)->Bool
}

/// The `IndexType` used for subscripting a `FilterCollectionView`
@public struct FilterCollectionViewIndex<Base: Collection> : ForwardIndex {
  @public func successor() -> FilterCollectionViewIndex {
    for nextPos in _pos.successor()..<_end {
      if _include(_base[nextPos]) {
        return FilterCollectionViewIndex(
          _pos: nextPos, _end: _end,
          _base: _base, _include: _include)
      }
    }
    return FilterCollectionViewIndex(
      _pos: _end, _end: _end, _base: _base, _include: _include)
  }
  var _pos: Base.IndexType
  var _end: Base.IndexType
  var _base: Base
  var _include: (Base.GeneratorType.Element)->Bool
}

@public func == <Base: Collection>(
  lhs: FilterCollectionViewIndex<Base>,
  rhs: FilterCollectionViewIndex<Base>
) -> Bool {
  return lhs._pos == rhs._pos
}

/// A lazy `Collection` wrapper that includes the elements of an
/// underlying collection that satisfy a predicate.  Not
/// automatically returned by `filter(x)` for two reasons:
///
/// * The O(1) guarantee of our `IndexType` would be iffy at best, since
///   it advances an underlying `Index` until the predicate is
///   satisfied.  Be aware that a `FilterCollectionView` may not offer
///   the expected efficiency for this reason.
///
/// * Constructing an `Array` from a `Collection` measures the length
///   of the collection before traversing it to read the elements.
///   This causes the filter predicate to be called twice for each
///   element of the underlying collection, which is surprising.
@public struct FilterCollectionView<Base: Collection> : Collection {

  @public typealias IndexType = FilterCollectionViewIndex<Base>

  @public
  init(_ base: Base, includeElement: (Base.GeneratorType.Element)->Bool) {
    self._base = base
    self._include = includeElement
  }

  @public var startIndex: IndexType {
    var first = _base.startIndex
    while first != _base.endIndex {
      if _include(_base[first]) {
        break
      }
      ++first
    }
    return FilterCollectionViewIndex(
      _pos: first, _end: _base.endIndex, _base: _base, _include: _include)
  }
  
  @public var endIndex: IndexType {
    return FilterCollectionViewIndex(
      _pos: _base.endIndex, _end: _base.endIndex,
      _base: _base, _include: _include)
  }

  @public subscript(index: IndexType) -> Base.GeneratorType.Element {
    return _base[index._pos]
  }

  @public func generate() -> FilterGenerator<Base.GeneratorType> {
    return FilterGenerator(_base: _base.generate(), _include: _include)
  }

  var _base: Base
  var _include: (Base.GeneratorType.Element)->Bool
}

% traversals = ('Forward', 'Bidirectional', 'RandomAccess')
% for Self in ['LazySequence'] + [ 'Lazy%sCollection' % t for t in traversals ]:
extension ${Self} {
  /// Return a lazy Sequence containing the elements `x` of `source` for
  /// which `includeElement(x)` is `true`
  @public
  func filter(
    includeElement: (S.GeneratorType.Element)->Bool
  ) -> LazySequence<FilterSequenceView<S>> {
    return LazySequence<FilterSequenceView<S>>(
      FilterSequenceView(_base: self._base, _include: includeElement))
  }
}

% end

/*
// No overload for collections; see the comment on
// FilterCollectionView for an explanation.

/// Return a lazy Collection containing the elements `x` of `source` for
/// which `includeElement(x)` is `true`
@public func filter<C:Collection>(
  source: C, includeElement: (C.GeneratorType.Element)->Bool
) -> FilterCollectionView<C> {
  return FilterCollectionView(_base: source, _include: includeElement)
}
*/
