//===--- Map.swift - Lazily map over a SequenceType -----------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

/// The `GeneratorType` used by `MapSequenceView` and `MapCollectionView`.
/// Produces each element by passing the output of the `Base`
/// `GeneratorType` through a transform function returning `T`
public struct MapSequenceGenerator<
  Base: GeneratorType, T
>: GeneratorType, SequenceType {
  public mutating func next() -> T? {
    let x = _base.next()
    if x != nil {
      return _transform(x!)
    }
    return nil
  }
  
  public func generate() -> MapSequenceGenerator {
    return self
  }
  
  var _base: Base
  var _transform: (Base.Element)->T
}

//===--- Sequences --------------------------------------------------------===//

/// A `SequenceType` whose elements consist of those in a `Base`
/// `SequenceType` passed through a transform function returning `T`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct MapSequenceView<Base: SequenceType, T> : SequenceType {
  public func generate() -> MapSequenceGenerator<Base.Generator,T> {
    return MapSequenceGenerator(
      _base: _base.generate(), _transform: _transform)
  }
  
  var _base: Base
  var _transform: (Base.Generator.Element)->T
}

/// Return an `Array` containing the results of mapping `transform`
/// over `source`.
public func map<S:SequenceType, T>(
  source: S, transform: (S.Generator.Element)->T
) -> [T] {
  return lazy(source).map(transform).array
}

//===--- Collections ------------------------------------------------------===//

/// A `CollectionType` whose elements consist of those in a `Base`
/// `CollectionType` passed through a transform function returning `T`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct MapCollectionView<Base: CollectionType, T> : CollectionType {
  public var startIndex: Base.Index {
    return _base.startIndex
  }
  
  public var endIndex: Base.Index {
    return _base.endIndex
  }

  public subscript(index: Base.Index) -> T {
    return _transform(_base[index])
  }

  public func generate() -> MapSequenceView<Base, T>.Generator {
    return MapSequenceGenerator(_base: _base.generate(), _transform: _transform)
  }

  var _base: Base
  var _transform: (Base.Generator.Element)->T
}

/// Return an `Array` containing the results of mapping `transform`
/// over `source`.
public func map<C:CollectionType, T>(
  source: C, transform: (C.Generator.Element)->T
) -> [T] {
  return lazy(source).map(transform).array
}

//===--- Support for lazy(s) ----------------------------------------------===//

% traversals = ('Forward', 'Bidirectional', 'RandomAccess')
% for View, Self in [('MapSequenceView', 'LazySequence')] + [ 
%   ('MapCollectionView', 'Lazy%sCollection' % t) for t in traversals
% ]:

extension ${Self} {
  /// Return a `${View}` over this `${Self}`.  The elements of
  /// the result are computed lazily, each time they are read, by
  /// calling `transform` function on a base element.
  public
  func map<U>(
    transform: (S.Generator.Element)->U
  ) -> ${Self}<${View}<S, U>> {
    return ${Self}<${View}<S, U>>(
      ${View}(_base: self._base, transform)
    )
  }
}

% end

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
