//===--- FixedPoint.swift.gyb ---------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{

from SwiftIntTypes import *

#
# Utility code for later in this template
#
def hexify(n):
    """Return a legible hex representation of n, using '_' separators """
    z = '%X' % n
    l = len(z)
    r = []
    while z:
        r.insert(0, z[-4:])
        z = z[:-4]
    return '0x' + '_'.join(r)

# Number of bits in the Builtin.Word type
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8

# Number of bits in integer literals.
builtinIntLiteralBits = 2048

# FIXME: checked and unchecked conversions of Word types
CastFromWord = 'zextOrBitCast_Word_Int64' if word_bits==64 else 'truncOrBitCast_Word_Int32'
CastToWord = 'truncOrBitCast_Int64_Word' if word_bits==64 else 'zextOrBitCast_Int32_Word'

def maskBits(n):
    """Return an n-bit mask in hex"""
    return hexify((1 << n) - 1)

}%

public typealias IntMax = Int${int_max_bits}
public typealias UIntMax = UInt${int_max_bits}

public protocol _IntegerType
  : _BuiltinIntegerLiteralConvertible,
    IntegerLiteralConvertible,
    Printable,
    ArrayBoundType,
    Hashable,
    IntegerArithmeticType,
    BitwiseOperationsType,
    _Incrementable
{
}

public protocol IntegerType : _IntegerType, RandomAccessIndexType {
}

public protocol _SignedIntegerType : _IntegerType, SignedNumberType {
  func toIntMax() -> IntMax
  class func from(IntMax) -> Self
}

public protocol SignedIntegerType : _SignedIntegerType, IntegerType {
}

public protocol _UnsignedIntegerType : _IntegerType {
  func toUIntMax() -> UIntMax
  class func from(UIntMax) -> Self
}

public protocol UnsignedIntegerType : _UnsignedIntegerType, IntegerType {
}

public func numericCast<
  T : _SignedIntegerType, U : _SignedIntegerType
>(x: T) -> U {
  return .from(x.toIntMax())
}

public func numericCast<
  T : _UnsignedIntegerType, U : _UnsignedIntegerType
>(x: T) -> U {
  return .from(x.toUIntMax())
}

public func numericCast<
  T : _SignedIntegerType, U : _UnsignedIntegerType
>(x: T) -> U {
  return .from(UIntMax(x.toIntMax()))
}

public func numericCast<
T : _UnsignedIntegerType, U : _SignedIntegerType
>(x: T) -> U {
  return .from(IntMax(x.toUIntMax()))
}

% for (name, bits, signed) in all_integer_types(word_bits):
%   (sign, ext) = ('s', 'sext') if signed else ('u', 'zext')
%   BuiltinName = builtin_int_name(name)
%   Self = int_name(name, signed)
%   OtherSelf = other_int_name(name, signed)
%   ConstructIntType = 'Int' if Self != 'Int' else ''

public struct ${Self}
   : ${'SignedIntegerType' if sign == 's' else 'UnsignedIntegerType'} {
  public var value: Builtin.${BuiltinName}

  @transparent public
  init() {
    var maxWidthZero: IntMax = 0
    value = Builtin.truncOrBitCast_Int${int_max_bits}_${BuiltinName}(
       maxWidthZero.value)
  }

  @transparent public
  init(_ v: Builtin.${BuiltinName}) {
    value = v
  }

  @transparent public
  init(_ value: ${Self}) { self = value }

%  if bits > 8:
  /// Creates an integer from its big-endian representation, changing the
  /// byte order if necessary.
  @transparent public
  init(bigEndian value: ${Self}) {
#if arch(i386) || arch(x86_64) || arch(arm) || arch(arm64)
    self = ${Self}(Builtin.int_bswap_${BuiltinName}(value.value) )
#else
    _UnsupportedArchitectureError()
#endif
  }

  /// Creates an integer from its little-endian representation, changing the
  /// byte order if necessary.
  @transparent public
  init(littleEndian value: ${Self}) {
#if arch(i386) || arch(x86_64) || arch(arm) || arch(arm64)
    self = value
#else
    _UnsupportedArchitectureError()
#endif
  }
%  end

  @transparent public
  static func _convertFromBuiltinIntegerLiteral(value: Builtin.Int${builtinIntLiteralBits}) -> ${Self} {
    return ${Self}(Builtin.s_to_${sign}_checked_trunc_Int${builtinIntLiteralBits}_${BuiltinName}(value).0)
  }

  @transparent public
  static func convertFromIntegerLiteral(value: ${Self}) -> ${Self} {
    return value
  }
  @transparent public
  func _getBuiltinArrayBoundValue() -> Builtin.Word {
%  if bits < word_bits:
    return Builtin.${ext}OrBitCast_${BuiltinName}_Word(self.value)
%  elif bits > word_bits:
    return Builtin.truncOrBitCast_${BuiltinName}_Word(self.value)
%  elif BuiltinName == 'Word':
    return self.value
%  else:
    return Builtin.${CastToWord}(self.value)
%  end
  }

  public typealias ArrayBound = ${Self}
  public var arrayBoundValue: ${Self} {
    return self
  }

%  if bits > 8:
  /// Returns the big-endian representation of the integer, changing the
  /// byte order if necessary.
  public var bigEndian: ${Self} {
#if arch(i386) || arch(x86_64) || arch(arm) || arch(arm64)
    return ${Self}(Builtin.int_bswap_${BuiltinName}(value) )
#else
    _UnsupportedArchitectureError()
#endif
  }
  /// Returns the little-endian representation of the integer, changing the
  /// byte order if necessary.
  public var littleEndian: ${Self} {
#if arch(i386) || arch(x86_64) || arch(arm) || arch(arm64)
    return self
#else
    _UnsupportedArchitectureError()
#endif
  }
% end

%  if bits > 8:
  /// Returns the current integer with the byte order swapped.
  public var byteSwapped: ${Self} {
    return ${Self}(Builtin.int_bswap_${BuiltinName}(value))
  }
% end

% max = maskBits((bits - 1) if signed else bits)
  @transparent public
  static var max: ${Self} { return ${max} }
  @transparent public
  static var min: ${Self} { return ${'-%s-1' % max if signed else '0'} }
  @transparent
  public static var _sizeInBits: ${Self} { return ${bits} }
}

extension ${Self} : Hashable {
  public var hashValue: Int {
% if bits < word_bits:
    return Int(Builtin.sextOrBitCast_${BuiltinName}_Word(self.value))
% elif bits > word_bits:
    var result: Int = 0
    for var i = 0; i < ${bits}; i += Int._sizeInBits {
      result ^= Int(self >> ${Self}(i)) & ~0
    }
    return result
% elif BuiltinName == 'Word':
    return Int(self.value)
% else:
    return Int(Builtin.${CastToWord}(self.value))
% end
  }
}

extension ${Self} : Printable {
  public var description: String {
% if signed:
    return _int64ToString(self.toIntMax())
% else:
    return _uint64ToString(self.toUIntMax())
% end
  }
}

// When ${Self} is used as an index, there are always bounds---more
// restrictive than the full range of ${Self}---against which we're
// not able to check.  Overflows are not useful indicators of
// precondition violations in this context.  Therefore, we use masked
// arithmetic in this conformance, and we need to be be sure that
// generic implementations of the arithmetic operators for
// RandomAccessIndexType's are all shadowed by more-specific
// implementations that *do* check for overflows.
@transparent
extension ${Self} : RandomAccessIndexType {
  // HACK: Disable indexing and slicing Ranges of IntegerType types
  // outside of a generic context.  See the implementation of Range
  // for details of how this works.
  typealias _DisabledRangeIndex = ${Self}
  
  @transparent public
  func successor() -> ${Self} {
    return self &+ 1
  }
  @transparent public
  func predecessor() -> ${Self} {
    return self &- 1
  }
  
  @transparent public
  func distanceTo(other: ${Self}) -> ${Self}.Distance {
    return numericCast((numericCast(other) as IntMax) &- numericCast(self))
  }
  
  @transparent public
  func advancedBy(amount: ${Self}.Distance) -> ${Self} {
    return numericCast((numericCast(self) as IntMax) &+ numericCast(amount))
  }
}

extension ${Self} {
% for Method,op in [('add', 'add'), ('subtract', 'sub'), ('multiply', 'mul')]:
  @transparent public
  static func ${Method}WithOverflow(lhs: ${Self}, _ rhs: ${Self}) -> (${Self}, overflow: Bool) {
    var tmp = Builtin.${sign}${op}_with_overflow_${BuiltinName}(lhs.value, rhs.value, false.value)
    return (${Self}(tmp.0), Bool(tmp.1))
  }
% end
  
% for Method,op in [('divide', 'div'), ('remainder', 'rem')]:
  /// Operations that return an overflow bit in addition to a partial result,
  /// helpful for checking for overflow when you want to handle it.
  @transparent public
  static func ${Method}WithOverflow(lhs: ${Self}, _ rhs: ${Self}) -> (${Self}, overflow: Bool) {
    if rhs == 0 {
      return (0, true)
    }
% if signed:
    if lhs == ${Self}.min && rhs == -1 {
      return (0, true)
    }
% end
    // FIXME: currently doesn't detect overflow -- blocked by:
    // <rdar://15735295> Need [su]{div,rem}_with_overflow IR
    var tmp = Builtin.${sign}${op}_${BuiltinName}(lhs.value, rhs.value)
    return (${Self}(tmp), false)
  }
%end

% U = '' if signed else 'U'
  @transparent public
  func to${U}IntMax() -> ${U}IntMax {
    return ${'self' if Self == U+'Int%s'%int_max_bits else U+'IntMax(self)'}
  }
% if not signed:
  @transparent public
  func toIntMax() -> IntMax {
    return IntMax(toUIntMax())
  }
% end
  @transparent public
  static func from(x: ${U}IntMax) -> ${Self} {
    return ${'x' if Self == U+'Int%s'%int_max_bits else Self+'(x)'}
  }
}

% if signed:
@transparent
extension ${Self} : SignedNumberType {}
% end

%# FIXME: checked conversions of Word types
// construction from other integer types
@transparent
extension ${Self} {
% for (srcName, srcBits, srcSigned) in all_integer_types(word_bits):
%    Src = int_name(srcName, srcSigned)
%    srcBuiltinName = builtin_int_name(srcName)
%    (srcSign, srcExt) = ('s', 'sext') if srcSigned else ('u', 'zext')
%    if Self != Src:
  public init(_ v: ${Src}) {
%
%       if srcBuiltinName == 'Word':
    var srcNotWord = Builtin.${CastFromWord}(v.value)
%       else:
    var srcNotWord = v.value
%       end
%
%       if srcBits == bits and srcSign == sign:
    var dstNotWord = srcNotWord
%
%       elif srcBits == bits:
    var tmp = Builtin.${srcSign}_to_${sign}_checked_conversion_Int${srcBits}(srcNotWord)
    Builtin.condfail(tmp.1)
    var dstNotWord = tmp.0
%
%       elif srcBits > bits:
    var tmp = Builtin.${srcSign}_to_${sign}_checked_trunc_Int${srcBits}_Int${bits}(srcNotWord)
    Builtin.condfail(tmp.1)
    var dstNotWord = tmp.0
%
%       elif srcSigned and not signed:
    var tmp = Builtin.s_to_u_checked_conversion_Int${srcBits}(srcNotWord)
    Builtin.condfail(tmp.1)
    var dstNotWord = Builtin.${srcExt}_Int${srcBits}_Int${bits}(tmp.0)
%
%       else:
    var dstNotWord = Builtin.${srcExt}_Int${srcBits}_Int${bits}(srcNotWord)
%       end
%
%       if BuiltinName == 'Word':
    value = Builtin.${CastToWord}(dstNotWord)
%       else:
    value = dstNotWord
%       end
  }

%    end
% end

  @availability(*,unavailable,message="it has been replaced by construction of the target type with an explicit 'bitPattern:' argument label")
  public func as${'Unsigned' if signed else 'Signed'}() -> ${OtherSelf} {
    return ${OtherSelf}(value)
  }
  
  /// Construct a `${Self}` having the same memory representation as
  /// the `${OtherSelf}` `bitPattern`.  No range or overflow checking
  /// occurs, and the resulting `${Self}` may not have the same numeric
  /// value as `bitPattern`--it is only guaranteed to use the same
  /// pattern of bits.
  @transparent
  public init(bitPattern: ${OtherSelf}) {
    value = bitPattern.value
  }
}

// Operations with potentially-static overflow checking
//
// FIXME: must use condfail in these operators, rather than
// overflowChecked, pending <rdar://problem/16271923> so that we don't
// foil static checking for numeric overflows.
% for op,method in ('+','add'), ('*','mul'), ('-','sub'):
@transparent public
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  let (result, error) = Builtin.${sign}${method}_with_overflow_${BuiltinName}(
    lhs.value, rhs.value, true.value)
  // return overflowChecked((${Self}(result), Bool(error)))
  Builtin.condfail(error)
  return ${Self}(result)
}
% end

% for op,inst in [('/', 'div'), ('%', 'rem')]:
@transparent public
func ${op}(lhs: ${Self}, rhs: ${Self}) -> ${Self} {
    Builtin.condfail((rhs == 0).value)
% if signed:
    Builtin.condfail(((lhs == ${Self}.min) & (rhs == -1)).value)
% end
    // FIXME: currently doesn't detect overflow -- blocked by:
    // <rdar://15735295> Need [su]{div,rem}_with_overflow IR
    var tmp = Builtin.${sign}${inst}_${BuiltinName}(lhs.value, rhs.value)
    return ${Self}(tmp)
  }
%end

// Bitwise negate
@transparent public
prefix func ~(rhs: ${Self}) -> ${Self} {
  let mask = ${Self}.subtractWithOverflow(0, 1).0
  return ${Self}(Builtin.xor_${BuiltinName}(rhs.value, mask.value))
}

% for op, name in (
%  ('==','eq'), ('!=','ne'),
%  ('<',sign+'lt'), ('<=',sign+'le'),
%  ('>',sign+'gt'), ('>=',sign+'ge')):
@transparent public
func ${op} (lhs: ${Self}, rhs: ${Self}) -> Bool {
  return Bool(Builtin.cmp_${name}_${BuiltinName}(lhs.value, rhs.value))
}
% end

% for op, name in (('<<','shl'), ('>>','ashr' if signed else 'lshr')):
@transparent public
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
% if signed:
  _precondition(U${Self}(rhs) < U${Self}(sizeofValue(rhs) &* 8),
      "shift amount is larger than type size in bits")
% else:
  _precondition(rhs < ${Self}(sizeofValue(rhs) &* 8),
      "shift amount is larger than type size in bits")
% end
  return ${Self}(Builtin.${name}_${BuiltinName}(lhs.value, rhs.value))
}
% end

% for op, name in (('&','and'), ('^','xor'), ('|','or')):
@transparent public
func ${op} (lhs: ${Self}, rhs: ${Self}) -> ${Self} {
  return ${Self}(Builtin.${name}_${BuiltinName}(lhs.value, rhs.value))
}
% end

// bitwise operations
@transparent
extension ${Self} : BitwiseOperationsType {
  public static var allZeros: ${Self} { return 0 }
}

// Compound assignments
% for op in '+', '-', '*', '<<', '>>', '&', '|', '^':
@transparent public
func ${op}=(inout lhs: ${Self}, rhs: ${Self}) {
  lhs = lhs ${op} rhs
}
% end

// Prefix and postfix increment and decrement.

// We already have generic versions of these, but when compiling
// -Onone we are unable to devirtualize the generic call, which
// results in worse performance than we would like for these simple
// operations (tracked by <rdar://problem/17692569>).
@transparent
public prefix func ++ (inout x: ${Self}) -> ${Self} {
  x = x + 1
  return x
}

@transparent
public postfix func ++ (inout x: ${Self}) -> ${Self} {
  var ret = x
  x = x + 1
  return ret
}

@transparent
public prefix func -- (inout x: ${Self}) -> ${Self} {
  x = x - 1
  return x
}

@transparent
public postfix func -- (inout x: ${Self}) -> ${Self} {
  var ret = x
  x = x - 1
  return ret
}

% end  # for bits in allInts

public typealias Word = Int
public typealias UWord = UInt

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
