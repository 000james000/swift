Mutable Namespace-Scope Variable Declarations
=============================================

A namespace-scope variable (i.e. a variable not inside a function) is allowed
to have an initializer, and that initializer is allowed to have side effects.
Thus, we have to decide how and when the initializer runs.

WLOG, lets assume that all namespace-scope variables are mutable (and thus that
immutable variables are just an optimization of the common case).  Given that
they can have mutable state, they cannot be "global" (in the C sense) because
then they would be visible across multiple actors.  Instead, the only logical
semantic is for them to be actor-local data ("thread local" in the C sense) of
some sort.

Given that there can be many of these variables in an address space, and very
few of them may be dynamically used by any particular actor, it doesn't make
sense to allocate space for all of the variables and run all of the initializers
for the variables at actor-startup-time.  Instead, swift should handle these as
"actor associated data" (stored in a hashtable that the actor has a pointer to)
and should be lazily initialized (in the absence of 'top level code', see
below).

This means that if you write code like this (optionally we could require an
attribute to make it clear that the value is actor local)

  func foo(a : int) -> int { print(a) return 0 }

  var x = foo(1)
  var y = foo(2)

That the print statements will execute the first time that x or y is used by any
particular actor.


Top Level Code
==============

One goal of swift is to provide a very "progressive disclosure" model of writing
code and learning how to write code.  Therefore, it is desirable that someone be
able to start out with:

  print("hello world\n")

as their first application.  This requires that we support "top level code",
which is code outside any function or other declaration.  The counter-example
of this is java, which requires someone to look at "class foo / public static
void main String[]...." all of which is non-essential to the problem of writing
a simple app.

Top level code is useful for a number of other things: many scripts written by
unix hackers (in perl, bourne shell, ruby, etc) are really just simple command
line apps that may have a few helper functions and some code that runs.  While
not essential, it is a great secondary goal to make these sorts of simple apps
easy to write in Swift as well.

Top-Level code and lazily evaluated variable initializers don't mix well, nor
does top level code and multiple actors.  As such, the logical semantics are:

1. Source files are partitioned into two cases: "has TLC" and "has no TLC".
2. All variables defined in "has no TLC" files are allocated and initialized
   lazily.
3. Source files that have TLC are each initialized in a deterministic order:
   The dependence graph of domains is respected (lower level domains are
   initialized before dependent ones), and the source files withing a domain are
   initialized in some deterministic order (perhaps according to their filename
   or something, TBD).
4. Within a source file with TLC, the TLC is run top down in determinstic order
   whenever the file's initializer is run.  This initializer executes in the
   context of the "first" actor, which is created on behalf of the program by
   the runtime library.
5. If/when some other actor refers to a variable in a file with TLC, it is
   allocated and initialized lazily just like globals in "has no TLC" files.

