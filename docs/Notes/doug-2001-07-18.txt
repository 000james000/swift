Random notes about implementation and language issues/concerns based on digging into the Swift code base.

LangRef:

Sidebar for Reserved Keywords talks about pushing most control flow into the library, but I'm guessing (hoping?) that we're not actually going to do that, since we'd prefer to actually be able to compute a CFG.

Parenthesized Expressions: there appears to be no way to express a one-tuple. How about allowing a trailing ","? 

Does

  'func' attribute-list? identifier arg-list-type '=' expr

really add value?

Subscripting shouldn't be a separate operator. We should just use
parentheses, so that subscripting an array is essentially just
treating the array as a function (operator() in C++ parlance). Then,
we can reserve square brackets for something else entirely.

There's a cluster of decisions around the juxtposition operator, tuple
<-> scalar conversions, auto-closuring, and the separation of
expression sequences into different statements that worry me. My
general concern is that they are too obscure for most programmers, and
that we're sacrificing clarity for conciseness (in the language
specification). 

I don't yet understand the interplay among the type inference rules
being used to match dependent expressions (e.g., :foo) to types
(pushing down the tree) and computing the types of expressions during
type checking (pulling up the tree). 

Implementation (general):
  - Need a separate module manager abstraction, which can be told to
  "go import this module". It should keep the module graph in memory,
  know where to search for modules, (eventually) know how to load
  modules from their binary representation, etc.
  - Need a virtual file system, backed by the on-disk file system, so
  that we can manage the invalidation of translation units when files
  change on disk.
  - Need a proper diagnostics subsystem; Clang's is an excellent
  model, but tblgen doesn't have a plugin system for us to use to keep
  Swift's diagnostics separate. Idea: write something like tblgen (but
  for diagnostics only) in Swift, to generate the C++ code we need. It
  can be one of our simple demo apps. 
  - Doxygen style could really use fixin'. This "FunctionName - It
  does stuff" approach doesn't work well; use "\brief It does stuff" instead.
  - Should build an AST verifier from the start.

Parser implementation:
  - Use RAII objects for handling balanced delimiters (e.g., (...)),
  so we can recover more intelligently when things go badly. 
  - I'm not at all thrilled about the llvm::isa<FunctionType> in
  Parser::parseDeclFunc. Requiring the '(' and then checking
  isa<FunctionType> works, but feels brittle.

AST implementation:
  - Consider using different BumpPtrAllocators for permanent AST nodes
  (e.g., declarations, resolved expressions) vs. temporary AST nodes
  (e.g., SequenceExpr, UnresolvedDeclRefExpr,
  OverloadSetRefExpr). Once name binding and type-checking are done, we
  could then dump all of the temporary storage and be left with just
  the permanent AST storage.
  - Pointer-width source locations? Really? We should really improve
  llvm::SourceMgr so it uses 32-bit source locations, add source
  ranges, improved formatting, etc. 

Name binding/type checking implementation:
  - It would be advantageous to be able to perform these operations on
  demand, for example, so that we could perform the name binding/type
  checking just for an expression being highlighted/completed within
  an IDE.

Overloading implementation:
  - May want to use the C++ "a least one argument has a better
  conversion and no argument has a worse conversion"
  formulation. However, this may be complicated a bit by name
  matching.
  - Bug: the algorithm could conclude that there are ambiguities if it sees
  two same-ranked functions before seeing a function ranked better
  than both of them. This only works today because there are only two
  levels implicit conversion.  
  - Overloading needs to be factored out; it's repeated in
  SemaApplyExpr and SemaBinaryExpr
  - SemaCoerceBottomUp::convertTupleToTupleType duplicates logic also
  present in overload resolution for attempting conversion between
  tuple types. Unify it, since this is a common theme.
