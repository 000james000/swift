==========
 Clonable
==========

**Abstract:** to better support the creation of value types, I propose
a “magic” `Clonable` protocol and an annotation for describing
which instance variables should be cloned when a type is copied.

When a type with reference semantics ``R`` is to be used as a part of
(versus merely being referred-to-by) a type with value semantics ``V``,
a new annotation, ``[clone]`` can be used to indicate that the ``R``
instance variable should be ``clone()``\ d when ``V`` is copied.

A ``class`` can be ``clone()``\ d when it implements the built-in ``Cloneable``
protocol::

  protocol Cloneable {
     func clone() -> This { /* see below */ }
  }

The implementation of ``clone()`` (which will be generated by the
compiler and typically never overridden) performs a primitive copy of
all ordinary instance variables, and a ``clone()`` of all instance
variables marked ``[clone]``::

  class FooValue : Cloneable  {}
  
  class Bar {}

  class Foo : Cloneable {
      var count : Int
      var [clone] myValue : FooValue 
      var somethingIJustReferTo : Bar
  }

  struct Baz {
      var [clone] partOfMyValue : Foo
      var anotherPart : Int
      var somethingIJustReferTo : Bar
  }

When a ``Baz`` is copied by any of the “big three” operations (variable
initialization, assignment, or function argument passing), even as
part of a larger ``struct``, its ``[clone]`` member is ``clone()``\ d.
Because ``Foo`` itself has a ``[clone]`` member, that is ``clone()``\ d
also.  Therfore copying a ``Baz`` object ``clone()``\ s a ``Foo`` and
``clone()``\ ing a ``Foo`` ``clone()``\ s a ``FooValue``.  

All ``struct``\ s are ``Cloneable`` by default, with ``clone()`` delivering
ordinary copy semantics.  Therefore, ::

  var x : Baz
  var y = x.clone()

is equivalent to ::

  var x : Baz
  var y = x

This should give us a start on a way to approach the generic
programming issues to be treated later.

Note that ``Cloneable`` is the first protocol with a default
implementation that can't currently be written in the standard library
(though arguably we'd like to add the capability to write that
implementation).

