============================
Objective-C Interoperability
============================

This document tracks the differences between the Swift and Objective-C ABIs and
class models, and what it would take to merge the two as much as possible. The
format of each section lays out the differences between Swift and Objective-C,
then describes what needs to happen for 


Level 1: Message-passing
========================

*Assuming an object is known to be a Swift object or an Objective-C object at*
*compile-time, what does it take to send a message from one to the other?*


Arguments
---------

  Objective-C currently requires that the first argument be ``self`` and the
  second be ``_cmd``. The explicit arguments to a method come after ``_cmd``.
  
  Swift only requires that the first argument be ``self``. The explicit
  arguments come after ``self``.

Swift methods that are exposed as Objective-C methods will have a wrapper
function that shifts all the arguments over.

Because these functions will be generated by a Swift compilation job, they may
be able to just inline the Swift method. If the Swift method is not referenced
anywhere else in the program, it is reasonable to *only* expose the Objective-C
entry point.

*Undecided: when a Swift method is exposed in Objective-C, but the method is in*
*a framework, is it worth exposing the Swift entry point as well? Otherwise, a*
*known Swift-to-Swift call will be forced to adjust for the Objective-C*
*conventions.*

ARC
---

  By default, objects are passed to and returned from Objective-C methods as +0
  (i.e. non-owned objects). The caller does not have to do anything to release
  returned objects, though if they wish to retain them they may be able to steal
  them out of the top autorelease pool. (In practice, the caller *does* retain
  the arguments for the duration of the method anyway, unless it can be proven
  that nothing interferes with the lifetime of the object between the load and
  the call.)

  Objective-C methods from certain method families do return +1 objects, as do
  methods explicitly annotated with the ``ns_returns_retained`` attribute.

  All Swift class objects (i.e. as opposed to structs) are returned as +1 (i.e.
  owned objects). The caller is responsible for releasing them.

The wrapper function mentioned above will be responsible for retaining all
the arguments and autoreleasing the return value.

*Swift methods will **not** be exposed as* ``ns_returns_retained`` because they*
*should behave like Objective-C methods when called through an* ``id``.


Output Parameters
-----------------

  Because Objective-C does not have tuples, returning multiple values is
  accomplished through the use of pointer-to-object-pointer parameters, such as
  ``NSError **``. Additionally, objects returned through these parameters are
  conventionally autoreleased, though ARC allows this to be specified
  explicitly.

  Swift has tuples and does not have pointers, so the natural way to return
  multiple values is to return a tuple. The retain-count issue is different
  here: with ARC, the tuple owns the objects in it, and the caller owns the
  tuple.

  Swift currently also has ``[byref]`` arguments. Whether or not these will be
  exposed to users and/or used for Objective-C out parameters is still
  undecided.

*This issue has not been resolved, but it only affects certain API.*


Messaging ``nil``
-----------------

  In Objective-C, the result of messaging ``nil`` is defined to be a zero-filled
  value of the return type. For methods that return an object, the return value
  is also ``nil``. Methods that return non-POD C++ objects attempt to
  default-construct the object if the receiver is ``nil``.

  In Swift, messaging ``nil`` is undefined, and hoped to be defined away by the
  type system through liberal use of some ``Optional`` type.

  - I've seen other languages explicitly request the Objective-C behavior using
    ``foo.?bar()``, though that's not the prettiest syntax in the world.
    -Jordan

As long as the implementation of ``Optional`` is layout-compatible with an
object pointer, and an absent ``Optional`` is represented with a null pointer,
this will Just Workâ„¢.


Overloading
-----------
  In Objective-C, methods cannot be overloaded.

  In Swift, methods can have the exact same name but take arguments of different
  types.

  Note that in Swift, all parameters after the first are part of the method
  name, unless using the "selector syntax" for defining methods::

    // 1. foo:baz:
    func foo(Int bar, Int baz);
  
    // 2. foo:qux:
    func foo(Int bar, Int qux);
  
    // 3. foo:qux: (same as above)
    func foo(Int bar) qux(Int quux);
  
    // 4. foo:baz: (but different type!)
    func foo(Int bar, Char baz);
  
    a.foo(1, 2)      // ambiguous in Swift (#1 or #2?)
    a.foo(1, baz=2)  // calls #1
    a.foo(1, qux=2)  // calls #2/3 (the same method)
    a.foo(1, 'C')    // calls #4, not ambiguous in Swift!
  
    [a foo:1 baz:2]; // ambiguous in Objective-C (#1 or #4?)
    [a foo:1 qux:2]; // calls #2/3 (the same method)

The Swift compiler should not let both #1 and #4 be exported to Objective-C.
It should already warn about the ambiguity between #1 and #2 without using
named parameters.


Level 2: Messaging ``id``
=========================

*If a Swift object can be referenced with* ``id``, *how do you send messages to*
*it?*


``isa`` Pointers
----------------
  The first word of every Objective-C object is a pointer to its class.
  
  We might want to use a more compact representation for Swift objects...

...but we can't; see below.


Method Lookup
-------------
  Objective-C performs method lookup by searching a sequence of maps for a
  given key, called a *selector*. Selectors are pointer-sized and uniqued
  across an entire process, so dynamically-loaded methods with the same name as
  an existing method will have an identical selector. Each map in the sequence
  refers to the set of methods added by a category (or the original class). If
  the lookup fails, the search is repeated for the superclass.

  Swift performs method lookup by vtable. In order to make these vtables
  non-fragile, the offset into a vtable for a given message is stored as a
  global variable. Rather than chaining searches through different message
  lists to account for inheritance and categories, the container for each
  method is known at compile-time. So the final lookup for a given method looks
  something like this::

    vtable[SUBCLASS_OFFSET + METHOD_OFFSET]

Swift class objects will have ``isa`` pointers, and those ``isa`` pointers will
have an Objective-C method list at the very least, and probably a method cache
as well. The methods in this list will refer to the Objective-C-compatible
wrappers around Swift methods described above.

The other words in the ``isa`` structure may not be used in the same way as they
are in Objective-C; only ``objc_msgSend`` has to avoid special-casing Swift
objects. Most of the other runtime functions can probably do a check to see if
they are dealing with a Swift class, and if so fail nicely.


Level 3a: Adopting Objective-C Protocols in Swift
=================================================

*To be written.*


Level 3b: Adopting Swift Protocols in Objective-C
=================================================

*To be written.*
*Note: including protocol implementations is essentially the same as implicitly*
*adding a category.*


Level 4a: Subclassing Objective-C Classes in Swift
==================================================

*To be written.*


Level 4b: Subclassing Swift Classes in Objective-C
==================================================

*To be written.*


Level 5a: Adding Extensions to Objective-C Classes in Swift
===========================================================

*To be written.*


Level 5b: Adding Categories to Swift Classes in Objective-C
===========================================================

*To be written.*


Level 6: Dynamic Subclassing
============================

*To be written, but probably not an issue...it's mostly the same as statically*
*subclassing, right?*


Level 7: Method Swizzling
=========================

I'm okay with just saying "no" to this one.

