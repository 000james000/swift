{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww11760\viewh14200\viewkind0
\deftab720
\pard\pardeftab720\ql\qnatural

\f0\b\fs24 \cf0 Overloading:
\b0 \
\
Function overloading in Swift is very simple: you define multiple values with the same name, and the compiler picks the right one. \'a0Overloading is only allowed for values at translation unit or namespace scope (not variables within a function). \'a0This is the same place where types are required on decls.\
\
There are restrictions on what \'a0can be overloaded: if any member of a overload set in a DeclContext is binary operator, then all must be, and at the same precedence level.\
\
The implementation of this is very simple: during name binding, lookup finds a collection of values that match the specified name. \'a0This collection is stored in an overload set expression (of dependent type), \'a0and type checking resolves the ambiguity if it can, and reports the ambiguity if not.\
\
\
// Unqualified name lookup "x" should ignore things explicitly declared as methods. \'a0Otherwise, the overload set will contain tons of junk that isn't useful, leading to ambiguities.\
\

\b Dot Syntax:
\b0 \
\
Dot syntax is simple sugar in the case when a tuple element lookup fails: \'a0when handling "x.y", first x is checked to see if it is a struct or tuple, and if so whether it has any member named y. \'a0If so, the dot syntax is resolved to refer to the named member.\'a0\
\
If it fails, the compiler treats this as syntactic sugar for "y x", which binds the left hand side to a function named on the right (with some specialized name lookup rules for "y") \'a0For example, consider something like:\
\
\'a0\'a0 x = myfile.lines.join("\\t")\
\
Assuming that none of these resolve to field expressions, this performs a lookup of "lines" taking a file, and resolves it to something that takes a T. \'a0Then it looks up "join", which takes a T and applies them. \'a0Then it applies the string to the result.\
\
The name lookup rules for dot syntax are similar to normal lookup, except:\
a) foo.x discards non-function candidates named 'x'\
b) local values are ignored (translation unit/namespace lookup only)\
c) normal lookup ignores things explicitly declared as methods, dot lookup doesn't.\
\
\
Note that the example above implies that 'join' must be declared as something like this:\
\
\'a0\'a0func join(whatever : T) -> (separator :\'a0string) -> string\
\
which has two arrows. \'a0If join were defined like this:\
\
\'a0\'a0func join2(whatever : T,\'a0separator :\'a0string)\'a0-> string\
\
then the user would have to write:\
\
\'a0x = (myfile.lines, "\\t").join2\
\
which is "not the effect that w're going for". \'a0 As a simpler example, consider something like:\
\
\'a0\'a0struct rect \{ width : int, height : int \}\
\
you'd have to define some methods as something like:\
\
\'a0\'a0func area(r : rect) -> int \{ return r.width*r.height \} \'a0 // this is not terrible.\
\'a0\'a0func print(r : rect) -> (os : ostream) -> void \{\
\'a0\'a0 \'a0os << r.width <<\'a0", " <<\'a0r.height << " area=" << r.area;\
\'a0\'a0\}\
\
to allow things like "myrect.print(os)"\
\
This is less than awesome because we lost the "-> void" sugar, people have to think about lots of arrows, and we don't have anything like "implicit this". \'a0For that reason, we introduce a new sugar for method syntax.\
\

\b \
Method Syntax:
\b0 \
\
There are lots of reasons to want to add methods (which are accessed through dot syntax) to types after the type is defined. \'a0Before we get to that, note that things like this are possible, if a bit kooky:\
\
\'a0\'a0 struct X \{\'a0f : int -> int\'a0\}\
\'a0\'a0 var a : X = ....\
\'a0\'a0 var b = \'a0x.f(4)\
\
However, this is not what most people want, because it inflates X by the size of a function pointer, and doesn't even have access to X (unless it is captured by the closure!). \'a0Instead, people want to add free functions to existing types, giving a capability along the same lines as Objective-C categories.\
\
As seen above, you can do this through var/func, but no one is going to be happy using the double arrow syntax for defining methods on types, and it is very very handy to have 'this' and implicit name lookup relative to 'this'. \'a0As such, Swift allows defining methods on types with the 'meth' keyword. \'a0The idea is simple, the methods above can be declared as:\
\
func rect::area() -> int \{ return width*height; \}\
\'a0\'a0\
func rect::print(os : ostream) \{\
\'a0\'a0os << width << ", " << height\'a0<< " area="\'a0<< this.area;\
\}\
\
This is just syntactic sugar for the exact function above. \'a0'meth' definitions are just sugar for func definitions (which are themselves just sugar for 'var' definitions), with the following effects:\
\
1. The instance of the type being acted on is available as 'this'.\
2. The named members of the type (like instance variables) are directly injected into the scope of the method body, so that width and height can be directly accessed. \'a0\
3. The type is correctly synthesized in "arrow form" and the default to "-> void" if no arrows are present is still in place.\
4. Free methods must still be accessed through "this.", like this.area.\
5. As the first example shows, no-argument methods can be defined with colon syntax for convenience and consistency.\
\
}