Overloading
===========

Function overloading in swift is very simple: you define multiple values with
the same name, and the compiler picks the right one. Overloading is only
allowed for values at translation unit or namespace scope (not variables within
a function). This is the same place where types are required on decls.

There are restrictions on what can be overloaded: if any member of a overload
set in a DeclContext is binary operator, then all must be, and at the same
precedence level.

The implementation of this is very simple: during name binding, lookup finds a
collection of values that match the specified name. This collection is stored in
an overload set expression (of dependent type), and type checking resolves the
ambiguity if it can, and reports the ambiguity if not.


// Unqualified name lookup "x" could/should ignore things explicitly declared as
// methods. Otherwise, the overload set will contain tons of junk that isn't
// useful, leading to ambiguities.

Dot Syntax
==========

Dot syntax is simple sugar in the case when a tuple element lookup fails: when
handling "x.y", first x is checked to see if it is a struct or tuple, and if so
whether it has any member named y. If so, the dot syntax is resolved to refer to
the named member.

If it fails, the compiler treats this as syntactic sugar for "y x", which binds
the left hand side to a function named on the right (with some specialized name
lookup rules for "y")  For example, consider something like:

   x = myfile.lines.join("\t")

Assuming that none of these resolve to field expressions, this performs a lookup
of "lines" taking a file, and resolves it to something that takes a T.  Then it
looks up "join", which takes a T and applies them.  Then it applies the string
to the result.

The name lookup rules for dot syntax are similar to normal lookup, except:
a) foo.x discards non-function candidates named 'x'
b) local values are ignored (translation unit/namespace lookup only)
c) normal lookup ignores things explicitly declared as methods, dot lookup
   doesn't.


Note that the example above implies that 'join' must be declared as something
like this:

  func join(whatever : T) -> (separator : string) -> string

which has two arrows.  If join were defined like this:

  func join2(whatever : T, separator : string) -> string

then the user would have to write:

 x = (myfile.lines, "\t").join2

which is "not the effect that we're going for".   As a simpler example, consider
something like:

  struct rect { width : int, height : int }

you'd have to define some methods as something like:

  func area(r : rect) -> int = r.width*r.height   // this is not terrible.
  func print(r : rect) -> (os : ostream) -> void {
    os << r.width << ", " << r.height << " area=" << r.area;
  }

to allow things like "myrect.print(os)"

This is less than awesome because we lost the "-> void" sugar, people have to
think about lots of arrows, and we don't have anything like "implicit this".
For that reason, we introduce a new sugar for method syntax.


Method Syntax
=============

There are lots of reasons to want to add methods (which are accessed through dot
syntax) to types after the type is defined.  Before we get to that, note that
things like this are possible, if a bit kooky:

   struct X { f : int -> int }
   var a : X = ....
   var b =  x.f(4)

However, this is not what most people want, because it inflates X by the size of
a function pointer, and doesn't even have access to X (unless it is captured by
the closure!).  Instead, people want to add free functions to existing types,
giving a capability along the same lines as Objective-C categories.

As seen above, you can do this through var/func, but no one is going to be happy
using the double arrow syntax for defining methods on types, and it is very very
handy to have 'this' and implicit name lookup relative to 'this'.  As such,
Swift allows defining methods on types with the 'meth' keyword.  The idea is
simple, the methods above can be declared as:

meth rect::area : int = width*height;
  
meth rect::print(os : ostream) {
  os << width << ", " << height << " area=" << this.area;
}

This is just syntactic sugar for the exact function above.  'meth' definitions
are just sugar for func definitions (which are themselves just sugar for 'var'
definitions), with the following effects:

1. The instance of the type being acted on is available as 'this'.
2. The named members of the type (like instance variables) are directly injected
   into the scope of the method body, so that width and height can be directly
   accessed.  
3. The type is correctly synthesized in "arrow form" and the default to
   "-> void" if no arrows are present is still in place.
4. Free methods must still be accessed through "this.", like this.area.
5. As the first example shows, no-argument methods can be defined with colon
   syntax for convenience and consistency.

