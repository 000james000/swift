.. @raise litre.TestsAreMissing
.. default-role:: term
.. title:: Modules Build Model


This document describes the process used to build a module from multiple Swift
source files.

.. contents:: :local:

See also the :doc:`Modules User Model <Modules>`.


Build Setups
============

Building a single source file
-----------------------------

A single Swift source file can be compiled to an object file using ``swift -c``.

.. sidebar:: Why is executable mode the default?

  By making executable mode the default, a single-file script can go from being
  interpreted to being compiled without any extra work. 

.. _executable-mode:
.. _library-mode:

By default, a file is compiled in "executable" mode, which

- permits top-level code, to be run via ``main`` when the program is launched,
  and
- does not generate global symbols for top-level variable declarations.

Files can also be compiled in "library" mode, which reverses these restrictions
(forbidding top-level code but allowing the declaration of module-scoped global
variables). This is accomplished by passing the ``-parse-as-library`` flag to
the compiler.

.. admonition:: TODO

  Not allowing true globals in the main source file seems like an awkward 
  limitation. The reason for this is that top-level variables should follow
  local variable definite initialization rules, but it seems like you might
  want to define true globals as well.


Building an entire module
-------------------------

Passing multiple source files to the Swift compiler driver will compile them
all to object files, then link the resulting object files into a binary. Each
file will be individually parsed and contains its own context, but non-private
declarations in each file are :ref:`implicitly visible <implicit-visibility>`
to every other file at the global scope. The compiler will save the
intermediate outputs in order to avoid recompiling every file in the module for
subsequent builds.

Passing multiple files to the compiler implies :ref:`library mode
<library-mode>`.

.. admonition:: TODO

  The compiler ought to be smart enough to figure out if there is one main
  source file and several library files. This would help the command line
  experience going from an interpreted script, spread over multiple files, to
  a compiled binary.


Interpreted Mode
----------------

The Swift compiler also supports being used as an interpreter through use of
the ``-i`` flag. In this mode, the single input file is parsed in
:ref:`executable mode <executable-mode>`. As with compilation, files can be
explicitly imported within the source using ``import``, or made implicitly
visible through the use of a :ref:`module source list <module-source-list>`.
However, in interpreter mode *all imported source files* are processed for code
generation, since there's no chance to link separate object files later.

Swift source files support the Unix convention of a `shebang`__ line at the
top of the file; this line will be recognized and skipped in the compiler's
interpreter mode.

__ http://goto.apple.com/?http://en.wikipedia.org/wiki/Shebang_(Unix)


Build Details
=============

.. admonition:: FIXME

  How does Xcode tell Swift about the other targets in the project, which should
  be available for import, but may not have been built yet? (Alternately, how
  does Xcode discover that they are dependencies?)


Dependency Analysis
-------------------

The build system's first duty is to decide what needs to be rebuilt, based on
output files generated by the last build. There are two ways a file might need
to be rebuilt:

1. The user has changed that file since the last build.
2. The user changed a decl the file depended on (directly or indirectly).

The build system makes a list of all files that have been changed since the
last build. Each file is parsed and its public decls are checked against the
public decls of the last build. If the decls are the same, dependent files do
not need to be recompiled.

Depending on how the declaration is used elsewhere, some subset of the entire
module may need to be recompiled. The most conservative answer is to recompile
the entire module; here are some possible refinements to that rule:

- If a declaration is only used in a function body, the function's interface
  has not been affected, and users of the function do not need to be recompiled.
- Adding an overload requires all users of a function to be recompiled, since
  it may change the overload resolution.
- Adding or removing a method or property on a class or protocol affects any 
  subclasses, adopters, or extensions of the type, as well as any users of the
  member, because it may change name binding. However, it does not affect files
  that simply have references with the given type and only call other methods.
  This does also applies to structs and enums unless the change is to a case or
  stored property.

.. note::

  If a function that may have been inlined changes or uses a declaration that
  may have changed, any file using that function will need to be recompiled as
  well, even if the function's interface didn't change.

.. admonition:: TODO

  Optimization beyond simply comparing the decl interfaces will require some
  kind of "build index" that tracks how decls are used in each file. This is
  more fine-grained than file-granular dependencies, and also accounts for
  "anti-dependencies", where introducing a new name in file A can cause file
  B to depend on A without any change in B.


AST Serialization
-----------------

When compiling each file, the compiler will load all other files in the target
into the current module. The output of compilation will be an object file or
LLVM bitcode file (for LTO, in `wrapper format`__) containing both the compiled
code and a serialized AST. This AST has two purposes: to speed up the build,
and for use in publishing a public API for the module.

__ http://goto.apple.com/?http://llvm.org/docs/BitCodeFormat.html#bitcode-wrapper-format

When the compiler is loading the other files in the module, it will first check
if any of the object files for the other sources are present and up-to-date. If
one is, the compiler will try to load a serialized AST from it first before
falling back to the source file.

.. admonition:: TODO

  There's still a fair amount of refactoring that needs to happen for this to 
  work.

.. sidebar:: Why not teach the linker to combine ASTs, or structure them so
             that this happens automatically?

  Each object file might have cross-references to the others, and at the very
  least these references should be resolved at compile time, rather than making
  every user of the module pay the price in the future. Making this a separate
  tool means that the system linker can still be used to link Swift object
  files into a binary.

Once all source files have been compiled, the final binary must be linked.
In addition to the normal linking of object files that happens in C or
Objective-C, Swift needs to merge the serialized ASTs from all the source files, so that the binary itself can be used as an imported module.

.. admonition:: TODO

  The tool for this AST linking hasn't been written yet.


Objective-C Interoperability
============================

.. admonition:: FIXME

  Write this section. Across module boundaries is the easy case: they just look
  like any other modules. (Though, note: how does this work for user 
  frameworks?) So, how to:
  
  - load Objective-C from Swift? (do we need an explicit module map? do we get
    implicit visibility? who knows?)
  - load Swift from Objective-C? (what do you @import? if that depends on Clang
    modules, how to get the same decls? if it depends on other sources in the
    same target, how to get the same decls?)
  - deal with mutual dependencies? (supposedly, everything imported from Clang
    has been fully type-checked. Clang won't even have a way to type-check
    things from Swift, but Swift doesn't have forward declarations.)
