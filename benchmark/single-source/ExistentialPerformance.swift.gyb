//===--- ExistentialPerformance.swift -------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

% # Ignore the following warning. This _is_ the correct file to edit.
////////////////////////////////////////////////////////////////////////////////
// WARNING: This file is manually generated from .gyb template and should not
// be directly modified. Instead, change ExistentialPerformance.swift.gyb
// and run scripts/generate_harness/generate_harness.py to regenerate this file.
////////////////////////////////////////////////////////////////////////////////

import TestsUtils

%{
FN = 'ExistentialTest'
Groups = (
  ['Array' + g for g in ['ConditionalShift', 'Mutating', 'OneMethodCall',
                         'Shift', 'TwoMethodCalls']] +
  ['MutatingAndNonMutating', 'Mutating', 'OneMethodCall',
  'PassExistentialOneMethodCall', 'PassExistentialTwoMethodCalls',
  'TwoMethodCalls']
)
Vars = [(0, 0), (1, 3), (2, 7), (3, 13)]
Refs = ['ClassValueBuffer' + str(i) for i in range(1, 5)]
Vals = ['IntValueBuffer' + str(i) for i in range(0, 5)]
Variants = Refs + Vals
Names = [FN + group + '_' + variant for group in Groups for variant in Variants]

Setup = """
  let existentialArray = initExistentialArray(withType: T.self, count: 128)
  let existential = initExistential(withType: T.self)
  let existential2 = initExistential(withType: T.self)
  var existential = initExistential(withType: T.self)
  var existentialArray = initExistentialArray(withType: T.self, count: 128)
""".splitlines()[1:]
Setup = [Setup[0], Setup[1], '\n'.join(Setup[1:3]), Setup[3], Setup[4]]

Workloads = [
  ('OneMethodCall', Setup[1], '20_000', """
    if !existential.doIt() {
      fatalError("expected true")
    }
"""),
  ('TwoMethodCalls', Setup[1], '20_000', """
    if !existential.doIt()  || !existential.reallyDoIt() {
      fatalError("expected true")
    }
"""),
  ('PassExistentialOneMethodCall', Setup[2], '20_000', """
    if !passExistentialTwiceOneMethodCall(existential, existential2) {
      fatalError("expected true")
    }
"""),
  ('PassExistentialTwoMethodCalls', Setup[2], '20_000', """
    if !passExistentialTwiceTwoMethodCalls(existential, existential2) {
      fatalError("expected true")
    }
"""),
  ('Mutating', Setup[3], '10_000', """
    if !existential.mutateIt()  {
      fatalError("expected true")
    }
"""),
  ('MutatingAndNonMutating', Setup[3], '10_000', """
    let _ = existential.doIt()
    if !existential.mutateIt()  {
      fatalError("expected true")
    }
"""),
  ('ArrayOneMethodCall', Setup[0], '100', """
    for elt in existentialArray {
      if !elt.doIt()  {
        fatalError("expected true")
      }
    }
"""),
  ('ArrayTwoMethodCalls', Setup[0], '100', """
    for elt in existentialArray {
      if !elt.doIt() || !elt.reallyDoIt() {
        fatalError("expected true")
      }
    }
"""),
  ('ArrayMutating', Setup[4], '100', """
    for i in 0 ..< existentialArray.count {
      if !existentialArray[i].mutateIt()  {
        fatalError("expected true")
      }
    }
"""),
  ('ArrayShift', Setup[4], '10', """
    for i in 0 ..< existentialArray.count-1 {
      existentialArray.swapAt(i, i+1)
    }
"""),
  ('ArrayConditionalShift', Setup[4], '10', """
    for i in 0 ..< existentialArray.count-1 {
      let curr = existentialArray[i]
      if curr.doIt() {
        existentialArray[i] = existentialArray[i+1]
        existentialArray[i+1] = curr
      }
    }
"""),
]
}%
public let ExistentialPerformance = [
% for Name in Names:
  BenchmarkInfo(name: "${Name}", runFunction: run_${Name}, tags: [.unstable${
    ', .api, .Array' if 'Array' in Name else ''}]),
% end
]

protocol Existential {
  init()
  func doIt() -> Bool
  func reallyDoIt() -> Bool
  mutating func mutateIt() -> Bool
}

struct IntValueBuffer0 : Existential {
  func doIt() -> Bool {
    return true
	}
  func reallyDoIt() -> Bool {
    return true
  }
  mutating func mutateIt() -> Bool {
    return true
	}
}

func next(_ x: inout Int, upto mod: Int) {
  x = (x + 1) % (mod + 1)
}

% for (V, i) in [(v, int(filter(str.isdigit, v))) for v in Vals[1:]]:
struct ${V} : Existential {
	${'\n	'.join(['var f{0}: Int = {1}'.format(vi, v)
                for (vi, v) in Vars[0:i]])}

  func doIt() -> Bool {
    return f0 == 0
	}
  func reallyDoIt() -> Bool {
   return ${
      'true' if i == 1 else
      ' && '.join(['f{0} == {1}'.format(vi, v) for (vi, v) in Vars[0:i]])}
  }
  mutating func mutateIt() -> Bool {
    ${
      '\n    '.join(['next(&f{0}, upto: {1})'.format(vi, (v if v > 0 else 1))
                     for (vi, v) in Vars[0:i]])}
    return true
	}
}

% end
class Klazz {
  var f0: Int = 0
  var f1: Int = 3

  func doIt() -> Bool {
    return f0 == 0
	}
  func reallyDoIt() -> Bool {
   return f0 == 0 && f1 == 3
  }

  func mutateIt() -> Bool{
    next(&f0, upto: 1)
    next(&f1, upto: 3)
    return true
	}
}

% for (V, i) in [(v, int(filter(str.isdigit, v))) for v in Refs]:
struct ${V} : Existential {
	${'\n	'.join([('var f{0}: Klazz = Klazz()'.format(vi) if vi < 3 else
                 'var f3: Int = 0') for (vi, _) in Vars[0:i]])}

  func doIt() -> Bool {
    return f0.doIt()
	}
  func reallyDoIt() -> Bool {
   return f0.reallyDoIt()
  }

  mutating func mutateIt() -> Bool{
    return f0.mutateIt()
  }
}

% end

@inline(never)
func initExistential<T: Existential>(withType: T.Type) -> Existential {
  return T()
}

@inline(never)
func initExistentialArray<T: Existential>(withType: T.Type, count c: Int) -> [Existential] {
  return [T](repeating: T(), count: c)
}

@inline(never)
func passExistentialTwiceOneMethodCall(_ e0: Existential, _ e1: Existential) -> Bool {
  return e0.doIt() && e1.doIt()
}

@inline(never)
func passExistentialTwiceTwoMethodCalls(_ e0: Existential, _ e1: Existential) -> Bool {
  return e0.doIt() && e1.doIt() && e0.reallyDoIt() && e1.reallyDoIt()
}
% for (name, setup, multiple, workload) in Workloads:
${"""
func runTest{0}<T: Existential>(withType: T.Type, numberOfTimes N: Int) {{
{1}
  for _ in 0 ..< N * {2} {{{3}  }}
}}""".format(name, setup, multiple, workload)}
% end

% for (Name, _, _, _) in Workloads:
// Test${Name}.
%   for Variant in Vals + Refs:
public func run_ExistentialTest${Name}_${Variant}(_ N: Int) {
  runTest${Name}(withType: ${Variant}.self, numberOfTimes: N)
}
%   end

% end
// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
